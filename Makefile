.PHONY: all init bootstrap build release test test-suite test-run clean distclean \
        build-kernel build-lang-reader emit-kernel-ast emit-lang-reader-ast emit-compiler-ast \
        seed-bootstrap test-composition generate-os-layer llvm-verify

# Get git info
GIT_COMMIT := $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
GIT_DIRTY := $(shell git diff --quiet 2>/dev/null || echo "-dirty")
VERSION := $(GIT_COMMIT)$(GIT_DIRTY)

# OS detection
UNAME := $(shell uname -s)
ifeq ($(UNAME),Darwin)
    PLATFORM := macos
else
    PLATFORM := linux
endif

# Target selection (environment variables)
# LANGOS: auto-detected from platform
# LANGBE: x86 (default for now), llvm (future)
# LANGLIBC: none (default, use raw syscalls), libc (use system libc)
LANGOS ?= $(PLATFORM)
LANGBE ?= x86
LANGLIBC ?= none

# OS layer file selection
# macOS MUST use libc (macos_arm64.lang uses hex literals which lexer doesn't support)
# Linux can use raw syscalls
ifeq ($(LANGOS),macos)
    OS_LAYER := std/os/libc.lang
else ifeq ($(LANGLIBC),libc)
    OS_LAYER := std/os/libc.lang
else ifeq ($(LANGOS),linux)
    OS_LAYER := std/os/linux_x86_64.lang
else
    $(error Unknown LANGOS: $(LANGOS). Valid values: linux, macos)
endif

# Bootstrap: LLVM IR is primary (cross-platform), x86 is secondary (Linux fast path)
ifeq ($(PLATFORM),macos)
    BOOTSTRAP_LL := bootstrap/current/compiler_macos.ll
    BOOTSTRAP_LIBC := std/os/libc_macos.lang
else
    BOOTSTRAP_LL := bootstrap/current/compiler_linux.ll
    BOOTSTRAP_LIBC := std/os/libc.lang
endif
# Legacy x86 bootstrap (Linux only)
BOOTSTRAP_X86 := $(shell if [ -f bootstrap/current/compiler.s ]; then echo bootstrap/current/compiler.s; else echo bootstrap/current.s; fi)

# Compiler paths
LANG := out/lang
LANG_NEXT := out/lang_next

# Default target
all: build

# Generate std/os.lang based on LANGOS
generate-os-layer:
	@echo 'include "$(OS_LAYER)"' > std/os.lang

# Generate src/version_info.lang with build-time constants
# Architecture detection
ARCH := $(shell uname -m)
ifeq ($(ARCH),arm64)
    BUILD_ARCH := arm64
else ifeq ($(ARCH),aarch64)
    BUILD_ARCH := arm64
else
    BUILD_ARCH := x86_64
endif

# Infer libc mode: macOS always uses libc, Linux uses OS_LAYER
ifeq ($(LANGOS),macos)
    EFFECTIVE_LIBC := system
else ifeq ($(findstring libc,$(OS_LAYER)),libc)
    EFFECTIVE_LIBC := system
else
    EFFECTIVE_LIBC := none
endif

generate-version-info:
	@BOOTSTRAP_FROM=$$(cat bootstrap/current/COMMIT 2>/dev/null || echo "unknown"); \
	echo '// Auto-generated by Makefile - do not edit manually' > src/version_info.lang; \
	echo 'var LANG_VERSION *u8 = "0.1.0";' >> src/version_info.lang; \
	echo 'var LANG_COMMIT *u8 = "$(GIT_COMMIT)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_BACKEND *u8 = "$(LANGBE)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_OS *u8 = "$(LANGOS)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_ARCH *u8 = "$(BUILD_ARCH)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_LIBC *u8 = "$(EFFECTIVE_LIBC)";' >> src/version_info.lang; \
	echo "var LANG_BOOTSTRAP_FROM *u8 = \"$$BOOTSTRAP_FROM\";" >> src/version_info.lang

# Init: build from bootstrap LLVM IR (cross-platform)
init:
	@mkdir -p out
	@echo "Initializing from $(BOOTSTRAP_LL)..."
	clang -O2 $(BOOTSTRAP_LL) -o out/lang_bootstrap
	ln -sf lang_bootstrap $(LANG)
	@echo "Created: $(LANG) -> lang_bootstrap"

# Build: compile src/*.lang using lang -> lang_next
# Uses LLVM on macOS, x86 on Linux
build: generate-os-layer generate-version-info
	@if [ ! -f $(LANG) ] && [ ! -L $(LANG) ]; then \
		$(MAKE) init; \
	fi
	@mkdir -p out
ifeq ($(PLATFORM),macos)
	LANGBE=llvm LANGOS=macos $(LANG) std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o out/lang_$(VERSION).ll
	clang -O2 out/lang_$(VERSION).ll -o out/lang_$(VERSION)
else
	$(LANG) std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o out/lang_$(VERSION).s
	as out/lang_$(VERSION).s -o out/lang_$(VERSION).o
	ld out/lang_$(VERSION).o -o out/lang_$(VERSION)
	rm -f out/lang_$(VERSION).o
endif
	ln -sf lang_$(VERSION) $(LANG_NEXT)
	@echo "Created: $(LANG_NEXT) -> lang_$(VERSION)"

# ============================================================
# BOOTSTRAP: The ONE command to verify and promote
# ============================================================
# LLVM-FIRST: All verification uses LLVM IR (cross-platform).
# x86 assembly is only emitted as optional artifact on Linux.
#
# Verification chain:
#   Stage 1: Root of trust (ctrusted from LLVM bootstrap)
#   Stage 2: Generation 1 (kernel1 built by trusted, LLVM output)
#   Stage 3: Generation 2 + LLVM fixed point check
#   Stage 4: AST fixed point check
#   Stage 5: Test suite validation
#   Stage 6: Promote (only if all checks pass)
#
# Run this ONE command. Nothing else. No shortcuts.
bootstrap: generate-os-layer
	@# Generate version info with LLVM backend (bootstrap always uses LLVM)
	@BOOTSTRAP_FROM=$$(cat bootstrap/current/COMMIT 2>/dev/null || echo "unknown"); \
	echo '// Auto-generated by Makefile - do not edit manually' > src/version_info.lang; \
	echo 'var LANG_VERSION *u8 = "0.1.0";' >> src/version_info.lang; \
	echo 'var LANG_COMMIT *u8 = "$(GIT_COMMIT)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_BACKEND *u8 = "llvm";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_OS *u8 = "$(LANGOS)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_ARCH *u8 = "$(BUILD_ARCH)";' >> src/version_info.lang; \
	echo 'var LANG_BUILD_LIBC *u8 = "$(EFFECTIVE_LIBC)";' >> src/version_info.lang; \
	echo "var LANG_BOOTSTRAP_FROM *u8 = \"$$BOOTSTRAP_FROM\";" >> src/version_info.lang
	@echo "╔════════════════════════════════════════════════════════════════╗"
	@echo "║           BOOTSTRAP: VERIFY + PROMOTE (LLVM-FIRST)             ║"
	@echo "╚════════════════════════════════════════════════════════════════╝"
	@echo ""
	@mkdir -p out out/ast /tmp/bootstrap_verify
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 1: ROOT OF TRUST                                         │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@echo "Platform: $(PLATFORM)"
	@echo "Bootstrap: $(BOOTSTRAP_LL)"
	@if [ ! -f $(BOOTSTRAP_LL) ]; then echo "ERROR: $(BOOTSTRAP_LL) not found"; exit 1; fi
	clang -O2 $(BOOTSTRAP_LL) -o /tmp/bootstrap_verify/ctrusted
	@echo "Built: ctrusted from $(BOOTSTRAP_LL)"
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 2: GENERATION 1 (Built by Trusted)                       │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Set up OS layer for LLVM compilation
	@echo 'include "$(BOOTSTRAP_LIBC)"' > std/os.lang
	@# Build kernel1 using LLVM backend
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/bootstrap_verify/ctrusted std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/kernel1.ll
	clang -O2 /tmp/bootstrap_verify/kernel1.ll -o /tmp/bootstrap_verify/kernel1
	@echo "Built: kernel1 (LLVM)"
	@# Emit reader AST 1 using kernel1
	/tmp/bootstrap_verify/kernel1 src/lang_reader.lang --emit-expanded-ast -o /tmp/bootstrap_verify/reader_ast1.ast
	@echo "Emitted: reader_ast1.ast ($$(wc -l < /tmp/bootstrap_verify/reader_ast1.ast) lines)"
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 3: GENERATION 2 + 3 (LLVM FIXED POINT)                   │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Build kernel2 (kernel1 compiles sources)
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/bootstrap_verify/kernel1 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/kernel2.ll
	clang -O2 /tmp/bootstrap_verify/kernel2.ll -o /tmp/bootstrap_verify/kernel2
	@echo "Built: kernel2 (LLVM)"
	@# Build kernel3 (kernel2 compiles sources) for true fixed point
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/bootstrap_verify/kernel2 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/kernel3.ll
	@echo ""
	@echo "Checking LLVM FIXED POINT (kernel2.ll === kernel3.ll)..."
	@if diff -q /tmp/bootstrap_verify/kernel2.ll /tmp/bootstrap_verify/kernel3.ll > /dev/null; then \
		echo "✓ LLVM FIXED POINT VERIFIED"; \
	else \
		echo ""; \
		echo "!!! LLVM FIXED POINT FAILED !!!"; \
		echo "kernel2.ll and kernel3.ll differ:"; \
		diff /tmp/bootstrap_verify/kernel2.ll /tmp/bootstrap_verify/kernel3.ll | head -20; \
		exit 1; \
	fi
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 4: AST FIXED POINT                                       │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Emit reader AST 2 using kernel2
	/tmp/bootstrap_verify/kernel2 src/lang_reader.lang --emit-expanded-ast -o /tmp/bootstrap_verify/reader_ast2.ast
	@echo ""
	@echo "Checking AST FIXED POINT (reader_ast1 === reader_ast2)..."
	@if diff -q /tmp/bootstrap_verify/reader_ast1.ast /tmp/bootstrap_verify/reader_ast2.ast > /dev/null; then \
		echo "✓ AST FIXED POINT VERIFIED"; \
	else \
		echo ""; \
		echo "!!! AST FIXED POINT FAILED !!!"; \
		echo "reader_ast1.ast and reader_ast2.ast differ:"; \
		diff /tmp/bootstrap_verify/reader_ast1.ast /tmp/bootstrap_verify/reader_ast2.ast | head -20; \
		exit 1; \
	fi
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 5: GENERATE BOOTSTRAP FILES                              │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Generate bootstrap files for both platforms using kernel2
	@echo "Generating cross-platform bootstrap files..."
	@# Linux LLVM bootstrap
	@echo 'include "std/os/libc.lang"' > std/os.lang
	LANGBE=llvm LANGOS=linux /tmp/bootstrap_verify/kernel2 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/compiler_linux.ll
	@echo "Compiling compiler_linux.ll with clang..."
	@rm -f /tmp/bootstrap_verify/compiler_linux
	clang -O2 /tmp/bootstrap_verify/compiler_linux.ll -o /tmp/bootstrap_verify/compiler_linux || { echo "ERROR: compiler_linux.ll failed to compile"; exit 1; }
	@echo "✓ compiler_linux.ll compiled"
	@# macOS LLVM bootstrap
	@echo 'include "std/os/libc_macos.lang"' > std/os.lang
	LANGBE=llvm LANGOS=macos /tmp/bootstrap_verify/kernel2 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/compiler_macos.ll
	@echo "Compiling compiler_macos.ll with clang..."
	@rm -f /tmp/bootstrap_verify/compiler_macos
	clang -O2 /tmp/bootstrap_verify/compiler_macos.ll -o /tmp/bootstrap_verify/compiler_macos || { echo "ERROR: compiler_macos.ll failed to compile"; exit 1; }
	@echo "✓ compiler_macos.ll compiled"
	@# Restore OS layer for test suite
	@echo 'include "$(BOOTSTRAP_LIBC)"' > std/os.lang
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 6: VALIDATION (Test Final Binary)                        │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Test the FINAL platform-specific binary (what we actually promote)
	@echo "Testing final compiler_$(PLATFORM) binary..."
	COMPILER=/tmp/bootstrap_verify/compiler_$(PLATFORM) ./test/run_llvm_suite.sh
	@# Install the tested binary to out/lang
	cp /tmp/bootstrap_verify/compiler_$(PLATFORM) out/lang
	cp /tmp/bootstrap_verify/compiler_$(PLATFORM).ll out/lang_$(VERSION).ll
	@echo "Installed: out/lang (from compiler_$(PLATFORM))"
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 7: ARCHIVE + PROMOTE                                     │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Archive current bootstrap to GitHub release + local cache
	@OLD_COMMIT=$$(cat bootstrap/current/COMMIT 2>/dev/null || echo ""); \
	if [ -n "$$OLD_COMMIT" ] && [ "$$OLD_COMMIT" != "$(GIT_COMMIT)" ]; then \
		echo "Archiving old bootstrap $$OLD_COMMIT..."; \
		tar -czf /tmp/bootstrap-$$OLD_COMMIT.tar.gz -C bootstrap current/; \
		if gh release view bootstrap-$$OLD_COMMIT >/dev/null 2>&1; then \
			echo "  GitHub release already exists"; \
		else \
			gh release create bootstrap-$$OLD_COMMIT /tmp/bootstrap-$$OLD_COMMIT.tar.gz \
				--title "Bootstrap $$OLD_COMMIT" \
				--notes "Bootstrap from commit $$OLD_COMMIT" \
				--latest=false || { echo "ERROR: Failed to create GitHub release. Bootstrap aborted."; exit 1; }; \
			echo "  Created GitHub release bootstrap-$$OLD_COMMIT"; \
		fi; \
		rm -f /tmp/bootstrap-$$OLD_COMMIT.tar.gz; \
		echo "  Saving to local archive..."; \
		mkdir -p bootstrap/archive/$$OLD_COMMIT; \
		cp -r bootstrap/current/* bootstrap/archive/$$OLD_COMMIT/; \
		echo "  Saved bootstrap/archive/$$OLD_COMMIT/"; \
		echo "  Managing local archive (10 folders, 10 tarballs)..."; \
		cd bootstrap/archive && \
		FOLDERS=$$(ls -dt */ 2>/dev/null | head -20 | sed 's|/||'); \
		KEEP_LIVE=$$(echo "$$FOLDERS" | head -10); \
		COMPRESS=$$(echo "$$FOLDERS" | tail -n +11 | head -10); \
		DELETE=$$(echo "$$FOLDERS" | tail -n +21); \
		for f in $$COMPRESS; do \
			if [ -d "$$f" ] && [ ! -f "$$f.tar.gz" ]; then \
				tar -czf "$$f.tar.gz" "$$f" && rm -rf "$$f" && echo "    Compressed $$f"; \
			fi; \
		done; \
		for f in $$DELETE; do \
			rm -rf "$$f" "$$f.tar.gz" 2>/dev/null && echo "    Deleted $$f (still in GitHub)"; \
		done; \
		OLD_TARBALLS=$$(ls -t *.tar.gz 2>/dev/null | tail -n +11); \
		for t in $$OLD_TARBALLS; do \
			rm -f "$$t" && echo "    Deleted $$t (still in GitHub)"; \
		done; \
	fi
	@# Update bootstrap/current/ with new bootstrap
	@mkdir -p bootstrap/current/lang_reader
	cp /tmp/bootstrap_verify/compiler_linux.ll bootstrap/current/compiler_linux.ll
	cp /tmp/bootstrap_verify/compiler_macos.ll bootstrap/current/compiler_macos.ll
	cp /tmp/bootstrap_verify/reader_ast1.ast bootstrap/current/lang_reader/source.ast
	@echo "$(GIT_COMMIT)" > bootstrap/current/COMMIT
	@# Write provenance
	@echo "compiler_linux.ll:" > bootstrap/current/PROVENANCE
	@echo "  sha256: $$(shasum -a 256 bootstrap/current/compiler_linux.ll | cut -d' ' -f1)" >> bootstrap/current/PROVENANCE
	@echo "compiler_macos.ll:" >> bootstrap/current/PROVENANCE
	@echo "  sha256: $$(shasum -a 256 bootstrap/current/compiler_macos.ll | cut -d' ' -f1)" >> bootstrap/current/PROVENANCE
	@echo "built_by: $$(cat bootstrap/current/COMMIT 2>/dev/null || echo none)" >> bootstrap/current/PROVENANCE
	@echo "built_at: $$(date -Iseconds)" >> bootstrap/current/PROVENANCE
	@echo "source_commit: $(GIT_COMMIT)" >> bootstrap/current/PROVENANCE
	@echo "verification:" >> bootstrap/current/PROVENANCE
	@echo "  llvm_fixed_point: true (kernel2.ll === kernel3.ll)" >> bootstrap/current/PROVENANCE
	@echo "  ast_fixed_point: true (reader_ast1 === reader_ast2)" >> bootstrap/current/PROVENANCE
	@echo "  clang_compiled: true (both .ll files compile with clang -O2)" >> bootstrap/current/PROVENANCE
	@echo "  test_suite: true (ran on compiler_$(PLATFORM) binary)" >> bootstrap/current/PROVENANCE
	@echo "lang_reader/source.ast:" >> bootstrap/current/PROVENANCE
	@echo "  sha256: $$(shasum -a 256 bootstrap/current/lang_reader/source.ast | cut -d' ' -f1)" >> bootstrap/current/PROVENANCE
	@echo "  lines: $$(wc -l < bootstrap/current/lang_reader/source.ast)" >> bootstrap/current/PROVENANCE
	@rm -rf /tmp/bootstrap_verify
	@echo ""
	@echo "╔════════════════════════════════════════════════════════════════╗"
	@echo "║                    BOOTSTRAP COMPLETE                          ║"
	@echo "╠════════════════════════════════════════════════════════════════╣"
	@echo "║ Verified:                                                      ║"
	@echo "║   ✓ LLVM fixed point (kernel2.ll === kernel3.ll)               ║"
	@echo "║   ✓ AST fixed point (reader_ast1 === reader_ast2)              ║"
	@echo "║   ✓ Both .ll files clang-compiled                              ║"
	@echo "║   ✓ Test suite on final binary (compiler_$(PLATFORM))          ║"
	@echo "║                                                                ║"
	@echo "║ Installed: out/lang = compiler_$(PLATFORM) (tested)            ║"
	@echo "║                                                                ║"
	@echo "║ Promoted: bootstrap/current/ ($(GIT_COMMIT))                   ║"
	@echo "║   - compiler_linux.ll (clang-verified)                         ║"
	@echo "║   - compiler_macos.ll (clang-verified, tested on macos)        ║"
	@echo "║   - lang_reader/source.ast                                     ║"
	@echo "╚════════════════════════════════════════════════════════════════╝"
	@echo ""
	@echo "Rebuild out/lang: clang -O2 bootstrap/current/compiler_$(PLATFORM).ll -o out/lang"

# bootstrap-local: Same as bootstrap but saves archive locally instead of GitHub
# Use this if you don't have release access
bootstrap-local: generate-os-layer
	@echo "Running bootstrap with local archive (no GitHub release)..."
	@$(MAKE) bootstrap-verify
	@# Archive to local cache (same logic as main bootstrap, minus GitHub)
	@OLD_COMMIT=$$(cat bootstrap/current/COMMIT 2>/dev/null || echo ""); \
	if [ -n "$$OLD_COMMIT" ] && [ "$$OLD_COMMIT" != "$(GIT_COMMIT)" ]; then \
		echo "Archiving old bootstrap $$OLD_COMMIT locally..."; \
		mkdir -p bootstrap/archive/$$OLD_COMMIT; \
		cp -r bootstrap/current/* bootstrap/archive/$$OLD_COMMIT/; \
		echo "  Saved bootstrap/archive/$$OLD_COMMIT/"; \
		echo "  Managing local archive (10 folders, 10 tarballs)..."; \
		cd bootstrap/archive && \
		FOLDERS=$$(ls -dt */ 2>/dev/null | head -20 | sed 's|/||'); \
		COMPRESS=$$(echo "$$FOLDERS" | tail -n +11 | head -10); \
		DELETE=$$(echo "$$FOLDERS" | tail -n +21); \
		for f in $$COMPRESS; do \
			if [ -d "$$f" ] && [ ! -f "$$f.tar.gz" ]; then \
				tar -czf "$$f.tar.gz" "$$f" && rm -rf "$$f" && echo "    Compressed $$f"; \
			fi; \
		done; \
		for f in $$DELETE; do \
			rm -rf "$$f" "$$f.tar.gz" 2>/dev/null && echo "    Deleted $$f"; \
		done; \
		OLD_TARBALLS=$$(ls -t *.tar.gz 2>/dev/null | tail -n +11); \
		for t in $$OLD_TARBALLS; do \
			rm -f "$$t" && echo "    Deleted $$t"; \
		done; \
	fi
	@# Update bootstrap/current/
	@mkdir -p bootstrap/current/lang_reader
	@echo 'include "std/os/libc.lang"' > std/os.lang
	LANGBE=llvm LANGOS=linux /tmp/bootstrap_verify/kernel2 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o bootstrap/current/compiler_linux.ll
	@echo 'include "std/os/libc_macos.lang"' > std/os.lang
	LANGBE=llvm LANGOS=macos /tmp/bootstrap_verify/kernel2 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o bootstrap/current/compiler_macos.ll
	cp /tmp/bootstrap_verify/reader_ast1.ast bootstrap/current/lang_reader/source.ast
	@echo "$(GIT_COMMIT)" > bootstrap/current/COMMIT
	@echo 'include "$(BOOTSTRAP_LIBC)"' > std/os.lang
	@rm -rf /tmp/bootstrap_verify
	@echo "Bootstrap complete (local archive). Run: clang -O2 bootstrap/current/compiler_$(PLATFORM).ll -o out/lang"

# bootstrap-verify: Run verification only (no promote) - used by bootstrap-local
bootstrap-verify: generate-os-layer
	@mkdir -p out out/ast /tmp/bootstrap_verify
	@if [ ! -f $(BOOTSTRAP_LL) ]; then echo "ERROR: $(BOOTSTRAP_LL) not found"; exit 1; fi
	clang -O2 $(BOOTSTRAP_LL) -o /tmp/bootstrap_verify/ctrusted
	@echo 'include "$(BOOTSTRAP_LIBC)"' > std/os.lang
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/bootstrap_verify/ctrusted std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/kernel1.ll
	clang -O2 /tmp/bootstrap_verify/kernel1.ll -o /tmp/bootstrap_verify/kernel1
	/tmp/bootstrap_verify/kernel1 src/lang_reader.lang --emit-expanded-ast -o /tmp/bootstrap_verify/reader_ast1.ast
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/bootstrap_verify/kernel1 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/kernel2.ll
	clang -O2 /tmp/bootstrap_verify/kernel2.ll -o /tmp/bootstrap_verify/kernel2
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/bootstrap_verify/kernel2 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang src/sexpr_reader.lang src/main.lang -o /tmp/bootstrap_verify/kernel3.ll
	@if ! diff -q /tmp/bootstrap_verify/kernel2.ll /tmp/bootstrap_verify/kernel3.ll > /dev/null; then \
		echo "LLVM FIXED POINT FAILED"; exit 1; \
	fi
	/tmp/bootstrap_verify/kernel2 src/lang_reader.lang --emit-expanded-ast -o /tmp/bootstrap_verify/reader_ast2.ast
	@if ! diff -q /tmp/bootstrap_verify/reader_ast1.ast /tmp/bootstrap_verify/reader_ast2.ast > /dev/null; then \
		echo "AST FIXED POINT FAILED"; exit 1; \
	fi
	cp /tmp/bootstrap_verify/kernel2 out/lang
	COMPILER=/tmp/bootstrap_verify/kernel2 ./test/run_llvm_suite.sh

# ============================================================
# LLVM-VERIFY: Mac-only verification without x86 bootstrap
# ============================================================
# Use this on Mac to verify compiler changes work:
#   1. Builds gen1 compiler using LLVM backend
#   2. Builds gen2 compiler using gen1
#   3. Checks LLVM IR fixed point (gen1.ll === gen2.ll)
#   4. Runs full test suite
#
# Requires: ./lang (bootstrap from llvm_libc_macos.ll)
# Usage: make llvm-verify
llvm-verify:
	@echo "╔════════════════════════════════════════════════════════════════╗"
	@echo "║           LLVM-VERIFY: Mac Bootstrap Verification              ║"
	@echo "╚════════════════════════════════════════════════════════════════╝"
	@echo ""
	@if [ ! -f ./lang ]; then \
		echo "ERROR: ./lang not found. Run: clang bootstrap/llvm_libc_macos.ll -o lang"; \
		exit 1; \
	fi
	@mkdir -p out /tmp/llvm_verify
	@# Set up macOS OS layer
	@echo 'include "std/os/libc_macos.lang"' > std/os.lang
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 1: Build gen1 compiler (bootstrap -> gen1)               │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	LANGBE=llvm LANGOS=macos ./lang std/core.lang src/version_info.lang src/lexer.lang src/parser.lang \
		src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang \
		src/sexpr_reader.lang src/main.lang -o /tmp/llvm_verify/gen1.ll
	clang /tmp/llvm_verify/gen1.ll -o /tmp/llvm_verify/gen1
	@echo "Built: gen1"
	@# Copy to out/lang for reader compilation
	cp /tmp/llvm_verify/gen1 out/lang
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 2: Build gen2 compiler (gen1 -> gen2)                    │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	LANGBE=llvm LANGOS=macos /tmp/llvm_verify/gen1 std/core.lang src/version_info.lang src/lexer.lang src/parser.lang \
		src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang \
		src/sexpr_reader.lang src/main.lang -o /tmp/llvm_verify/gen2.ll
	@echo ""
	@echo "Checking LLVM IR FIXED POINT (gen1.ll === gen2.ll)..."
	@if diff -q /tmp/llvm_verify/gen1.ll /tmp/llvm_verify/gen2.ll > /dev/null; then \
		echo "✓ LLVM FIXED POINT VERIFIED"; \
	else \
		echo ""; \
		echo "!!! LLVM FIXED POINT FAILED !!!"; \
		echo "gen1.ll and gen2.ll differ:"; \
		diff /tmp/llvm_verify/gen1.ll /tmp/llvm_verify/gen2.ll | head -30; \
		exit 1; \
	fi
	clang /tmp/llvm_verify/gen2.ll -o /tmp/llvm_verify/gen2
	@echo "Built: gen2"
	@echo ""
	@echo "┌────────────────────────────────────────────────────────────────┐"
	@echo "│ STAGE 3: Run test suite                                        │"
	@echo "└────────────────────────────────────────────────────────────────┘"
	@# Ensure out/lang points to verified gen2
	cp /tmp/llvm_verify/gen2 out/lang
	COMPILER=/tmp/llvm_verify/gen2 ./test/run_llvm_suite.sh
	@echo ""
	@echo "╔════════════════════════════════════════════════════════════════╗"
	@echo "║              LLVM-VERIFY COMPLETE                              ║"
	@echo "╠════════════════════════════════════════════════════════════════╣"
	@echo "║ ✓ LLVM fixed point verified (gen1.ll === gen2.ll)              ║"
	@echo "║ ✓ Test suite passed                                            ║"
	@echo "║                                                                ║"
	@echo "║ Verified compiler: out/lang                                    ║"
	@echo "╚════════════════════════════════════════════════════════════════╝"

# Release: run bootstrap + git tag
release:
	@if [ -z "$(TAG)" ]; then \
		echo "Usage: make release TAG=v0.2.0"; \
		exit 1; \
	fi
	@$(MAKE) bootstrap
	@cp bootstrap/current/compiler.s bootstrap/$(TAG).s
	@git add bootstrap/$(TAG).s
	@echo "Saved bootstrap/$(TAG).s"
	@echo "Run: git commit -m 'Release $(TAG)' && git tag $(TAG)"

# Run the test suite
test-suite:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	@./test/run_lang1_suite.sh

# Run ALL tests
test-all: test-suite test-run

# Compile and run sample test programs
test-run:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	@echo "=== hello.lang ===" && \
	$(LANG) test/suite/181_hello.lang -o out/hello.s && \
	as out/hello.s -o out/hello.o && \
	ld out/hello.o -o out/hello && \
	./out/hello && rm -f out/hello.o
	@echo "=== factorial.lang ===" && \
	$(LANG) test/suite/174_factorial.lang -o out/factorial.s && \
	as out/factorial.s -o out/factorial.o && \
	ld out/factorial.o -o out/factorial && \
	./out/factorial && rm -f out/factorial.o

# Compile a .lang file (usage: make compile FILE=test/hello.lang)
compile:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	$(LANG) $(FILE) -o out/$(notdir $(basename $(FILE))).s

# Full build chain for a .lang file (usage: make run FILE=test/hello.lang)
run:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	$(LANG) $(FILE) -o out/$(notdir $(basename $(FILE))).s
	as out/$(notdir $(basename $(FILE))).s -o out/$(notdir $(basename $(FILE))).o
	ld out/$(notdir $(basename $(FILE))).o -o out/$(notdir $(basename $(FILE)))
	./out/$(notdir $(basename $(FILE)))

# Build with stdlib (usage: make stdlib-run FILE=myprogram.lang)
stdlib-run:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	$(LANG) std/core.lang $(FILE) -o out/$(notdir $(basename $(FILE))).s
	as out/$(notdir $(basename $(FILE))).s -o out/$(notdir $(basename $(FILE))).o
	ld out/$(notdir $(basename $(FILE))).o -o out/$(notdir $(basename $(FILE)))
	./out/$(notdir $(basename $(FILE)))

# Run with development compiler (usage: make dev-run FILE=test/suite/188_effect_exception.lang)
dev-run:
	@if [ ! -L $(LANG_NEXT) ]; then echo "Run 'make build' first"; exit 1; fi
	$(LANG_NEXT) $(FILE) -o out/$(notdir $(basename $(FILE))).s
	as out/$(notdir $(basename $(FILE))).s -o out/$(notdir $(basename $(FILE))).o
	ld out/$(notdir $(basename $(FILE))).o -o out/$(notdir $(basename $(FILE)))
	./out/$(notdir $(basename $(FILE))); echo "Exit: $$?"

# Run with dev compiler + stdlib (usage: make dev-stdlib-run FILE=myprogram.lang)
dev-stdlib-run:
	@if [ ! -L $(LANG_NEXT) ]; then echo "Run 'make build' first"; exit 1; fi
	$(LANG_NEXT) std/core.lang $(FILE) -o out/$(notdir $(basename $(FILE))).s
	as out/$(notdir $(basename $(FILE))).s -o out/$(notdir $(basename $(FILE))).o
	ld out/$(notdir $(basename $(FILE))).o -o out/$(notdir $(basename $(FILE)))
	./out/$(notdir $(basename $(FILE))); echo "Exit: $$?"

# Clean: remove non-essential build artifacts
clean:
	rm -f out/*.s out/*.o out/verify.s
	rm -f out/hello out/factorial
	rm -f $(LANG_NEXT)

# Distclean: remove everything in out/
distclean:
	rm -rf out/*

# Show current state
status:
	@echo "Bootstrap: $(BOOTSTRAP) -> $$(readlink $(BOOTSTRAP))"
	@echo "Current commit: $(VERSION)"
	@if [ -L $(LANG) ]; then \
		echo "lang -> $$(readlink $(LANG))"; \
	else \
		echo "lang: not set (run 'make bootstrap')"; \
	fi
	@if [ -L $(LANG_NEXT) ]; then \
		echo "lang_next -> $$(readlink $(LANG_NEXT))"; \
	fi

# ============================================================
# SPLIT ARCHITECTURE: kernel + lang_reader
# ============================================================
#
# The compiler is split into:
#   kernel = AST -> x86 (codegen + sexpr_reader)
#   lang_reader = lang -> AST (lexer + parser + ast_emit)
#
# Composition: kernel -c lang_reader.ast = full lang compiler

# Kernel core (for composition - no main)
# Note: parser.lang needed for AST node accessors used by codegen and sexpr_reader
# Note: limits.lang is included by std/core.lang, don't list explicitly
KERNEL_CORE := std/core.lang src/lexer.lang src/parser.lang src/codegen.lang src/sexpr_reader.lang

# Kernel binary sources (core + main for standalone kernel)
KERNEL_SOURCES := $(KERNEL_CORE) src/kernel_main.lang

# Lang reader sources (includes lexer/parser/ast_emit + the reader definition)
# Note: limits.lang is included by std/core.lang, don't list explicitly
LANG_READER_SOURCES := std/core.lang src/lexer.lang src/parser.lang src/ast_emit.lang src/lang_reader.lang

# Compiler entry point (uses reader_transform from reader + generate from kernel)
COMPILER_SOURCES := src/compiler.lang

# Build kernel binary (AST -> x86)
build-kernel:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	@mkdir -p out
	$(LANG) $(KERNEL_SOURCES) -o out/kernel.s
	as out/kernel.s -o out/kernel.o
	ld out/kernel.o -o out/kernel
	rm -f out/kernel.o
	@echo "Built: out/kernel"

# Build lang_reader binary (standalone tool: lang -> AST to stdout)
build-lang-reader:
	@if [ ! -L $(LANG) ]; then $(MAKE) init; fi
	@mkdir -p out
	$(LANG) $(LANG_READER_SOURCES) src/reader_main.lang -o out/lang_reader.s
	as out/lang_reader.s -o out/lang_reader.o
	ld out/lang_reader.o -o out/lang_reader
	rm -f out/lang_reader.o
	@echo "Built: out/lang_reader"

# Emit kernel core AST (for composition - no main)
# Note: requires lang_next which has --emit-ast support
emit-kernel-ast: build
	@mkdir -p out/ast
	$(LANG_NEXT) $(KERNEL_CORE) --emit-ast -o out/ast/kernel.ast
	@echo "Wrote: out/ast/kernel.ast"

# Emit lang_reader AST (for composition - just the reader, deps come from kernel)
emit-lang-reader-ast: build
	@mkdir -p out/ast
	$(LANG_NEXT) src/lang_reader.lang --emit-ast -o out/ast/lang_reader.ast
	@echo "Wrote: out/ast/lang_reader.ast"

# Emit compiler AST (for composition)
emit-compiler-ast: build
	@mkdir -p out/ast
	$(LANG_NEXT) $(COMPILER_SOURCES) --emit-ast -o out/ast/compiler.ast
	@echo "Wrote: out/ast/compiler.ast"

# Seed the bootstrap directory with initial AST files
seed-bootstrap: emit-kernel-ast emit-lang-reader-ast emit-compiler-ast
	@mkdir -p bootstrap/$(GIT_COMMIT)/kernel bootstrap/$(GIT_COMMIT)/lang_reader bootstrap/$(GIT_COMMIT)/compiler
	cp out/ast/kernel.ast bootstrap/$(GIT_COMMIT)/kernel/source.ast
	cp out/ast/lang_reader.ast bootstrap/$(GIT_COMMIT)/lang_reader/source.ast
	cp out/ast/compiler.ast bootstrap/$(GIT_COMMIT)/compiler/source.ast
	@echo "Seeded: bootstrap/$(GIT_COMMIT)/"
	@echo "To activate: ln -sfn $(GIT_COMMIT) bootstrap/current"

# Test composition: kernel + reader via -r mode
# This is the new composition flow:
#   1. Build kernel AST with --emit-exe-ast (standalone, with ___main)
#   2. Build kernel binary with --embed-self (self-aware, carries its own AST)
#   3. Build reader AST with --emit-expanded-ast (for composition, NO ___main)
#   4. Compose: kernel -r lang reader.ast -> lang1
#   5. Test: lang1 can compile programs that require "std/core"
test-composition:
	@echo "╔════════════════════════════════════════════════════════════════╗"
	@echo "║              TEST COMPOSITION (LLVM)                           ║"
	@echo "╚════════════════════════════════════════════════════════════════╝"
	@mkdir -p /tmp/compose_test
	@echo ""
	@echo "┌─ Step 1: Build kernel AST (--emit-exe-ast, with ___main) ──────┐"
	LANGBE=llvm LANGOS=$(PLATFORM) ./out/lang --emit-exe-ast \
		std/core.lang src/version_info.lang src/lexer.lang src/parser.lang \
		src/codegen.lang src/codegen_llvm.lang src/ast_emit.lang \
		src/sexpr_reader.lang src/main.lang \
		-o /tmp/compose_test/kernel.ast
	@echo "  Kernel AST: $$(wc -l < /tmp/compose_test/kernel.ast) lines"
	@echo ""
	@echo "┌─ Step 2: Build kernel binary (--embed-self) ───────────────────┐"
	LANGBE=llvm LANGOS=$(PLATFORM) ./out/lang /tmp/compose_test/kernel.ast \
		--embed-self -o /tmp/compose_test/kernel.ll
	clang -O2 /tmp/compose_test/kernel.ll -o /tmp/compose_test/kernel
	@echo "  Built: /tmp/compose_test/kernel"
	/tmp/compose_test/kernel version || true
	@echo ""
	@echo "┌─ Step 3: Build reader AST (--emit-expanded-ast, NO ___main) ───┐"
	./out/lang --emit-expanded-ast src/lang_reader.lang \
		-o /tmp/compose_test/lang_reader.ast
	@echo "  Reader AST: $$(wc -l < /tmp/compose_test/lang_reader.ast) lines"
	@echo ""
	@echo "┌─ Step 4: Compose kernel + reader (-r lang) ────────────────────┐"
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/compose_test/kernel -r lang /tmp/compose_test/lang_reader.ast \
		-o /tmp/compose_test/lang1.ll
	clang -O2 /tmp/compose_test/lang1.ll -o /tmp/compose_test/lang1
	@echo "  Built: /tmp/compose_test/lang1"
	/tmp/compose_test/lang1 version || true
	@echo ""
	@echo "┌─ Step 5: Test composed compiler ───────────────────────────────┐"
	@echo 'require "std/core"' > /tmp/compose_test/hello.lang
	@echo 'func main() i64 { println("Hello from composed compiler!"); return 0; }' >> /tmp/compose_test/hello.lang
	LANGBE=llvm LANGOS=$(PLATFORM) /tmp/compose_test/lang1 /tmp/compose_test/hello.lang -o /tmp/compose_test/hello.ll
	clang /tmp/compose_test/hello.ll -o /tmp/compose_test/hello
	@/tmp/compose_test/hello
	@echo ""
	@echo "╔════════════════════════════════════════════════════════════════╗"
	@echo "║              COMPOSITION TEST PASSED                           ║"
	@echo "╚════════════════════════════════════════════════════════════════╝"

# Test bootstrap: verify true fixed point
# The fixed point is: A -c lang.lang === B -c lang.lang
# where A = {kernel -c lang.ast} -c lang.lang
# NOT: {kernel -c lang.ast} === A (AST-built vs source-built may differ)
test-bootstrap: test-composition
	@echo ""
	@echo "=== Building first generation: lang_composed -c lang_reader.lang ==="
	./out/lang_composed -c src/lang_reader.lang \
		--kernel-ast out/ast/kernel.ast \
		--compiler-ast out/ast/compiler.ast \
		-o out/lang_bootstrap.s
	as out/lang_bootstrap.s -o out/lang_bootstrap.o
	ld out/lang_bootstrap.o -o out/lang_bootstrap
	rm -f out/lang_bootstrap.o
	@echo "Built: out/lang_bootstrap"
	@echo ""
	@echo "=== Testing fixed point: lang_bootstrap -c lang_reader.lang ==="
	./out/lang_bootstrap -c src/lang_reader.lang \
		--kernel-ast out/ast/kernel.ast \
		--compiler-ast out/ast/compiler.ast \
		-o out/lang_bootstrap2.s
	@if diff -q out/lang_bootstrap.s out/lang_bootstrap2.s > /dev/null; then \
		echo "FIXED POINT ACHIEVED: lang_bootstrap can bootstrap itself!"; \
	else \
		echo "ERROR: Fixed point not reached!"; \
		exit 1; \
	fi

# OLD TARGETS REMOVED - use unified 'make verify' and 'make promote' instead
# The unified verify does both kernel and reader fixed point checks in one command
