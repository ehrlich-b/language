# Mac Bootstrap Handoff

Bootstrap the lang compiler on Mac ARM64. Delete after successful setup.

## Quick Start

```bash
# 1. Compile the libc-based bootstrap (macOS version)
clang bootstrap/llvm_libc_macos.ll -o lang

# 2. Full verification (builds gen1 -> gen2, checks fixed point, runs 167 tests)
make llvm-verify
```

That's it. `make llvm-verify` handles all the workarounds automatically.

## Making Changes on Mac

The `make llvm-verify` target allows you to develop on Mac:

```bash
# 1. Edit compiler source files
vim src/codegen.lang

# 2. Verify your changes work
make llvm-verify

# 3. If it passes, commit and push
git add -A && git commit -m "Your change"
git push
```

The verification process:
1. Builds gen1 compiler from bootstrap using LLVM
2. Builds gen2 compiler from gen1 using LLVM
3. Checks LLVM IR fixed point (gen1.ll === gen2.ll)
4. Runs full test suite (167 tests)

**Note**: This doesn't update the x86 bootstrap. Run `make bootstrap` on x86 Linux to promote verified changes.

## Manual Testing (if needed)

```bash
# Test LLVM backend manually
echo 'include "std/os/libc_macos.lang"' > std/os.lang
LANGBE=llvm LANGOS=macos ./lang std/core.lang test/suite/002_return_42.lang -o test.ll
clang test.ll -o test
./test; echo "Exit: $?"
# Expected: Exit: 42
```

## What's in the Bootstrap

`bootstrap/llvm_libc_macos.ll` - LLVM IR that uses libc for OS interface:
- Uses `read()`, `write()`, `open()`, `close()` from libc
- Uses `malloc()`, `free()` from libc
- Uses `getenv()` from our stdlib (reads from envp passed to main)
- Portable across Linux/Mac since libc abstracts OS differences

**Current status (2026-01-01)**: **167/167 tests passing** with `make llvm-verify`.

---

## BUGS TO FIX (revealed by cross-platform testing)

### Bug 1: std/os.lang hardcoded to Linux

**Impact**: All tests that `include "std/core.lang"` fail with mmap returning -1 (MAP_FAILED)

**Root cause**: `std/os.lang` is hardcoded:
```lang
include "std/os/linux_x86_64.lang"
```

Tests include std/core.lang → includes std/os.lang → uses Linux mmap flags (34) → fails on Mac.

**Workaround**: `echo 'include "std/os/libc_macos.lang"' > std/os.lang`

**Fix needed**: The test script should generate std/os.lang based on platform, OR std/os.lang should be auto-generated by build system, OR there should be runtime detection.

### Bug 2: Effect system uses hardcoded x86-64 inline asm ✓ FIXED

**Fix applied**: Effect system now emits architecture-appropriate inline asm based on `llvm_is_arm64` flag (set from LANGOS):

- x86-64: `movq %rbp`, `movq %rsp`, `leaq .Lhandler(%rip)`, `jmpq *`
- ARM64: `mov x29`, `mov sp`, `adrp/add .Lhandler@PAGE/@PAGEOFF`, `br`

See `src/codegen_llvm.lang`:
- Lines 3103-3144: Handle handler setup (save frame/stack ptr, get handler address)
- Lines 3452-3497: Perform continuation save (store fp/sp/return address)
- Lines 3558-3566: Perform jump to handler
- Lines 3686-3698: Resume jump restoration

### Bug 3: Reader macro compilation ignores LANGBE ✓ FIXED

**Fix applied**: Reader compilation now respects LANGBE environment variable:
- Added `exec_run_env()` to pass LANGBE/LANGOS to child compiler
- When LANGBE=llvm: outputs .ll files, uses clang to compile
- When LANGBE=x86: uses as/ld as before
- Added `llvm_emit_reader()` to emit readers as LLVM functions

See `src/codegen.lang:1048-1243` for reader compilation logic.

### Bug 4: Reader compilation hardcodes `./out/lang` path

**Impact**: Reader tests fail with "no such file or directory" for .ll files

**Root cause**: `src/codegen.lang:1237` hardcodes:
```lang
exec_run_env("./out/lang", src_path, "-o", out_path, nil, nil, child_envp);
```

When running the bootstrap as `./lang`, the reader compilation tries to use `./out/lang` which doesn't exist.

**Workaround**: `mkdir -p out && cp ./lang ./out/lang` (handled by `make llvm-verify`)

**Proper fix**: Don't exec a path on disk at all. Fork, and the child IS the compiler:

```
Current (bad):
  1. Write wrapper source to disk
  2. exec("./out/lang", wrapper, "-o", output)  <- finds binary on disk
  3. as/ld or clang

Proper (fork-self):
  1. fork()
  2. child: already has parser/codegen loaded!
     - read wrapper source from pipe (or use AST directly)
     - call codegen functions directly to emit .s/.ll
     - write to temp file, exit
  3. parent: wait, then as/ld or clang the output
```

The child doesn't need to "find itself" because it already IS the compiler with all code loaded. No disk path, no exec for compilation step.

**Location**: `src/codegen.lang:compile_reader_to_executable()` (lines ~1048-1247)

### Bug 5: Effect tests missing `//clang` marker

**Impact**: 4 effect tests fail when run with lli (inline asm not supported)

**Root cause**: Effect system emits inline assembly, which lli can't execute. The test script uses clang only for tests marked `//clang` in lines 1-3.

**Fix applied on Mac**: Added `//clang` to tests 188, 191, 193, 194.

These tests should be committed with the `//clang` marker.

### Summary: Current test status

| Category | Count | Status |
|----------|-------|--------|
| All tests | 167 | ✓ All passing with workarounds |
| Effects | ~10 | ✓ Fixed (Bug 2) + need //clang marker |
| Readers | ~15 | ✓ Fixed (Bug 3) + need ./out/lang workaround |

**167/167 tests pass** with:
1. OS layer workaround: `echo 'include "std/os/libc_macos.lang"' > std/os.lang`
2. Compiler path workaround: `cp ./lang ./out/lang`

## Troubleshooting

**clang errors about malloc/free redefinition**: The bootstrap should only have `declare` (not `define`) for libc functions. If you see conflicts, regenerate on the dev machine:
```bash
LANGBE=llvm LANGLIBC=libc ./out/lang std/core.lang src/*.lang -o bootstrap/llvm_libc_macos.ll
```

**getenv returns nil**: The current bootstrap stores envp from main's hidden third parameter. If tests that use `getenv()` fail, the issue is likely in how clang calls main().

**Binary crashes immediately**: Check that you're using `LANGBE=llvm`. The default x86 output won't run on ARM Mac.

---

## RESOLVED: 2026-01-01 Attempt #5 - Two ARM64 ABI issues

**Fixed on x86 side** - Both issues resolved in `src/codegen_llvm.lang`.

### Issue 1: open() variadic calling convention (ARM64 ABI) ✓ FIXED

**Fix applied**: Special-cased `open()` in LLVM backend:
- Declaration: `declare i64 @open(i64, i64, ...)`
- Call: `call i64 (i64, i64, ...) @open(...)`
- See `src/codegen_llvm.lang:1435-1470` (call) and `4774-4797` (declaration)

### Issue 2: Target triple hardcoded for Linux ✓ FIXED

**Fix applied**: Check `LANGOS` env var in `src/codegen_llvm.lang:5425-5438`:
- `LANGOS=macos` → `target triple = "arm64-apple-macosx"`
- Otherwise → `target triple = "x86_64-unknown-linux-gnu"`

Makefile now builds macOS bootstrap with `LANGOS=macos`.

---

## RESOLVED: 2025-01-01 Attempt #4 - read_file_contents uses raw syscalls

**Fixed on x86 side** - `src/codegen.lang:read_file_contents` now uses `os_open`, `os_read`, `os_close`.

**Symptom**: SIGSYS crash in read_file_contents
```
signal SIGSYS
frame #0: libsystem_kernel.dylib`__syscall + 24
frame #1: lang`read_file_contents + 332
```

**Root cause**: `src/codegen.lang:read_file_contents` still uses raw syscalls:
```lang
// codegen.lang:1336-1343
var fd i64 = syscall(2, path_z, 0, 0);   // Linux open syscall
var n i64 = syscall(0, fd, buf, buf_cap); // Linux read syscall
syscall(3, fd);                           // Linux close syscall
```

The OS layer (`std/os/libc_macos.lang`) already has:
- `os_open()`, `os_read()`, `os_close()` that use libc
- `os_fork()`, `os_execve()`, etc. for reader macros

**But the bootstrap was generated BEFORE updating read_file_contents!**

**Fix needed on Windows**:
1. Update `read_file_contents` in `src/codegen.lang`:
```lang
func read_file_contents(path *u8, path_len i64, buf *u8, buf_cap i64) i64 {
    // Null-terminate path
    var path_z *u8 = alloc(path_len + 1);
    var j i64 = 0;
    while j < path_len {
        *(path_z + j) = *(path + j);
        j = j + 1;
    }
    *(path_z + path_len) = 0;

    // Open file using OS layer (O_RDONLY = 0)
    var fd i64 = os_open(path_z, 0, 0);
    if fd < 0 {
        return -1;
    }

    // Read contents using OS layer
    var n i64 = os_read(fd, buf, buf_cap);
    os_close(fd);

    if n >= 0 {
        *(buf + n) = 0;  // null-terminate
    }
    return n;
}
```

2. Regenerate bootstrap:
```bash
LANGBE=llvm LANGLIBC=libc ./out/lang std/core.lang src/*.lang -o bootstrap/llvm_libc_macos.ll
```

---

## RESOLVED: 2024-12-31 Attempt #3 - mmap flags

**Symptom**: mmap returns MAP_FAILED (-1), crash in append_str
```
frame #0: lang`append_str + 68  (writing to 0xffffffffffffffff)
```

**Root cause**: `std/core.lang` hardcodes Linux mmap flags:
```lang
// std/core.lang:18
heap_pos = os_mmap(nil, SIZE_HEAP, 3, 34, 0-1, 0);
//                                    ^^-- Linux MAP_PRIVATE|MAP_ANONYMOUS = 34
```

macOS uses different flag values:
| Flag | Linux | macOS |
|------|-------|-------|
| MAP_PRIVATE | 0x02 | 0x02 |
| MAP_ANONYMOUS | 0x20 | 0x1000 (MAP_ANON) |
| Combined | 34 | 4098 |

**Fix options**:

1. **Define flags in OS layer** - each `std/os/*.lang` exports constants:
   ```lang
   // std/os/libc.lang (or per-platform)
   var MMAP_FLAGS_ANON i64 = 4098;  // macOS value
   ```
   Then std/core.lang uses `MMAP_FLAGS_ANON` instead of hardcoded 34.

2. **Use libc malloc entirely** - when using libc layer, don't implement our own bump allocator. Just use libc's malloc/free everywhere.

---

## Deep Dive: All Platform-Specific Code (2024-12-31)

### Issue 1: mmap flags in std/core.lang (BLOCKING)
```lang
// std/core.lang:18
heap_pos = os_mmap(nil, SIZE_HEAP, 3, 34, 0-1, 0);
//                                    ^^-- Linux only
```
- Linux: MAP_PRIVATE|MAP_ANONYMOUS = 34
- macOS: MAP_PRIVATE|MAP_ANON = 4098

### Issue 2: File open flags (will break file writing)
```lang
// Multiple places use 577 for O_WRONLY|O_CREAT|O_TRUNC
file_open(output_file, 577);
```
- Linux: O_CREAT=64, O_TRUNC=512 → 577
- macOS: O_CREAT=512, O_TRUNC=1024 → 1537

**Affected files:**
- src/main.lang:382, 399
- src/codegen_llvm.lang:29
- src/codegen.lang:1164, 5831
- src/reader_main.lang:126

### Issue 3: Direct syscalls in codegen.lang (reader execution)
The reader macro system uses raw Linux syscalls:
```lang
// codegen.lang - reader subprocess execution
syscall(57);           // fork
syscall(59, ...);      // execve
syscall(61, ...);      // wait4
syscall(22, ...);      // pipe
syscall(33, ...);      // dup2
syscall(2, path, 577, 420);  // open
syscall(0, fd, ...);   // read
syscall(1, fd, ...);   // write
syscall(3, fd);        // close
```

These are **not abstracted** through the OS layer. The libc layer would need:
```lang
extern func fork() i64;
extern func execve(path *u8, argv **u8, envp **u8) i64;
extern func waitpid(pid i64, status *i64, options i64) i64;
extern func pipe(pipefd *i64) i64;
extern func dup2(oldfd i64, newfd i64) i64;
```

### Issue 4: codegen.lang:5831 bypasses OS layer
```lang
cg_out_fd = syscall(2, out_path, 577, 420);
```
Direct syscall instead of using `file_open()`.

### Summary Table

| Issue | Location | Linux Value | macOS Value | Severity |
|-------|----------|-------------|-------------|----------|
| mmap flags | std/core.lang:18 | 34 | 4098 | BLOCKING |
| open flags | multiple | 577 | 1537 | BLOCKING |
| fork syscall | codegen.lang | 57 | N/A (use libc) | Reader macros break |
| execve syscall | codegen.lang | 59 | N/A | Reader macros break |
| wait4 syscall | codegen.lang | 61 | N/A | Reader macros break |
| pipe syscall | codegen.lang | 22 | N/A | Reader macros break |
| dup2 syscall | codegen.lang | 33 | N/A | Reader macros break |

### Recommended Fix Strategy

1. **Define constants in OS layer**:
   ```lang
   // std/os/libc.lang
   var OPEN_FLAGS_WRITE_CREATE_TRUNC i64 = 1537;  // macOS
   var MMAP_FLAGS_ANON i64 = 4098;                // macOS
   ```

2. **Add process functions to OS layer**:
   ```lang
   extern func fork() i64;
   extern func execve(path *u8, argv **u8, envp **u8) i64;
   extern func waitpid(pid i64, status *i64, options i64) i64;
   extern func pipe(pipefd *i64) i64;
   extern func dup2(oldfd i64, newfd i64) i64;

   func os_fork() i64 { return fork(); }
   func os_exec(...) i64 { return execve(...); }
   // etc.
   ```

3. **Update codegen.lang** to use OS layer functions instead of direct syscalls.

4. **Alternative**: For libc bootstrap, just use libc malloc everywhere and skip our custom allocator.
