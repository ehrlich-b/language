// ============================================================
// Lisp Reader Demo - The Grand Finale
// ============================================================
//
// This demonstrates the full power of reader macros:
// - #lisp{} is a reader macro
// - #lisp{} uses #parser{} internally (a reader using a reader!)
// - All of this compiles to native x86 with zero runtime overhead
//
// The vision: "compiler compiler" - readers building readers.

include "std/core.lang"
include "example/lisp/lisp.lang"

func main() i64 {
    print("=== Lisp Reader Macro Demo ===\n\n");

    // Simple arithmetic
    print("(+ 10 32)           = ");
    print_int(#lisp{ (+ 10 32) });
    print("\n");

    // Nested left
    print("(+ (* 2 3) 1)       = ");
    print_int(#lisp{ (+ (* 2 3) 1) });
    print("\n");

    // Nested right
    print("(+ 1 (* 2 3))       = ");
    print_int(#lisp{ (+ 1 (* 2 3)) });
    print("\n");

    // Both sides nested
    print("(- (* 7 8) (+ 5 9)) = ");
    print_int(#lisp{ (- (* 7 8) (+ 5 9)) });
    print("\n");

    // Deep nesting
    print("(+ (+ (+ 1 2) 3) 4) = ");
    print_int(#lisp{ (+ (+ (+ 1 2) 3) 4) });
    print("\n");

    // N-ary operators
    print("(+ 1 2 3 4 5)       = ");
    print_int(#lisp{ (+ 1 2 3 4 5) });
    print("\n");

    // Complex expression
    print("(* (+ 3 3) (+ 3 4)) = ");
    var answer i64 = #lisp{ (* (+ 3 3) (+ 3 4)) };
    print_int(answer);
    print("\n");

    print("\n=== All computed at COMPILE TIME! ===\n");

    // Verify results
    if #lisp{ (+ 10 32) } != 42 { print("FAIL\n"); return 1; }
    if #lisp{ (+ (* 2 3) 1) } != 7 { print("FAIL\n"); return 1; }
    if #lisp{ (+ 1 (* 2 3)) } != 7 { print("FAIL\n"); return 1; }
    if #lisp{ (- (* 7 8) (+ 5 9)) } != 42 { print("FAIL\n"); return 1; }
    if #lisp{ (+ (+ (+ 1 2) 3) 4) } != 10 { print("FAIL\n"); return 1; }
    if #lisp{ (+ 1 2 3 4 5) } != 15 { print("FAIL\n"); return 1; }
    if answer != 42 { print("FAIL\n"); return 1; }

    print("\nPASS: All tests passed!\n");
    return 0;
}
