// std/os/libc_macos.lang - OS abstraction via system libc (macOS)
//
// This file provides the OS abstraction layer using extern declarations to
// the system's libc. Use this when compiling with LLVM backend to get portable
// binaries that link against the platform's libc.
//
// Unlike linux_x86_64.lang which uses raw syscalls, this approach:
// - Works on any OS where clang can target (macOS, Linux, Windows, etc.)
// - Links against system libc (-lc)
// - Is more portable but requires libc at runtime
//
// ============================================================
// OS Layer Interface
// ============================================================
// Every OS layer (linux_x86_64, macos_arm64, libc) implements this interface.
//
// Internal functions (os_* prefix, used by std library):
//   os_read(fd, buf, count) i64
//   os_write(fd, buf, count) i64
//   os_open(path, flags, mode) i64
//   os_close(fd) i64
//   os_mmap(addr, len, prot, flags, fd, offset) *u8
//   os_exit(code) void
//   os_stat(path, statbuf) i64
//   os_getpid() i64
//   os_getppid() i64
//   os_getcwd(buf, size) i64
//   os_mkdir(path, mode) i64
//   os_unlink(path) i64
//   os_rmdir(path) i64
//
// User-facing functions (from libc extern declarations):
//   malloc(size) *u8
//   free(ptr) void
//   exit(code) void
//   getpid() i64
//   getppid() i64
//   getcwd(buf, size) *u8  -- NOTE: libc returns pointer, not i64
//   mkdir(path, mode) i64
//   unlink(path) i64
//   rmdir(path) i64
//   init_environ(envp) void  -- no-op, libc handles environ
//   getenv(name) *u8

// ============================================================
// Platform constants
// ============================================================
// These use macOS values since libc.lang is primarily for macOS.
// On Linux, use linux_x86_64.lang instead (default for LANGOS=linux).

// File open flags for macOS
// O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2
// O_CREAT = 512, O_TRUNC = 1024, O_APPEND = 8
pub var O_RDONLY i64 = 0;
pub var O_WRONLY i64 = 1;
pub var O_CREAT i64 = 512;
pub var O_TRUNC i64 = 1024;
pub var O_APPEND i64 = 8;
pub var O_WRONLY_CREAT_TRUNC i64 = 1537;  // O_WRONLY | O_CREAT | O_TRUNC

// ============================================================
// External libc declarations
// ============================================================

// File I/O
extern func read(fd i64, buf *u8, count i64) i64;
extern func write(fd i64, buf *u8, count i64) i64;
extern func open(path *u8, flags i64, mode i64) i64;
extern func close(fd i64) i64;

// Memory
extern func mmap(addr *u8, len i64, prot i64, flags i64, fd i64, offset i64) *u8;
extern func munmap(addr *u8, len i64) i64;
pub extern func malloc(size i64) *u8;
pub extern func calloc(n i64, size i64) *u8;
pub extern func free(ptr *u8) void;

// Process - basic
pub extern func exit(code i64) void;
pub extern func getpid() i64;
pub extern func getppid() i64;
pub extern func getenv(name *u8) *u8;

// Process - for subprocess execution (reader macros)
extern func fork() i64;
extern func execve(path *u8, argv **u8, envp **u8) i64;
extern func waitpid(pid i64, status *i64, options i64) i64;
extern func pipe(fds *i64) i64;
extern func dup2(oldfd i64, newfd i64) i64;
extern func _exit(status i64) void;

// File system
extern func stat(path *u8, statbuf *u8) i64;
extern func mkdir(path *u8, mode i64) i64;
extern func unlink(path *u8) i64;
extern func rmdir(path *u8) i64;
extern func getcwd(buf *u8, size i64) *u8;

// ============================================================
// OS abstraction layer (same interface as linux_x86_64.lang)
// ============================================================

func os_read(fd i64, buf *u8, count i64) i64 {
    return read(fd, buf, count);
}

func os_write(fd i64, buf *u8, count i64) i64 {
    return write(fd, buf, count);
}

func os_open(path *u8, flags i64, mode i64) i64 {
    return open(path, flags, mode);
}

func os_close(fd i64) i64 {
    return close(fd);
}

func os_mmap(addr *u8, len i64, prot i64, flags i64, fd i64, offset i64) *u8 {
    return mmap(addr, len, prot, flags, fd, offset);
}

func os_exit(code i64) void {
    exit(code);
}

// Extended syscalls

func os_stat(path *u8, statbuf *u8) i64 {
    return stat(path, statbuf);
}

func os_getpid() i64 {
    return getpid();
}

func os_getppid() i64 {
    return getppid();
}

func os_getcwd(buf *u8, size i64) i64 {
    var result *u8 = getcwd(buf, size);
    if result == nil {
        return 0 - 1;
    }
    return 0;
}

func os_mkdir(path *u8, mode i64) i64 {
    return mkdir(path, mode);
}

func os_unlink(path *u8) i64 {
    return unlink(path);
}

func os_rmdir(path *u8) i64 {
    return rmdir(path);
}

// ============================================================
// Process control - for subprocess execution (reader macros)
// ============================================================

func os_fork() i64 {
    return fork();
}

func os_execve(path *u8, argv **u8, envp **u8) i64 {
    return execve(path, argv, envp);
}

func os_waitpid(pid i64, status *i64, options i64) i64 {
    return waitpid(pid, status, options);
}

func os_pipe(fds *i64) i64 {
    return pipe(fds);
}

func os_dup2(oldfd i64, newfd i64) i64 {
    return dup2(oldfd, newfd);
}

func os__exit(status i64) void {
    _exit(status);
}

// ============================================================
// Memory allocation - just use libc malloc
// ============================================================
// For libc layer, we don't need our own bump allocator.
// This avoids platform-specific mmap flag issues.

pub func alloc(size i64) *u8 {
    // Use calloc to get zeroed memory (malloc doesn't zero, but mmap does)
    return calloc(1, size);
}

// ============================================================
// Environment - libc handles this, init_environ is no-op
// ============================================================

// No-op: libc's environ is already initialized
pub func init_environ(envp **u8) void {
    // libc handles environ internally
}
