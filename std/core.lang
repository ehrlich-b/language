// std/core.lang - Standard library for language
// Provides basic I/O, memory allocation, and string operations

include "src/limits.lang"
include "std/os.lang"
include "std/tools.lang"

// ============================================================
// Memory
// ============================================================
// alloc() is now provided by the OS layer (std/os/*.lang)
// - linux_x86_64: mmap-based bump allocator with Linux flags
// - macos_arm64: mmap-based bump allocator with macOS flags
// - libc: delegates to libc malloc()

// ============================================================
// Dynamic Array (Vec)
// ============================================================
// Vec layout: [capacity:8][length:8][data:8] = 24 bytes
// Data array stores i64 values (8 bytes each)

pub func vec_new(cap i64) *u8 {
    var v *u8 = malloc(24);

    // Initialize capacity
    if cap < 4 {
        cap = 4;
    }
    var cap_ptr *i64 = v;
    *cap_ptr = cap;

    // Initialize length to 0
    var len_ptr *i64 = v + 8;
    *len_ptr = 0;

    // Allocate initial data array
    var data_ptr **u8 = v + 16;
    *data_ptr = malloc(cap * 8);

    return v;
}

pub func vec_len(v *u8) i64 {
    var len_ptr *i64 = v + 8;
    return *len_ptr;
}

pub func vec_get(v *u8, index i64) i64 {
    var data_ptr **u8 = v + 16;
    var data *u8 = *data_ptr;
    var elem_ptr *i64 = data + index * 8;
    return *elem_ptr;
}

pub func vec_set(v *u8, index i64, value i64) {
    var data_ptr **u8 = v + 16;
    var data *u8 = *data_ptr;
    var elem_ptr *i64 = data + index * 8;
    *elem_ptr = value;
}

pub func vec_push(v *u8, value i64) {
    var cap_ptr *i64 = v;
    var len_ptr *i64 = v + 8;
    var data_ptr **u8 = v + 16;

    var cap i64 = *cap_ptr;
    var len i64 = *len_ptr;
    var data *u8 = *data_ptr;

    // Check if we need to grow
    if len >= cap {
        // Double capacity
        var new_cap i64 = cap * 2;
        var new_data *u8 = malloc(new_cap * 8);

        // Copy old data
        var i i64 = 0;
        while i < len {
            var old_ptr *i64 = data + i * 8;
            var new_ptr *i64 = new_data + i * 8;
            *new_ptr = *old_ptr;
            i = i + 1;
        }

        // Free old data and update vec
        free(data);
        *cap_ptr = new_cap;
        *data_ptr = new_data;
        data = new_data;
    }

    // Add element
    var elem_ptr *i64 = data + len * 8;
    *elem_ptr = value;
    *len_ptr = len + 1;
}

pub func vec_free(v *u8) {
    var data_ptr **u8 = v + 16;
    var data *u8 = *data_ptr;
    free(data);
    free(v);
}

pub func vec_pop(v *u8) i64 {
    var len_ptr *i64 = v + 8;
    var data_ptr **u8 = v + 16;
    var len i64 = *len_ptr;
    if len == 0 {
        return 0;  // Empty vector
    }
    len = len - 1;
    *len_ptr = len;
    var data *u8 = *data_ptr;
    var elem_ptr *i64 = data + len * 8;
    return *elem_ptr;
}

// ============================================================
// Hash Map (string keys -> i64 values)
// ============================================================
// Map layout: [capacity:8][count:8][keys:8][values:8] = 32 bytes
// keys: array of *u8 (nil = empty slot)
// values: array of i64
// Uses open addressing with linear probing

pub func hash_str(s *u8) i64 {
    // djb2 hash
    var h i64 = 5381;
    while *s != 0 {
        h = h * 33 + *s;
        s = s + 1;
    }
    // Make positive
    if h < 0 {
        h = 0 - h;
    }
    return h;
}

pub func map_new() *u8 {
    var m *u8 = malloc(32);

    // Initial capacity 16
    var cap_ptr *i64 = m;
    *cap_ptr = 16;

    // Count 0
    var count_ptr *i64 = m + 8;
    *count_ptr = 0;

    // Allocate keys array (16 * 8 = 128 bytes)
    var keys_ptr **u8 = m + 16;
    var keys *u8 = malloc(128);
    *keys_ptr = keys;

    // Initialize keys to nil
    var i i64 = 0;
    while i < 16 {
        var slot **u8 = keys + i * 8;
        *slot = nil;
        i = i + 1;
    }

    // Allocate values array (16 * 8 = 128 bytes)
    var vals_ptr **u8 = m + 24;
    *vals_ptr = malloc(128);

    return m;
}

func map_find_slot(m *u8, key *u8) i64 {
    // Returns index where key is or should be inserted
    var cap_ptr *i64 = m;
    var cap i64 = *cap_ptr;
    var keys_ptr **u8 = m + 16;
    var keys *u8 = *keys_ptr;

    var h i64 = hash_str(key) % cap;
    var i i64 = 0;

    while i < cap {
        var idx i64 = (h + i) % cap;
        var slot **u8 = keys + idx * 8;
        var slot_key *u8 = *slot;

        if slot_key == nil {
            return idx;
        }
        if streq(slot_key, key) {
            return idx;
        }
        i = i + 1;
    }

    // Should never reach here if load factor < 1
    return 0 - 1;
}

func map_grow(m *u8) {
    var cap_ptr *i64 = m;
    var count_ptr *i64 = m + 8;
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;

    var old_cap i64 = *cap_ptr;
    var old_keys *u8 = *keys_ptr;
    var old_vals *u8 = *vals_ptr;

    // Double capacity
    var new_cap i64 = old_cap * 2;
    *cap_ptr = new_cap;
    *count_ptr = 0;

    // Allocate new arrays
    var new_keys *u8 = malloc(new_cap * 8);
    var new_vals *u8 = malloc(new_cap * 8);

    // Initialize new keys to nil
    var i i64 = 0;
    while i < new_cap {
        var slot **u8 = new_keys + i * 8;
        *slot = nil;
        i = i + 1;
    }

    *keys_ptr = new_keys;
    *vals_ptr = new_vals;

    // Rehash old entries
    i = 0;
    while i < old_cap {
        var old_slot **u8 = old_keys + i * 8;
        var old_key *u8 = *old_slot;

        if old_key != nil {
            var old_val_ptr *i64 = old_vals + i * 8;
            var old_val i64 = *old_val_ptr;

            // Insert into new table
            var idx i64 = map_find_slot(m, old_key);
            var new_slot **u8 = new_keys + idx * 8;
            *new_slot = old_key;
            var new_val_ptr *i64 = new_vals + idx * 8;
            *new_val_ptr = old_val;

            var count i64 = *count_ptr;
            *count_ptr = count + 1;
        }
        i = i + 1;
    }

    free(old_keys);
    free(old_vals);
}

pub func map_set(m *u8, key *u8, value i64) {
    var cap_ptr *i64 = m;
    var count_ptr *i64 = m + 8;
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;

    var cap i64 = *cap_ptr;
    var count i64 = *count_ptr;

    // Check load factor (> 0.75 = count * 4 > cap * 3)
    if count * 4 > cap * 3 {
        map_grow(m);
    }

    var keys *u8 = *keys_ptr;
    var vals *u8 = *vals_ptr;

    var idx i64 = map_find_slot(m, key);
    var slot **u8 = keys + idx * 8;
    var slot_key *u8 = *slot;

    // Set key if new slot
    if slot_key == nil {
        *slot = key;
        count = *count_ptr;
        *count_ptr = count + 1;
    }

    // Set value
    var val_ptr *i64 = vals + idx * 8;
    *val_ptr = value;
}

pub func map_get(m *u8, key *u8) i64 {
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;
    var keys *u8 = *keys_ptr;
    var vals *u8 = *vals_ptr;

    var idx i64 = map_find_slot(m, key);
    var slot **u8 = keys + idx * 8;
    var slot_key *u8 = *slot;

    if slot_key == nil {
        return 0;  // Not found, return 0
    }

    var val_ptr *i64 = vals + idx * 8;
    return *val_ptr;
}

pub func map_has(m *u8, key *u8) i64 {
    var keys_ptr **u8 = m + 16;
    var keys *u8 = *keys_ptr;

    var idx i64 = map_find_slot(m, key);
    var slot **u8 = keys + idx * 8;
    var slot_key *u8 = *slot;

    if slot_key == nil {
        return 0;
    }
    return 1;
}

pub func map_free(m *u8) {
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;
    free(*keys_ptr);
    free(*vals_ptr);
    free(m);
}

// Make a null-terminated copy of a string with explicit length
pub func str_dup_n(s *u8, len i64) *u8 {
    var result *u8 = malloc(len + 1);
    var i i64 = 0;
    while i < len {
        *(result + i) = *(s + i);
        i = i + 1;
    }
    *(result + len) = 0;
    return result;
}

// Map set/get with length-prefixed keys (creates null-terminated copy)
pub func map_set_n(m *u8, key *u8, key_len i64, value i64) void {
    var key_copy *u8 = str_dup_n(key, key_len);
    map_set(m, key_copy, value);
}

pub func map_get_n(m *u8, key *u8, key_len i64) i64 {
    var key_copy *u8 = str_dup_n(key, key_len);
    var result i64 = map_get(m, key_copy);
    free(key_copy);
    return result;
}

// ============================================================
// File I/O
// ============================================================

pub func file_open(path *u8, flags i64) i64 {
    // 420 = 0644 permissions
    return os_open(path, flags, 420);
}

pub func file_read(fd i64, buf *u8, n i64) i64 {
    return os_read(fd, buf, n);
}

pub func file_write(fd i64, buf *u8, n i64) i64 {
    return os_write(fd, buf, n);
}

pub func file_close(fd i64) {
    os_close(fd);
}

// ============================================================
// Strings
// ============================================================

pub func strlen(s *u8) i64 {
    var n i64 = 0;
    while *(s + n) != 0 {
        n = n + 1;
    }
    return n;
}

pub func streq(a *u8, b *u8) i64 {
    while *a != 0 && *b != 0 {
        if *a != *b {
            return 0;
        }
        a = a + 1;
        b = b + 1;
    }
    if *a == *b {
        return 1;
    }
    return 0;
}

// Compare two strings with explicit lengths
pub func str_eq_n(a *u8, a_len i64, b *u8, b_len i64) bool {
    if a_len != b_len {
        return false;
    }
    var i i64 = 0;
    while i < a_len {
        if *(a + i) != *(b + i) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

pub func str_concat(a *u8, b *u8) *u8 {
    var len_a i64 = strlen(a);
    var len_b i64 = strlen(b);
    var result *u8 = malloc(len_a + len_b + 1);

    // Copy a
    var i i64 = 0;
    while i < len_a {
        *(result + i) = *(a + i);
        i = i + 1;
    }

    // Copy b
    var j i64 = 0;
    while j < len_b {
        *(result + len_a + j) = *(b + j);
        j = j + 1;
    }

    // Null terminate
    *(result + len_a + len_b) = 0;

    return result;
}

pub func str_dup(s *u8) *u8 {
    var len i64 = strlen(s);
    var result *u8 = malloc(len + 1);
    var i i64 = 0;
    while i <= len {
        *(result + i) = *(s + i);
        i = i + 1;
    }
    return result;
}

pub func str_starts_with(s *u8, prefix *u8) i64 {
    while *prefix != 0 {
        if *s != *prefix { return 0; }
        s = s + 1;
        prefix = prefix + 1;
    }
    return 1;
}

// ============================================================
// I/O helpers
// ============================================================

pub func print(s *u8) {
    file_write(1, s, strlen(s));
}

pub func println(s *u8) {
    print(s);
    file_write(1, "\n", 1);
}

pub func eprint(s *u8) {
    file_write(2, s, strlen(s));
}

pub func eprintln(s *u8) {
    eprint(s);
    file_write(2, "\n", 1);
}

pub func eprint_buf(buf *u8, len i64) {
    file_write(2, buf, len);
}

pub func eprint_i64(n i64) {
    if n < 0 {
        file_write(2, "-", 1);
        n = 0 - n;
    }

    if n == 0 {
        file_write(2, "0", 1);
        return;
    }

    // Find the highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Print each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        var c u8 = 48 + digit;  // '0' = 48
        file_write(2, &c, 1);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

// ============================================================
// Process - exit() provided by OS layer
// ============================================================

// ============================================================
// Numeric helpers (useful for debugging)
// ============================================================

pub func print_digit(d i64) {
    var c u8 = 48 + d;  // '0' = 48
    file_write(1, &c, 1);
}

pub func print_int(n i64) {
    if n < 0 {
        file_write(1, "-", 1);
        n = 0 - n;
    }

    if n == 0 {
        file_write(1, "0", 1);
        return;
    }

    // Find the highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Print each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        print_digit(digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

// Convert integer to string, write to buffer, return length
pub func itoa(n i64, buf *u8) i64 {
    var pos i64 = 0;

    if n < 0 {
        *(buf + pos) = 45;  // '-'
        pos = pos + 1;
        n = 0 - n;
    }

    if n == 0 {
        *(buf + pos) = 48;  // '0'
        return pos + 1;
    }

    // Find the highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Write each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        *(buf + pos) = 48 + digit;
        pos = pos + 1;
        n = n % divisor;
        divisor = divisor / 10;
    }

    return pos;
}

// ============================================================
// OS utilities (higher-level, use alloc)
// ============================================================
// Note: getpid, getppid, getcwd, mkdir, unlink, rmdir are provided
// by the OS layer (linux_x86_64.lang, macos_arm64.lang, or libc.lang)

// Get file modification time (seconds since epoch)
// Returns 0 if file doesn't exist or error
pub func file_mtime(path *u8) i64 {
    // struct stat is 144 bytes on x86-64 Linux
    // st_mtime is at offset 88
    var statbuf *u8 = alloc(144);
    var result i64 = os_stat(path, statbuf);
    if result < 0 {
        return 0;  // file doesn't exist or error
    }
    var mtime_ptr *i64 = statbuf + 88;
    return *mtime_ptr;
}

// ============================================================
// Environment variables
// ============================================================
// Note: environ, init_environ, getenv are provided by the OS layer
// (linux_x86_64.lang, macos_arm64.lang, or libc.lang)
