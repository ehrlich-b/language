// std/core.lang - Standard library for language
// Provides basic I/O, memory allocation, and string operations

// ============================================================
// Memory - Bump allocator (simple, never frees)
// ============================================================

var heap_pos *u8 = nil;
var heap_end *u8 = nil;

func alloc(size i64) *u8 {
    if heap_pos == nil {
        // mmap(NULL, 64MB, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
        // syscall 9 = mmap, 3 = PROT_READ|PROT_WRITE, 34 = MAP_PRIVATE|MAP_ANONYMOUS
        heap_pos = syscall(9, 0, 67108864, 3, 34, 0-1, 0);
        heap_end = heap_pos + 67108864;
    }
    var ptr *u8 = heap_pos;
    heap_pos = heap_pos + size;
    return ptr;
}

// ============================================================
// Memory - malloc/free with free list
// ============================================================
// Block layout: [size:8][data...]
// Free blocks store next pointer in data area: [size:8][next:8]
// Minimum allocation is 8 bytes (to hold next pointer when freed)

var free_list *u8 = nil;

func malloc(size i64) *u8 {
    // Minimum size is 8 (to store next pointer when freed)
    if size < 8 {
        size = 8;
    }

    // Align size to 8 bytes
    var rem i64 = size % 8;
    if rem != 0 {
        size = size + 8 - rem;
    }

    // Search free list for first fit
    var prev *u8 = nil;
    var curr *u8 = free_list;

    while curr != nil {
        // Get block size (stored at curr)
        var block_size_ptr *i64 = curr;
        var block_size i64 = *block_size_ptr;

        if block_size >= size {
            // Found a suitable block - remove from free list
            var next_ptr **u8 = curr + 8;
            var next *u8 = *next_ptr;

            if prev == nil {
                free_list = next;
            } else {
                var prev_next_ptr **u8 = prev + 8;
                *prev_next_ptr = next;
            }

            // Return pointer to data area (skip size header)
            return curr + 8;
        }

        prev = curr;
        var curr_next_ptr **u8 = curr + 8;
        curr = *curr_next_ptr;
    }

    // No suitable free block, bump allocate with header
    var total i64 = size + 8;
    var block *u8 = alloc(total);

    // Store size in header
    var size_ptr *i64 = block;
    *size_ptr = size;

    // Return pointer to data area
    return block + 8;
}

func free(ptr *u8) {
    if ptr == nil {
        return;
    }

    // Get block header (8 bytes before data)
    var block *u8 = ptr - 8;

    // Add to front of free list
    var next_ptr **u8 = block + 8;
    *next_ptr = free_list;
    free_list = block;
}

// ============================================================
// Dynamic Array (Vec)
// ============================================================
// Vec layout: [capacity:8][length:8][data:8] = 24 bytes
// Data array stores i64 values (8 bytes each)

func vec_new() *u8 {
    var v *u8 = malloc(24);

    // Initialize capacity to 8
    var cap_ptr *i64 = v;
    *cap_ptr = 8;

    // Initialize length to 0
    var len_ptr *i64 = v + 8;
    *len_ptr = 0;

    // Allocate initial data array (8 slots * 8 bytes = 64 bytes)
    var data_ptr **u8 = v + 16;
    *data_ptr = malloc(64);

    return v;
}

func vec_len(v *u8) i64 {
    var len_ptr *i64 = v + 8;
    return *len_ptr;
}

func vec_get(v *u8, index i64) i64 {
    var data_ptr **u8 = v + 16;
    var data *u8 = *data_ptr;
    var elem_ptr *i64 = data + index * 8;
    return *elem_ptr;
}

func vec_set(v *u8, index i64, value i64) {
    var data_ptr **u8 = v + 16;
    var data *u8 = *data_ptr;
    var elem_ptr *i64 = data + index * 8;
    *elem_ptr = value;
}

func vec_push(v *u8, value i64) {
    var cap_ptr *i64 = v;
    var len_ptr *i64 = v + 8;
    var data_ptr **u8 = v + 16;

    var cap i64 = *cap_ptr;
    var len i64 = *len_ptr;
    var data *u8 = *data_ptr;

    // Check if we need to grow
    if len >= cap {
        // Double capacity
        var new_cap i64 = cap * 2;
        var new_data *u8 = malloc(new_cap * 8);

        // Copy old data
        var i i64 = 0;
        while i < len {
            var old_ptr *i64 = data + i * 8;
            var new_ptr *i64 = new_data + i * 8;
            *new_ptr = *old_ptr;
            i = i + 1;
        }

        // Free old data and update vec
        free(data);
        *cap_ptr = new_cap;
        *data_ptr = new_data;
        data = new_data;
    }

    // Add element
    var elem_ptr *i64 = data + len * 8;
    *elem_ptr = value;
    *len_ptr = len + 1;
}

func vec_free(v *u8) {
    var data_ptr **u8 = v + 16;
    var data *u8 = *data_ptr;
    free(data);
    free(v);
}

func vec_pop(v *u8) i64 {
    var len_ptr *i64 = v + 8;
    var data_ptr **u8 = v + 16;
    var len i64 = *len_ptr;
    if len == 0 {
        return 0;  // Empty vector
    }
    len = len - 1;
    *len_ptr = len;
    var data *u8 = *data_ptr;
    var elem_ptr *i64 = data + len * 8;
    return *elem_ptr;
}

// ============================================================
// Hash Map (string keys -> i64 values)
// ============================================================
// Map layout: [capacity:8][count:8][keys:8][values:8] = 32 bytes
// keys: array of *u8 (nil = empty slot)
// values: array of i64
// Uses open addressing with linear probing

func hash_str(s *u8) i64 {
    // djb2 hash
    var h i64 = 5381;
    while *s != 0 {
        h = h * 33 + *s;
        s = s + 1;
    }
    // Make positive
    if h < 0 {
        h = 0 - h;
    }
    return h;
}

func map_new() *u8 {
    var m *u8 = malloc(32);

    // Initial capacity 16
    var cap_ptr *i64 = m;
    *cap_ptr = 16;

    // Count 0
    var count_ptr *i64 = m + 8;
    *count_ptr = 0;

    // Allocate keys array (16 * 8 = 128 bytes)
    var keys_ptr **u8 = m + 16;
    var keys *u8 = malloc(128);
    *keys_ptr = keys;

    // Initialize keys to nil
    var i i64 = 0;
    while i < 16 {
        var slot **u8 = keys + i * 8;
        *slot = nil;
        i = i + 1;
    }

    // Allocate values array (16 * 8 = 128 bytes)
    var vals_ptr **u8 = m + 24;
    *vals_ptr = malloc(128);

    return m;
}

func map_find_slot(m *u8, key *u8) i64 {
    // Returns index where key is or should be inserted
    var cap_ptr *i64 = m;
    var cap i64 = *cap_ptr;
    var keys_ptr **u8 = m + 16;
    var keys *u8 = *keys_ptr;

    var h i64 = hash_str(key) % cap;
    var i i64 = 0;

    while i < cap {
        var idx i64 = (h + i) % cap;
        var slot **u8 = keys + idx * 8;
        var slot_key *u8 = *slot;

        if slot_key == nil {
            return idx;
        }
        if streq(slot_key, key) {
            return idx;
        }
        i = i + 1;
    }

    // Should never reach here if load factor < 1
    return 0 - 1;
}

func map_grow(m *u8) {
    var cap_ptr *i64 = m;
    var count_ptr *i64 = m + 8;
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;

    var old_cap i64 = *cap_ptr;
    var old_keys *u8 = *keys_ptr;
    var old_vals *u8 = *vals_ptr;

    // Double capacity
    var new_cap i64 = old_cap * 2;
    *cap_ptr = new_cap;
    *count_ptr = 0;

    // Allocate new arrays
    var new_keys *u8 = malloc(new_cap * 8);
    var new_vals *u8 = malloc(new_cap * 8);

    // Initialize new keys to nil
    var i i64 = 0;
    while i < new_cap {
        var slot **u8 = new_keys + i * 8;
        *slot = nil;
        i = i + 1;
    }

    *keys_ptr = new_keys;
    *vals_ptr = new_vals;

    // Rehash old entries
    i = 0;
    while i < old_cap {
        var old_slot **u8 = old_keys + i * 8;
        var old_key *u8 = *old_slot;

        if old_key != nil {
            var old_val_ptr *i64 = old_vals + i * 8;
            var old_val i64 = *old_val_ptr;

            // Insert into new table
            var idx i64 = map_find_slot(m, old_key);
            var new_slot **u8 = new_keys + idx * 8;
            *new_slot = old_key;
            var new_val_ptr *i64 = new_vals + idx * 8;
            *new_val_ptr = old_val;

            var count i64 = *count_ptr;
            *count_ptr = count + 1;
        }
        i = i + 1;
    }

    free(old_keys);
    free(old_vals);
}

func map_set(m *u8, key *u8, value i64) {
    var cap_ptr *i64 = m;
    var count_ptr *i64 = m + 8;
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;

    var cap i64 = *cap_ptr;
    var count i64 = *count_ptr;

    // Check load factor (> 0.75 = count * 4 > cap * 3)
    if count * 4 > cap * 3 {
        map_grow(m);
    }

    var keys *u8 = *keys_ptr;
    var vals *u8 = *vals_ptr;

    var idx i64 = map_find_slot(m, key);
    var slot **u8 = keys + idx * 8;
    var slot_key *u8 = *slot;

    // Set key if new slot
    if slot_key == nil {
        *slot = key;
        count = *count_ptr;
        *count_ptr = count + 1;
    }

    // Set value
    var val_ptr *i64 = vals + idx * 8;
    *val_ptr = value;
}

func map_get(m *u8, key *u8) i64 {
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;
    var keys *u8 = *keys_ptr;
    var vals *u8 = *vals_ptr;

    var idx i64 = map_find_slot(m, key);
    var slot **u8 = keys + idx * 8;
    var slot_key *u8 = *slot;

    if slot_key == nil {
        return 0;  // Not found, return 0
    }

    var val_ptr *i64 = vals + idx * 8;
    return *val_ptr;
}

func map_has(m *u8, key *u8) i64 {
    var keys_ptr **u8 = m + 16;
    var keys *u8 = *keys_ptr;

    var idx i64 = map_find_slot(m, key);
    var slot **u8 = keys + idx * 8;
    var slot_key *u8 = *slot;

    if slot_key == nil {
        return 0;
    }
    return 1;
}

func map_free(m *u8) {
    var keys_ptr **u8 = m + 16;
    var vals_ptr **u8 = m + 24;
    free(*keys_ptr);
    free(*vals_ptr);
    free(m);
}

// Make a null-terminated copy of a string with explicit length
func str_dup_n(s *u8, len i64) *u8 {
    var result *u8 = malloc(len + 1);
    var i i64 = 0;
    while i < len {
        *(result + i) = *(s + i);
        i = i + 1;
    }
    *(result + len) = 0;
    return result;
}

// Map set/get with length-prefixed keys (creates null-terminated copy)
func map_set_n(m *u8, key *u8, key_len i64, value i64) void {
    var key_copy *u8 = str_dup_n(key, key_len);
    map_set(m, key_copy, value);
}

func map_get_n(m *u8, key *u8, key_len i64) i64 {
    var key_copy *u8 = str_dup_n(key, key_len);
    var result i64 = map_get(m, key_copy);
    free(key_copy);
    return result;
}

// ============================================================
// File I/O
// ============================================================

func file_open(path *u8, flags i64) i64 {
    // syscall 2 = open, 420 = 0644 permissions
    return syscall(2, path, flags, 420);
}

func file_read(fd i64, buf *u8, n i64) i64 {
    // syscall 0 = read
    return syscall(0, fd, buf, n);
}

func file_write(fd i64, buf *u8, n i64) i64 {
    // syscall 1 = write
    return syscall(1, fd, buf, n);
}

func file_close(fd i64) {
    // syscall 3 = close
    syscall(3, fd);
}

// ============================================================
// Strings
// ============================================================

func strlen(s *u8) i64 {
    var n i64 = 0;
    while *(s + n) != 0 {
        n = n + 1;
    }
    return n;
}

func streq(a *u8, b *u8) i64 {
    while *a != 0 && *b != 0 {
        if *a != *b {
            return 0;
        }
        a = a + 1;
        b = b + 1;
    }
    if *a == *b {
        return 1;
    }
    return 0;
}

// Compare two strings with explicit lengths
func str_eq_n(a *u8, a_len i64, b *u8, b_len i64) bool {
    if a_len != b_len {
        return false;
    }
    var i i64 = 0;
    while i < a_len {
        if *(a + i) != *(b + i) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

func str_concat(a *u8, b *u8) *u8 {
    var len_a i64 = strlen(a);
    var len_b i64 = strlen(b);
    var result *u8 = malloc(len_a + len_b + 1);

    // Copy a
    var i i64 = 0;
    while i < len_a {
        *(result + i) = *(a + i);
        i = i + 1;
    }

    // Copy b
    var j i64 = 0;
    while j < len_b {
        *(result + len_a + j) = *(b + j);
        j = j + 1;
    }

    // Null terminate
    *(result + len_a + len_b) = 0;

    return result;
}

func str_dup(s *u8) *u8 {
    var len i64 = strlen(s);
    var result *u8 = malloc(len + 1);
    var i i64 = 0;
    while i <= len {
        *(result + i) = *(s + i);
        i = i + 1;
    }
    return result;
}

// ============================================================
// I/O helpers
// ============================================================

func print(s *u8) {
    file_write(1, s, strlen(s));
}

func println(s *u8) {
    print(s);
    file_write(1, "\n", 1);
}

func eprint(s *u8) {
    file_write(2, s, strlen(s));
}

func eprintln(s *u8) {
    eprint(s);
    file_write(2, "\n", 1);
}

func eprint_buf(buf *u8, len i64) {
    file_write(2, buf, len);
}

func eprint_i64(n i64) {
    if n < 0 {
        file_write(2, "-", 1);
        n = 0 - n;
    }

    if n == 0 {
        file_write(2, "0", 1);
        return;
    }

    // Find the highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Print each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        var c u8 = 48 + digit;  // '0' = 48
        file_write(2, &c, 1);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

// ============================================================
// Process
// ============================================================

func exit(code i64) {
    // syscall 60 = exit
    syscall(60, code);
}

// ============================================================
// Numeric helpers (useful for debugging)
// ============================================================

func print_digit(d i64) {
    var c u8 = 48 + d;  // '0' = 48
    file_write(1, &c, 1);
}

func print_int(n i64) {
    if n < 0 {
        file_write(1, "-", 1);
        n = 0 - n;
    }

    if n == 0 {
        file_write(1, "0", 1);
        return;
    }

    // Find the highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Print each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        print_digit(digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}
