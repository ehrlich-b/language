// ============================================================
// std/sexpr_reader.lang - S-Expression Reader Macro
// ============================================================
//
// Usage:
//   include "std/sexpr_reader.lang"
//
//   var x i64 = #sexpr{ (+ 1 2) };       // expands to: (1 + 2)
//   var y i64 = #sexpr{ (* 3 (+ 1 2)) }; // expands to: (3 * (1 + 2))
//
// Converts prefix s-expressions to infix lang expressions.
// Supports: +, -, *, /, numbers, and nested expressions.

include "std/parser_reader.lang"

// Generate s-expression parser
#parser{
    sexp = number | symbol | operator | list
    list = '(' sexp* ')'
}

// Convert parsed s-expression to lang source code
func sexpr_to_lang(node *PNode) *u8 {
    if node == nil {
        return "nil";
    }

    var sb *StringBuilder = sb_new();
    sexpr_emit(sb, node);
    return sb_finish(sb);
}

func sexpr_emit(sb *StringBuilder, node *PNode) void {
    if node == nil {
        sb_str(sb, "nil");
        return;
    }

    // kind 1 = number, kind 2 = symbol (from rdgen)
    if node.kind == 1 {
        // Number - emit as-is
        sb_str(sb, node.text);
        return;
    }

    if node.kind == 2 {
        // Symbol - emit as-is (variable reference)
        sb_str(sb, node.text);
        return;
    }

    if node.kind == 5 {
        // Operator - emit as-is
        sb_str(sb, node.text);
        return;
    }

    // kind 4 = sequence (list)
    // A list node has children: [lparen, sexp*, rparen]
    // The sexp* node is at index 1, and its children are the actual elements
    if node.kind == 4 {
        var inner *PNode = vec_get(node.children, 1);
        var count i64 = vec_len(inner.children);

        if count == 0 {
            // Empty list - shouldn't happen in valid sexpr
            sb_str(sb, "0");
            return;
        }

        // First element should be operator
        var op_node *PNode = vec_get(inner.children, 0);
        if op_node == nil {
            sb_str(sb, "0");
            return;
        }

        var op *u8 = op_node.text;

        if count == 1 {
            // Single element - just emit it
            sexpr_emit(sb, op_node);
            return;
        }

        if count == 2 {
            // Unary: (- x) -> (0 - x)
            sb_str(sb, "(0 ");
            sb_str(sb, op);
            sb_str(sb, " ");
            sexpr_emit(sb, vec_get(inner.children, 1));
            sb_str(sb, ")");
            return;
        }

        // Binary or more: (+ a b c) -> ((a + b) + c)
        sb_str(sb, "(");
        sexpr_emit(sb, vec_get(inner.children, 1));

        var i i64 = 2;
        while i < count {
            sb_str(sb, " ");
            sb_str(sb, op);
            sb_str(sb, " ");
            sexpr_emit(sb, vec_get(inner.children, i));
            i = i + 1;
        }
        sb_str(sb, ")");
        return;
    }

    // Unknown kind - emit 0
    sb_str(sb, "0");
}

reader sexpr(text *u8) *u8 {
    var t *Tokenizer = tok_new(text);
    var node *PNode = parse_sexp(t);
    return sexpr_to_lang(node);
}
