// src/main.lang - Main entry point for self-hosting compiler

func read_file(path *u8) *u8 {
    var fd i64 = file_open(path, 0);  // O_RDONLY
    if fd < 0 {
        eprint("Error: cannot open file: ");
        eprintln(path);
        return nil;
    }

    var buf *u8 = alloc(1048576);  // 1MB max file size
    var n i64 = file_read(fd, buf, 1048576);
    file_close(fd);

    if n < 0 {
        eprintln("Error: cannot read file");
        return nil;
    }

    // Null-terminate
    *(buf + n) = 0;

    return buf;
}

// Get argv[i] - argv is array of char pointers
func get_arg(argv **u8, i i64) *u8 {
    var p **u8 = argv + (i * 8);
    return *p;
}

func main(argc i64, argv **u8) i64 {
    if argc < 2 {
        eprintln("Usage: lang1 <file.lang>... [-o output.s]");
        return 1;
    }

    // Parse arguments
    var output_file *u8 = nil;
    var source_buf *u8 = alloc(4194304);  // 4MB for all sources
    var source_len i64 = 0;

    var i i64 = 1;
    while i < argc {
        var arg *u8 = get_arg(argv, i);

        // Check for -o flag
        if *arg == 45 {  // '-'
            if *(arg + 1) == 111 {  // 'o'
                i = i + 1;
                if i < argc {
                    output_file = get_arg(argv, i);
                }
            }
        } else {
            // Input file
            var content *u8 = read_file(arg);
            if content == nil {
                return 1;
            }
            var content_len i64 = strlen(content);

            // Copy to source buffer
            var j i64 = 0;
            while j < content_len {
                *(source_buf + source_len) = *(content + j);
                source_len = source_len + 1;
                j = j + 1;
            }
            // Add newline separator
            *(source_buf + source_len) = 10;
            source_len = source_len + 1;
        }
        i = i + 1;
    }

    // Null-terminate
    *(source_buf + source_len) = 0;

    if source_len == 0 {
        eprintln("Error: no input files");
        return 1;
    }

    if output_file == nil {
        output_file = "a.s";
    }

    // Tokenize
    parser_tokenize(source_buf);

    // Check for lexer errors
    i = 0;
    while i < parser_token_count() {
        var tok *u8 = get_token(i);
        if tok_type(tok) == TOKEN_ERROR {
            eprint("Error: ");
            eprintln(tok_lexeme(tok));
            return 1;
        }
        i = i + 1;
    }

    // Parse
    var prog *u8 = parse_program();

    if parse_error_count > 0 {
        return 1;
    }

    // Generate
    generate(prog, output_file);

    print("Wrote ");
    println(output_file);

    return 0;
}
