// src/main.lang - Main entry point for self-hosting compiler

// Get file extension (returns pointer to extension after last '.')
// Returns nil if no extension found
func get_extension(path *u8) *u8 {
    var len i64 = strlen(path);
    var p *u8 = path + len - 1;

    // Walk backwards to find last '.'
    while p >= path {
        if *p == 46 {  // '.'
            return p + 1;  // Return part after '.'
        }
        if *p == 47 {  // '/' - stop at path separator
            return nil;
        }
        p = p - 1;
    }
    return nil;
}

// Check if extension matches "lang"
func is_lang_extension(ext *u8) i64 {
    if ext == nil {
        return 0;
    }
    // Check "lang\0"
    if *ext == 'l' && *(ext + 1) == 'a' && *(ext + 2) == 'n' && *(ext + 3) == 'g' && *(ext + 4) == 0 {
        return 1;
    }
    return 0;
}

func read_file(path *u8) *u8 {
    var fd i64 = file_open(path, 0);  // O_RDONLY
    if fd < 0 {
        eprint("Error: cannot open file: ");
        eprintln(path);
        return nil;
    }

    var buf *u8 = alloc(1048576);  // 1MB max file size
    var n i64 = file_read(fd, buf, 1048576);
    file_close(fd);

    if n < 0 {
        eprintln("Error: cannot read file");
        return nil;
    }

    // Null-terminate
    *(buf + n) = 0;

    return buf;
}

// Get argv[i] - argv is array of char pointers
// Uses *u8 cast for bootstrap compatibility (works with both old and new compilers)
func get_arg(argv **u8, i i64) *u8 {
    var base *u8 = argv;
    var p **u8 = base + (i * 8);  // Manual byte offset on *u8
    return *p;
}

// Helper to append string to source buffer
func append_str(buf *u8, len *i64, s *u8) void {
    while *s != 0 {
        *(buf + *len) = *s;
        *len = *len + 1;
        s = s + 1;
    }
}

// Global flags for AST modes
var emit_ast_mode i64 = 0;
var from_ast_mode i64 = 0;
var from_ast_file *u8 = nil;

func main(argc i64, argv **u8) i64 {
    if argc < 2 {
        eprintln("Usage: lang <file.lang>... [-o output.s] [--expand-macros] [--emit-ast] [--from-ast] [-c reader]");
        return 1;
    }

    // Parse arguments - first pass collects files
    var output_file *u8 = nil;
    var gen_compiler *u8 = nil;  // For -c flag: generate compiler for this reader
    var input_files *u8 = vec_new(16);  // Collect input file paths

    var i i64 = 1;
    while i < argc {
        var arg *u8 = get_arg(argv, i);
        var handled i64 = 0;

        // Check for --expand-macros flag
        if *arg == 45 && *(arg + 1) == 45 {  // '--'
            if memcmp(arg + 2, "expand-macros", 13) {
                cg_expand_macros = 1;
                handled = 1;
            }
            // Check for --emit-ast flag
            if handled == 0 && memcmp(arg + 2, "emit-ast", 8) {
                emit_ast_mode = 1;
                handled = 1;
            }
            // Check for --from-ast flag
            if handled == 0 && memcmp(arg + 2, "from-ast", 8) {
                from_ast_mode = 1;
                handled = 1;
            }
        }

        // Check for -c flag (generate standalone compiler for reader)
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 'c' && *(arg + 2) == 0 {
                i = i + 1;
                if i < argc {
                    gen_compiler = get_arg(argv, i);
                }
                handled = 1;
            }
        }

        // Check for -o flag
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 111 {  // 'o'
                i = i + 1;
                if i < argc {
                    output_file = get_arg(argv, i);
                }
                handled = 1;
            }
        }

        if handled == 0 {
            // Input file - collect for later processing
            vec_push(input_files, arg);
        }
        i = i + 1;
    }

    // Build source based on mode
    var source_buf *u8 = alloc(4194304);  // 4MB for all sources
    var source_len i64 = 0;

    if gen_compiler != nil {
        // -c mode: Generate standalone compiler
        // 1. Include all .lang files from CLI (reader sources)
        //    This ensures the reader gets compiled to .lang-cache/readers/<name>
        i = 0;
        while i < vec_len(input_files) {
            var path *u8 = vec_get(input_files, i);
            append_str(source_buf, &source_len, "include \"");
            append_str(source_buf, &source_len, path);
            append_str(source_buf, &source_len, "\"\n");
            i = i + 1;
        }

        // 2. Generate glue function that calls the reader directly
        append_str(source_buf, &source_len, "func reader_transform(t *u8) *u8 { return ");
        append_str(source_buf, &source_len, gen_compiler);
        append_str(source_buf, &source_len, "(t); }\n");

        // 3. Include standalone template (provides main and compiler infrastructure)
        append_str(source_buf, &source_len, "include \"src/standalone.lang\"\n");

        // 4. Add ___main wrapper
        append_str(source_buf, &source_len, "func ___main(argc i64, argv **u8) i64 { return main(argc, argv); }\n");

    } else {
        // Normal mode: Compile user program
        i = 0;
        while i < vec_len(input_files) {
            var arg *u8 = vec_get(input_files, i);
            var ext *u8 = get_extension(arg);

            if ext != nil && is_lang_extension(ext) == 0 {
                // Non-.lang file: read content and wrap in #ext{ content }
                var content *u8 = read_file(arg);
                if content == nil {
                    return 1;
                }

                append_str(source_buf, &source_len, "#");
                append_str(source_buf, &source_len, ext);
                append_str(source_buf, &source_len, "{");
                append_str(source_buf, &source_len, content);
                append_str(source_buf, &source_len, "}\n");
            } else {
                // .lang file: generate include statement
                append_str(source_buf, &source_len, "include \"");
                append_str(source_buf, &source_len, arg);
                append_str(source_buf, &source_len, "\"\n");
            }
            i = i + 1;
        }

        // Add ___main wrapper that calls user's main (skip in --emit-ast mode for composition)
        // Passes argc/argv - arg count check skipped for 'main' to support both signatures
        if emit_ast_mode == 0 {
            append_str(source_buf, &source_len, "func ___main(argc i64, argv **u8) i64 { return main(argc, argv); }\n");
        }
    }

    // Null-terminate
    *(source_buf + source_len) = 0;

    if output_file == nil {
        output_file = "a.s";
    }

    // --from-ast mode: parse S-expression AST directly
    if from_ast_mode != 0 {
        if vec_len(input_files) == 0 {
            eprintln("Error: no input file for --from-ast");
            return 1;
        }

        var ast_file *u8 = vec_get(input_files, 0);
        var ast_source *u8 = read_file(ast_file);
        if ast_source == nil {
            return 1;
        }

        var prog *u8 = parse_ast_from_string(ast_source);
        if prog == nil {
            eprintln("Error: failed to parse AST");
            return 1;
        }

        // Generate assembly
        generate(prog, output_file);

        print("Wrote ");
        println(output_file);
        return 0;
    }

    if source_len == 0 {
        eprintln("Error: no input files");
        return 1;
    }

    // Tokenize
    parser_tokenize(source_buf);

    // Check for lexer errors
    i = 0;
    while i < parser_token_count() {
        var tok *u8 = get_token(i);
        if tok_type(tok) == TOKEN_ERROR {
            eprint("Error: ");
            eprintln(tok_lexeme(tok));
            return 1;
        }
        i = i + 1;
    }

    // Parse
    var prog *u8 = parse_program();

    if parse_error_count > 0 {
        return 1;
    }

    // Output based on mode
    if emit_ast_mode != 0 {
        // Emit AST as S-expressions
        var ast_str *u8 = ast_emit_program(prog);

        // Write to output file
        // O_WRONLY=1 | O_CREAT=64 | O_TRUNC=512 = 577
        var fd i64 = file_open(output_file, 577);
        if fd < 0 {
            eprint("Error: cannot open output file: ");
            eprintln(output_file);
            return 1;
        }
        file_write(fd, ast_str, strlen(ast_str));
        file_close(fd);

        print("Wrote AST to ");
        println(output_file);
    } else {
        // Generate assembly
        generate(prog, output_file);

        print("Wrote ");
        println(output_file);
    }

    return 0;
}
