// src/main.lang - Main entry point for self-hosting compiler

// ============================================================
// CLI helpers
// ============================================================

// Check if string contains a dot (has extension)
func has_extension(s *u8) i64 {
    while *s != 0 {
        if *s == '.' { return 1; }
        s = s + 1;
    }
    return 0;
}

// Get file extension (returns pointer to extension after last '.')
// Returns nil if no extension found
func get_extension(path *u8) *u8 {
    var len i64 = strlen(path);
    var p *u8 = path + len - 1;

    // Walk backwards to find last '.'
    while p >= path {
        if *p == 46 {  // '.'
            return p + 1;  // Return part after '.'
        }
        if *p == 47 {  // '/' - stop at path separator
            return nil;
        }
        p = p - 1;
    }
    return nil;
}

// Check if extension matches "lang"
func is_lang_extension(ext *u8) i64 {
    if ext == nil {
        return 0;
    }
    // Check "lang\0"
    if *ext == 'l' && *(ext + 1) == 'a' && *(ext + 2) == 'n' && *(ext + 3) == 'g' && *(ext + 4) == 0 {
        return 1;
    }
    return 0;
}

func read_file(path *u8) *u8 {
    var fd i64 = file_open(path, 0);  // O_RDONLY
    if fd < 0 {
        eprint("Error: cannot open file: ");
        eprintln(path);
        return nil;
    }

    var buf *u8 = alloc(SIZE_AST_EMIT);  // Use same limit as AST emit
    var n i64 = file_read(fd, buf, SIZE_AST_EMIT);
    file_close(fd);

    if n < 0 {
        eprintln("Error: cannot read file");
        return nil;
    }

    // Null-terminate
    *(buf + n) = 0;

    return buf;
}

// Get argv[i] - argv is array of char pointers
// Uses *u8 cast for bootstrap compatibility (works with both old and new compilers)
func get_arg(argv **u8, i i64) *u8 {
    var base *u8 = argv;
    var p **u8 = base + (i * 8);  // Manual byte offset on *u8
    return *p;
}

// Helper to append string to source buffer
func append_str(buf *u8, len *i64, s *u8) void {
    while *s != 0 {
        *(buf + *len) = *s;
        *len = *len + 1;
        s = s + 1;
    }
}

// Global flags for AST modes
var emit_ast_mode i64 = 0;
var emit_expanded_ast_mode i64 = 0;  // Emit with includes fully expanded (NO ___main, for composition)
var emit_exe_ast_mode i64 = 0;       // Emit with includes expanded AND ___main (standalone executable)
var from_ast_mode i64 = 0;
var from_ast_file *u8 = nil;
var embed_self_mode i64 = 0;  // --embed-self: inject AST file into self_kernel variable
var add_reader_mode i64 = 0;  // -r: add reader to self-aware kernel
var add_reader_name *u8 = nil;
var add_reader_file *u8 = nil;

// Self-awareness: kernel carries its own AST for quine pattern
// Initialized empty, --embed-self pokes the real AST in
var self_kernel *u8 = "";

// Kernel modules registry: tracks what modules are baked into this kernel
// Populated by --embed-self from (modules ...) node in AST
// Used by -r mode to skip redundant requires
// Format: nil-terminated array of module path strings
var kernel_modules [256]*u8 = [];

// Kernel built-in modules for distribution fallback
// When no local source file exists, these provide the AST
// Populated by --embed-self mode from source files
var kernel_builtin_modules [256]*u8 = [];  // Extension-less names: "std/core", ...
var kernel_builtin_asts [256]*u8 = [];     // Full AST strings: "(program ...)", ...

// Embedded reader registry (in codegen.lang):
// var embedded_reader_names [1024]*u8 = [];
// var embedded_reader_funcs [1024]*u8 = [];
// These get poked by -r mode to add readers (arrays, nil-terminated)

// Find kernel built-in module by name (extension-less)
// Returns the AST string or nil if not found
func find_kernel_builtin(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < 256 {
        var mod *u8 = kernel_builtin_modules[i];
        if mod == nil {
            return nil;  // End of list
        }
        var mod_len i64 = strlen(mod);
        if mod_len == name_len && memcmp(mod, name, name_len) {
            return kernel_builtin_asts[i];
        }
        i = i + 1;
    }
    return nil;
}

// Check if a module path is in kernel_modules
// Returns 1 if found, 0 if not
// Handles: "std/core" matches "std/core.lang", "std/core.lisp", etc.
// Uses dynamic extension matching - checks for path + "." prefix
func has_kernel_module(path *u8, path_len i64) i64 {
    var i i64 = 0;
    while i < 256 {
        var mod *u8 = kernel_modules[i];
        if mod == nil {
            return 0;  // End of list
        }
        var mod_len i64 = strlen(mod);

        // Exact match (for paths that already have extension)
        if mod_len == path_len && memcmp(mod, path, path_len) {
            return 1;
        }

        // Check if mod starts with path + "." (any extension)
        // e.g., "std/core.lang" matches "std/core" because it starts with "std/core."
        // But "std/core_extra.lang" does NOT match "std/core" (no dot after path)
        if mod_len > path_len + 1 {  // mod must be at least path + "." + one char
            if memcmp(mod, path, path_len) {
                // Check for '.' immediately after path
                if *(mod + path_len) == 46 {  // '.'
                    return 1;
                }
            }
        }

        i = i + 1;
    }
    return 0;
}

// Include expansion state for --emit-expanded-ast
var expand_included_map *u8 = nil;
var expand_collected_decls *u8 = nil;  // Vec of declarations
var expand_input_files *u8 = nil;      // Vec of input file paths (for modules tracking)

// Recursively expand includes and collect declarations
func expand_collect_decl(decl *u8) void {
    var k i64 = node_kind(decl);

    if k == NODE_INCLUDE_DECL {
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Skip if already included
        var path_str *u8 = str_dup_n(path, path_len);
        if map_has(expand_included_map, path_str) {
            return;
        }
        map_set(expand_included_map, path_str, 1);

        // Read and parse file
        var buf *u8 = alloc(1048576);
        var fd i64 = file_open(path_str, 0);
        if fd < 0 {
            eprint("Error: cannot open include file: ");
            eprintln(path_str);
            return;
        }
        var n i64 = file_read(fd, buf, 1048576);
        file_close(fd);
        if n < 0 { return; }
        *(buf + n) = 0;

        // Parse
        parser_tokenize(buf);
        var prog *u8 = parse_program();
        if prog == nil || parse_error_count > 0 {
            eprint("Error: cannot parse include file: ");
            eprintln(path_str);
            return;
        }

        // Recursively collect declarations
        var inc_decls *u8 = program_decls(prog);
        var inc_count i64 = program_decl_count(prog);
        var j i64 = 0;
        while j < inc_count {
            expand_collect_decl(get_decl(inc_decls, j));
            j = j + 1;
        }
    } else {
        // Non-include declaration - add to collected list
        vec_push(expand_collected_decls, decl);
    }
}

// Build expanded program from collected declarations
func build_expanded_program() *u8 {
    // Count modules: input files + included files
    var input_count i64 = vec_len(expand_input_files);
    var include_count i64 = map_size(expand_included_map);
    var module_count i64 = input_count + include_count;

    // Build modules node
    var modules_node *u8 = modules_decl_alloc();
    var mods *u8 = alloc(module_count * 16);
    modules_decl_set_modules(modules_node, mods);
    modules_decl_set_count(modules_node, module_count);

    // Add input files
    var i i64 = 0;
    while i < input_count {
        var path *u8 = vec_get(expand_input_files, i);
        var entry *u8 = mods + (i * 16);
        module_entry_set(entry, path, strlen(path));
        i = i + 1;
    }

    // Add included files from map
    var keys *u8 = map_keys(expand_included_map);
    var j i64 = 0;
    while j < include_count {
        var key *u8 = vec_get(keys, j);
        var entry *u8 = mods + ((input_count + j) * 16);
        module_entry_set(entry, key, strlen(key));
        j = j + 1;
    }

    // Collect all decls (+1 for modules node at front)
    var decl_count i64 = vec_len(expand_collected_decls);
    var total_count i64 = decl_count + 1;
    var decls *u8 = alloc(total_count * 8);

    // First decl is modules node
    var dp0 **u8 = decls;
    *dp0 = modules_node;

    // Copy rest of declarations
    i = 0;
    while i < decl_count {
        var d *u8 = vec_get(expand_collected_decls, i);
        var dp **u8 = decls + ((i + 1) * 8);
        *dp = d;
        i = i + 1;
    }

    // Build program node
    var prog *u8 = alloc(16);
    var pd **u8 = prog;
    *pd = decls;
    var pc *i64 = prog + 8;
    *pc = total_count;

    return prog;
}

// ============================================================
// Subcommands
// ============================================================

func cmd_help_compile() i64 {
    println("lang compile - compile source files to assembly");
    println("");
    println("Usage: lang [compile] <files...> -o <output>");
    println("");
    println("The 'compile' command is implicit when the first argument has a file extension.");
    println("");
    println("Examples:");
    println("  lang file.lang -o out.s");
    println("  lang compile file.lang -o out.s");
    println("  lang std/core.lang main.lang -o program.s");
    println("");
    println("Options:");
    println("  -o <file>           Output file (required)");
    println("  -c <reader>         Generate standalone compiler with reader");
    println("  --emit-ast          Emit AST S-expressions instead of assembly");
    println("  --emit-expanded-ast Emit fully expanded AST (for composition, no ___main)");
    println("  --emit-exe-ast      Emit executable AST (expanded with ___main)");
    println("  --from-ast          Input is AST, not source");
    println("  --embed-self        Inject AST file into self_kernel variable");
    println("  --expand-macros     Print macro expansions to stderr");
    println("");
    println("Multi-syntax compilation:");
    println("  Files with .lang extension are parsed by the lang reader.");
    println("  Other extensions invoke reader macros: file.lisp -> #lisp{...}");
    return 0;
}

func cmd_help_env() i64 {
    println("lang env - show environment variables");
    println("");
    println("Usage: lang env [variable]");
    println("");
    println("Examples:");
    println("  lang env            Show all variables");
    println("  lang env LANGBE     Show specific variable");
    println("");
    println("Variables:");
    println("  LANGBE    Backend: x86 (default), llvm");
    println("  LANGOS    Target OS: linux (default), macos");
    println("  LANGLIBC  Libc mode: none (default), system");
    println("  PATH      Search path for tools");
    return 0;
}

func cmd_help_version() i64 {
    println("lang version - show compiler identity");
    println("");
    println("Usage: lang version");
    println("");
    println("Shows:");
    println("  - Version and commit hash");
    println("  - Build configuration (backend, OS, arch, libc)");
    println("  - Bootstrap provenance (what compiler built this)");
    println("");
    println("Aliases: --version, -V");
    return 0;
}

func cmd_help_tools() i64 {
    println("lang tools - show platform and build capabilities");
    println("");
    println("Usage: lang tools");
    println("");
    println("Shows:");
    println("  - Platform this compiler was built for");
    println("  - Available emit targets (x86, llvm)");
    println("  - Current output configuration");
    println("  - Required toolchains for building executables");
    return 0;
}

func cmd_help_help() i64 {
    println("lang help - show help information");
    println("");
    println("Usage: lang help [command]");
    println("");
    println("Examples:");
    println("  lang help            Show general help");
    println("  lang help compile    Show compile command help");
    println("  lang help env        Show env command help");
    println("");
    println("Aliases: --help, -h");
    return 0;
}

func cmd_help_compose() i64 {
    println("lang compose - create compiler with embedded reader ASTs");
    println("");
    println("Usage: lang compose -r <name> <file> [-r ...] -o <output>");
    println("");
    println("Embeds reader ASTs into a new compiler source file.");
    println("The reader source is compiled to AST, then embedded.");
    println("The resulting compiler can use those readers without external files.");
    println("");
    println("Examples:");
    println("  lang compose -r lisp reader.lang -o composed.lang");
    println("");
    println("Options:");
    println("  -r <name> <file>    Add reader (name=extension, file=source or .ast)");
    println("  -o <output>         Output file (.lang source)");
    println("");
    println("After generating, compile the output:");
    println("  LANGBE=llvm ./lang composed.lang -o out.ll && clang out.ll -o compiler");
    return 0;
}

func cmd_help(argc i64, argv **u8, arg_offset i64) i64 {
    // Check for subcommand-specific help
    // arg_offset is used because argv pointer arithmetic is unreliable
    if argc > 0 {
        var subcmd *u8 = get_arg(argv, arg_offset);
        if streq(subcmd, "compile") { return cmd_help_compile(); }
        if streq(subcmd, "compose") { return cmd_help_compose(); }
        if streq(subcmd, "env") { return cmd_help_env(); }
        if streq(subcmd, "version") { return cmd_help_version(); }
        if streq(subcmd, "tools") { return cmd_help_tools(); }
        if streq(subcmd, "help") { return cmd_help_help(); }
        // Unknown subcommand - show general help
        eprint("Unknown command: ");
        eprintln(subcmd);
        println("");
    }

    // General help
    println("lang - a self-hosted compiler where syntax is a plugin");
    println("");
    println("Usage: lang [command] [options]");
    println("");
    println("Commands:");
    println("  compile    Compile source files (default)");
    println("  compose    Create compiler with embedded readers");
    println("  help       Show this help message");
    println("  version    Show version information");
    println("  env        Show environment variables");
    println("  tools      Show toolchain availability");
    println("");
    println("Examples:");
    println("  lang file.lang -o out.s        Compile to assembly");
    println("  lang help compile              Help for compile command");
    println("");
    println("Environment:");
    println("  LANGBE=llvm         Use LLVM backend (default: x86)");
    println("  LANGOS=macos        Target macOS (default: linux)");
    println("");
    println("Run 'lang help <command>' for command-specific help.");
    return 0;
}

func cmd_version() i64 {
    // Identity: what IS this compiler binary
    print("lang ");
    print(LANG_VERSION);
    print(" (");
    print(LANG_COMMIT);
    println(")");

    // Build configuration: how this binary was built
    print("built: ");
    print(LANG_BUILD_BACKEND);
    print(", ");
    print(LANG_BUILD_OS);
    print("-");
    print(LANG_BUILD_ARCH);
    if streq(LANG_BUILD_LIBC, "system") {
        print(", libc");
    }
    println("");

    // Provenance: what compiler built this
    print("bootstrap: from ");
    println(LANG_BOOTSTRAP_FROM);

    return 0;
}

func cmd_env(argc i64, argv **u8) i64 {
    // Show specific variable if provided
    if argc > 0 {
        var name *u8 = get_arg(argv, 0);
        var val *u8 = getenv(name);
        if val != nil {
            println(val);
        }
        return 0;
    }

    // Show all relevant variables
    var langbe *u8 = getenv("LANGBE");
    print("LANGBE=");
    if langbe != nil { println(langbe); } else { println(""); }

    var langos *u8 = getenv("LANGOS");
    print("LANGOS=");
    if langos != nil { println(langos); } else { println(""); }

    var langlibc *u8 = getenv("LANGLIBC");
    print("LANGLIBC=");
    if langlibc != nil { println(langlibc); } else { println(""); }

    var path *u8 = getenv("PATH");
    print("PATH=");
    if path != nil { println(path); } else { println(""); }

    return 0;
}

// find_in_path is now in std/tools.lang (included via std/core.lang)

func print_tool_status(name *u8, desc *u8) void {
    var path *u8 = find_in_path(name);
    print("  ");
    print(name);
    // Pad to align (min 1 space)
    var len i64 = strlen(name);
    print(" ");
    while len < 8 {
        print(" ");
        len = len + 1;
    }
    if path != nil {
        print("found: ");
        println(path);
    } else {
        print("NOT FOUND  (");
        print(desc);
        println(")");
    }
}

func cmd_tools() i64 {
    // Platform: what this compiler was built for
    print("Platform: ");
    print(LANG_BUILD_OS);
    print("-");
    print(LANG_BUILD_ARCH);
    if streq(LANG_BUILD_LIBC, "system") {
        print(" (libc)");
    } else {
        print(" (no libc)");
    }
    println("");
    println("");

    // LLVM backend tools
    println("LLVM backend (LANGBE=llvm):");
    println("  Required:");
    print_tool_status("clang", ".ll -> executable");
    println("  Optional:");
    print_tool_status("lli", "run .ll directly (fast testing)");
    print_tool_status("llc", ".ll -> .s (then use as/ld)");
    println("");

    // x86 backend tools
    println("x86 backend (LANGBE=x86):");
    println("  Required:");
    print_tool_status("as", "assemble .s -> .o");
    print_tool_status("ld", "link .o -> executable");
    println("");

    // Test utilities
    println("Test utilities:");
    print_tool_status("timeout", "test timeouts (Linux)");
    print_tool_status("gtimeout", "test timeouts (macOS)");

    return 0;
}

// ============================================================
// Compose command - create compiler with embedded reader ASTs
// ============================================================

// Escape string for embedding as lang string literal
func escape_string_literal(s *u8) *u8 {
    var len i64 = 0;
    var p *u8 = s;
    while *p != 0 {
        if *p == 92 { len = len + 2; }
        else if *p == 34 { len = len + 2; }
        else if *p == 10 { len = len + 2; }
        else if *p == 9 { len = len + 2; }
        else { len = len + 1; }
        p = p + 1;
    }

    var result *u8 = alloc(len + 1);
    var out *u8 = result;
    p = s;
    while *p != 0 {
        if *p == 92 { *out = 92; out = out + 1; *out = 92; out = out + 1; }
        else if *p == 34 { *out = 92; out = out + 1; *out = 34; out = out + 1; }
        else if *p == 10 { *out = 92; out = out + 1; *out = 'n'; out = out + 1; }
        else if *p == 9 { *out = 92; out = out + 1; *out = 't'; out = out + 1; }
        else { *out = *p; out = out + 1; }
        p = p + 1;
    }
    *out = 0;
    return result;
}

func i64_to_str(n i64) *u8 {
    var buf *u8 = alloc(32);
    if n == 0 { *buf = '0'; *(buf + 1) = 0; return buf; }
    var digits *u8 = alloc(32);
    var d i64 = 0;
    while n > 0 { *(digits + d) = '0' + (n % 10); n = n / 10; d = d + 1; }
    var i i64 = 0;
    while d > 0 { d = d - 1; *(buf + i) = *(digits + d); i = i + 1; }
    *(buf + i) = 0;
    return buf;
}

// cmd_compose: TODO - will be reimplemented using kernel -r approach
// See designs/fix_composition.md for the new architecture

func main(argc i64, argv **u8) i64 {
    if argc < 2 {
        return cmd_help(0, argv, 0);
    }

    // Get first argument
    var first *u8 = get_arg(argv, 1);

    // If first arg has extension, it's a file -> compile mode
    // Otherwise, it's a subcommand
    if has_extension(first) == 0 {
        // Check for subcommands
        if streq(first, "help") || streq(first, "--help") || streq(first, "-h") {
            // argc-2 remaining args after "lang help", start at index 2
            return cmd_help(argc - 2, argv, 2);
        }
        if streq(first, "version") || streq(first, "--version") || streq(first, "-V") {
            return cmd_version();
        }
        if streq(first, "env") {
            return cmd_env(argc - 2, argv + 16);
        }
        if streq(first, "tools") {
            return cmd_tools();
        }
        if streq(first, "compile") {
            // Skip "compile" and process remaining args
            argc = argc - 1;
            argv = argv + 8;
        } else {
            // Unknown command - could be a file without extension
            // Fall through to compile mode
        }
    }

    // Parse arguments - first pass collects files
    var output_file *u8 = nil;
    var gen_compiler *u8 = nil;  // For -c flag: generate compiler for this reader
    var input_files *u8 = vec_new(16);  // Collect input file paths

    var i i64 = 1;
    while i < argc {
        var arg *u8 = get_arg(argv, i);
        var handled i64 = 0;

        // Check for --expand-macros flag
        if *arg == 45 && *(arg + 1) == 45 {  // '--'
            if memcmp(arg + 2, "expand-macros", 13) {
                cg_expand_macros = 1;
                handled = 1;
            }
            // Check for --emit-ast flag
            if handled == 0 && memcmp(arg + 2, "emit-ast", 8) {
                emit_ast_mode = 1;
                handled = 1;
            }
            // Check for --emit-expanded-ast flag (fully expand includes, NO ___main)
            if handled == 0 && memcmp(arg + 2, "emit-expanded-ast", 17) {
                emit_expanded_ast_mode = 1;
                handled = 1;
            }
            // Check for --emit-exe-ast flag (expanded includes WITH ___main for standalone)
            if handled == 0 && memcmp(arg + 2, "emit-exe-ast", 12) {
                emit_exe_ast_mode = 1;
                handled = 1;
            }
            // Check for --from-ast flag
            if handled == 0 && memcmp(arg + 2, "from-ast", 8) {
                from_ast_mode = 1;
                handled = 1;
            }
            // Check for --embed-self flag
            if handled == 0 && memcmp(arg + 2, "embed-self", 10) {
                embed_self_mode = 1;
                handled = 1;
            }
        }

        // Check for -r flag (add reader to kernel)
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 'r' && *(arg + 2) == 0 {
                i = i + 1;
                if i < argc {
                    add_reader_name = get_arg(argv, i);
                }
                i = i + 1;
                if i < argc {
                    add_reader_file = get_arg(argv, i);
                }
                add_reader_mode = 1;
                handled = 1;
            }
        }

        // Check for -c flag (generate standalone compiler for reader)
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 'c' && *(arg + 2) == 0 {
                i = i + 1;
                if i < argc {
                    gen_compiler = get_arg(argv, i);
                }
                handled = 1;
            }
        }

        // Check for -o flag
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 111 {  // 'o'
                i = i + 1;
                if i < argc {
                    output_file = get_arg(argv, i);
                }
                handled = 1;
            }
        }

        if handled == 0 {
            // Input file - collect for later processing
            vec_push(input_files, arg);
        }
        i = i + 1;
    }

    // Build source based on mode
    var source_buf *u8 = alloc(4194304);  // 4MB for all sources
    var source_len i64 = 0;

    if gen_compiler != nil {
        // -c mode: Generate standalone compiler
        // 1. Include all .lang files from CLI (reader sources)
        //    This ensures the reader gets compiled to .lang-cache/readers/<name>
        i = 0;
        while i < vec_len(input_files) {
            var path *u8 = vec_get(input_files, i);
            append_str(source_buf, &source_len, "include \"");
            append_str(source_buf, &source_len, path);
            append_str(source_buf, &source_len, "\"\n");
            i = i + 1;
        }

        // 2. Generate glue function that calls the reader directly
        append_str(source_buf, &source_len, "func reader_transform(t *u8) *u8 { return ");
        append_str(source_buf, &source_len, gen_compiler);
        append_str(source_buf, &source_len, "(t); }\n");

        // 3. Include standalone template (provides main and compiler infrastructure)
        append_str(source_buf, &source_len, "include \"src/standalone.lang\"\n");

        // 4. Add ___main wrapper (receives envp from _start)
        // Reader mode includes std/core.lang which provides init_environ
        append_str(source_buf, &source_len, "func ___main(argc i64, argv **u8, envp **u8) i64 { init_environ(envp); return main(argc, argv); }\n");

    } else {
        // Normal mode: Compile user program
        i = 0;
        while i < vec_len(input_files) {
            var arg *u8 = vec_get(input_files, i);
            var ext *u8 = get_extension(arg);

            if ext != nil && is_lang_extension(ext) == 0 {
                // Non-.lang file: read content and wrap in #ext{ content }
                var content *u8 = read_file(arg);
                if content == nil {
                    return 1;
                }

                append_str(source_buf, &source_len, "#");
                append_str(source_buf, &source_len, ext);
                append_str(source_buf, &source_len, "{");
                append_str(source_buf, &source_len, content);
                append_str(source_buf, &source_len, "}\n");
            } else {
                // .lang file: generate include statement
                append_str(source_buf, &source_len, "include \"");
                append_str(source_buf, &source_len, arg);
                append_str(source_buf, &source_len, "\"\n");
            }
            i = i + 1;
        }

        // Add ___main wrapper that calls user's main
        // Skip for: --emit-ast (debug), --emit-expanded-ast (composition), LLVM backend (clang provides entry)
        // Include for: normal x86 compile, --emit-exe-ast (standalone executable AST)
        var langbe_check *u8 = getenv("LANGBE");
        var is_llvm i64 = 0;
        if langbe_check != nil && streq(langbe_check, "llvm") {
            is_llvm = 1;
        }
        // Add ___main if: exe-ast mode OR (normal compile without AST modes and not LLVM)
        if emit_exe_ast_mode != 0 || (emit_ast_mode == 0 && emit_expanded_ast_mode == 0 && is_llvm == 0) {
            // Simple ___main - no environment setup for basic programs
            // Programs needing getenv should include std/core.lang
            append_str(source_buf, &source_len, "func ___main(argc i64, argv **u8, envp **u8) i64 { return main(argc, argv); }\n");
        }
    }

    // Null-terminate
    *(source_buf + source_len) = 0;

    if output_file == nil {
        output_file = "a.s";
    }

    // --from-ast mode: parse S-expression AST directly
    if from_ast_mode != 0 {
        if vec_len(input_files) == 0 {
            eprintln("Error: no input file for --from-ast");
            return 1;
        }

        var ast_file *u8 = vec_get(input_files, 0);
        var ast_source *u8 = read_file(ast_file);
        if ast_source == nil {
            return 1;
        }

        var prog *u8 = parse_ast_from_string(ast_source);
        if prog == nil {
            eprintln("Error: failed to parse AST");
            return 1;
        }

        // Generate using appropriate backend
        var langbe *u8 = getenv("LANGBE");
        if langbe != nil && streq(langbe, "llvm") {
            generate_llvm(prog, output_file);
        } else {
            generate(prog, output_file);
        }

        print("Wrote ");
        println(output_file);
        return 0;
    }

    // --embed-self mode: parse AST and inject raw contents into self_kernel variable
    if embed_self_mode != 0 {
        if vec_len(input_files) == 0 {
            eprintln("Error: no input file for --embed-self");
            return 1;
        }

        var ast_file *u8 = vec_get(input_files, 0);
        var ast_source *u8 = read_file(ast_file);
        if ast_source == nil {
            return 1;
        }
        var ast_source_len i64 = strlen(ast_source);

        var prog *u8 = parse_ast_from_string(ast_source);
        if prog == nil {
            eprintln("Error: failed to parse AST");
            return 1;
        }

        // First pass: find (modules ...) node and extract module paths
        var modules_node *u8 = nil;
        var decls *u8 = program_decls(prog);
        var decl_count i64 = program_decl_count(prog);
        var j i64 = 0;
        while j < decl_count {
            var decl *u8 = get_decl(decls, j);
            if node_kind(decl) == NODE_MODULES_DECL {
                modules_node = decl;
            }
            j = j + 1;
        }

        // Second pass: find self_kernel and kernel_modules, inject values
        var found_self i64 = 0;
        var found_mods i64 = 0;
        j = 0;
        while j < decl_count {
            var decl *u8 = get_decl(decls, j);
            if node_kind(decl) == NODE_VAR_DECL {
                var name *u8 = var_decl_name(decl);
                var name_len i64 = var_decl_name_len(decl);

                // Poke self_kernel with raw AST contents
                if name_len == 11 && memcmp(name, "self_kernel", 11) {
                    var str_node *u8 = string_expr_alloc();
                    string_expr_set_value(str_node, ast_source);
                    string_expr_set_value_len(str_node, ast_source_len);
                    var_decl_set_init(decl, str_node);
                    found_self = 1;
                }

                // Poke kernel_modules with module paths from (modules ...) node
                if name_len == 14 && memcmp(name, "kernel_modules", 14) {
                    if modules_node != nil {
                        // Build array literal from modules node
                        var mod_count i64 = modules_decl_count(modules_node);
                        var elements *u8 = alloc(mod_count * 8);
                        var k i64 = 0;
                        while k < mod_count {
                            var entry *u8 = modules_decl_get(modules_node, k);
                            var mod_name *u8 = module_entry_name(entry);
                            var mod_len i64 = module_entry_len(entry);

                            var str_node *u8 = string_expr_alloc();
                            string_expr_set_value(str_node, mod_name);
                            string_expr_set_value_len(str_node, mod_len);

                            var ep **u8 = elements + (k * 8);
                            *ep = str_node;
                            k = k + 1;
                        }

                        var arr_node *u8 = array_literal_alloc();
                        array_literal_set_elems(arr_node, elements);
                        array_literal_set_count(arr_node, mod_count);
                        var_decl_set_init(decl, arr_node);
                    }
                    found_mods = 1;
                }

                // Poke kernel_builtin_modules with extension-less names for std/* modules
                if name_len == 22 && memcmp(name, "kernel_builtin_modules", 22) {
                    if modules_node != nil {
                        // Count std/* modules only
                        var mod_count i64 = modules_decl_count(modules_node);
                        var std_count i64 = 0;
                        var k i64 = 0;
                        while k < mod_count {
                            var entry *u8 = modules_decl_get(modules_node, k);
                            var mod_name *u8 = module_entry_name(entry);
                            // Check for "std/" prefix
                            if *mod_name == 's' && *(mod_name + 1) == 't' && *(mod_name + 2) == 'd' && *(mod_name + 3) == '/' {
                                std_count = std_count + 1;
                            }
                            k = k + 1;
                        }

                        // Build array of extension-less names
                        var elements *u8 = alloc(std_count * 8);
                        var idx i64 = 0;
                        k = 0;
                        while k < mod_count {
                            var entry *u8 = modules_decl_get(modules_node, k);
                            var mod_name *u8 = module_entry_name(entry);
                            var mod_len i64 = module_entry_len(entry);
                            // Check for "std/" prefix
                            if *mod_name == 's' && *(mod_name + 1) == 't' && *(mod_name + 2) == 'd' && *(mod_name + 3) == '/' {
                                // Strip extension: find last '.' and truncate
                                var base_len i64 = mod_len;
                                var p i64 = mod_len - 1;
                                while p > 0 {
                                    if *(mod_name + p) == '.' {
                                        base_len = p;
                                    }
                                    p = p - 1;
                                }

                                var str_node *u8 = string_expr_alloc();
                                string_expr_set_value(str_node, mod_name);
                                string_expr_set_value_len(str_node, base_len);

                                var ep **u8 = elements + (idx * 8);
                                *ep = str_node;
                                idx = idx + 1;
                            }
                            k = k + 1;
                        }

                        var arr_node *u8 = array_literal_alloc();
                        array_literal_set_elems(arr_node, elements);
                        array_literal_set_count(arr_node, std_count);
                        var_decl_set_init(decl, arr_node);
                    }
                }

                // Poke kernel_builtin_asts with AST strings for std/* modules
                if name_len == 19 && memcmp(name, "kernel_builtin_asts", 19) {
                    if modules_node != nil {
                        // Count std/* modules only
                        var mod_count i64 = modules_decl_count(modules_node);
                        var std_count i64 = 0;
                        var k i64 = 0;
                        while k < mod_count {
                            var entry *u8 = modules_decl_get(modules_node, k);
                            var mod_name *u8 = module_entry_name(entry);
                            if *mod_name == 's' && *(mod_name + 1) == 't' && *(mod_name + 2) == 'd' && *(mod_name + 3) == '/' {
                                std_count = std_count + 1;
                            }
                            k = k + 1;
                        }

                        // Build array of AST strings
                        var elements *u8 = alloc(std_count * 8);
                        var idx i64 = 0;
                        k = 0;
                        while k < mod_count {
                            var entry *u8 = modules_decl_get(modules_node, k);
                            var mod_name *u8 = module_entry_name(entry);
                            var mod_len i64 = module_entry_len(entry);
                            if *mod_name == 's' && *(mod_name + 1) == 't' && *(mod_name + 2) == 'd' && *(mod_name + 3) == '/' {
                                // Read source file
                                var path_str *u8 = str_dup_n(mod_name, mod_len);
                                var src *u8 = read_file(path_str);
                                var ast_str *u8 = "";
                                if src != nil {
                                    // Parse and emit AST
                                    parser_tokenize(src);
                                    var mod_prog *u8 = parse_program();
                                    if mod_prog != nil && parse_error_count == 0 {
                                        ast_str = ast_emit_program(mod_prog);
                                    }
                                }

                                var str_node *u8 = string_expr_alloc();
                                string_expr_set_value(str_node, ast_str);
                                string_expr_set_value_len(str_node, strlen(ast_str));

                                var ep **u8 = elements + (idx * 8);
                                *ep = str_node;
                                idx = idx + 1;
                            }
                            k = k + 1;
                        }

                        var arr_node *u8 = array_literal_alloc();
                        array_literal_set_elems(arr_node, elements);
                        array_literal_set_count(arr_node, std_count);
                        var_decl_set_init(decl, arr_node);
                    }
                }
            }
            j = j + 1;
        }

        if found_self == 0 {
            eprintln("Error: self_kernel variable not found in AST");
            return 1;
        }

        // Generate using appropriate backend
        var langbe *u8 = getenv("LANGBE");
        if langbe != nil && streq(langbe, "llvm") {
            generate_llvm(prog, output_file);
        } else {
            generate(prog, output_file);
        }

        print("Wrote ");
        println(output_file);
        return 0;
    }

    // -r mode: add reader to self-aware kernel
    if add_reader_mode != 0 {
        if add_reader_name == nil || add_reader_file == nil {
            eprintln("Error: -r requires <name> <file.ast>");
            return 1;
        }

        // Check if we have self_kernel embedded
        if strlen(self_kernel) == 0 {
            eprintln("Error: -r requires a self-aware kernel (use --embed-self first)");
            return 1;
        }

        // Parse self_kernel to get the base AST
        var base_prog *u8 = parse_ast_from_string(self_kernel);
        if base_prog == nil {
            eprintln("Error: failed to parse self_kernel AST");
            return 1;
        }

        // Parse reader AST file
        var reader_source *u8 = read_file(add_reader_file);
        if reader_source == nil {
            return 1;
        }
        var reader_prog *u8 = parse_ast_from_string(reader_source);
        if reader_prog == nil {
            eprintln("Error: failed to parse reader AST");
            return 1;
        }

        // Combine: base + reader declarations (skipping redundant requires)
        var base_decls *u8 = program_decls(base_prog);
        var base_count i64 = program_decl_count(base_prog);
        var reader_decls *u8 = program_decls(reader_prog);
        var reader_count i64 = program_decl_count(reader_prog);

        // First pass: count reader decls that will be included (skip redundant requires)
        var included_count i64 = 0;
        var j i64 = 0;
        while j < reader_count {
            var src **u8 = reader_decls + (j * 8);
            var decl *u8 = *src;
            var skip i64 = 0;

            if node_kind(decl) == NODE_REQUIRE_DECL {
                var mod *u8 = require_decl_module(decl);
                var mod_len i64 = require_decl_module_len(decl);
                if has_kernel_module(mod, mod_len) {
                    skip = 1;  // Already in kernel, skip
                }
            }

            // Skip (modules ...) declarations too - they're metadata
            if node_kind(decl) == NODE_MODULES_DECL {
                skip = 1;
            }

            if skip == 0 {
                included_count = included_count + 1;
            }
            j = j + 1;
        }

        var total i64 = base_count + included_count;
        var combined_decls *u8 = alloc(total * 8);

        // Copy base declarations
        j = 0;
        while j < base_count {
            var src **u8 = base_decls + (j * 8);
            var dst **u8 = combined_decls + (j * 8);
            *dst = *src;
            j = j + 1;
        }

        // Copy reader declarations, skipping redundant requires
        var dst_idx i64 = base_count;
        j = 0;
        while j < reader_count {
            var src **u8 = reader_decls + (j * 8);
            var decl *u8 = *src;
            var skip i64 = 0;

            if node_kind(decl) == NODE_REQUIRE_DECL {
                var mod *u8 = require_decl_module(decl);
                var mod_len i64 = require_decl_module_len(decl);
                if has_kernel_module(mod, mod_len) {
                    skip = 1;
                }
            }

            if node_kind(decl) == NODE_MODULES_DECL {
                skip = 1;
            }

            if skip == 0 {
                var dst **u8 = combined_decls + (dst_idx * 8);
                *dst = decl;
                // Mark reader_decl nodes as having AST body (not lang source)
                if node_kind(decl) == NODE_READER_DECL {
                    reader_decl_set_is_ast(decl, 1);
                }
                dst_idx = dst_idx + 1;
            }
            j = j + 1;
        }

        // Build combined program node
        var combined_prog *u8 = alloc(16);
        var pd **u8 = combined_prog;
        *pd = combined_decls;
        var pc *i64 = combined_prog + 8;
        *pc = total;

        // Reader function name is just the reader name (e.g., "lang")
        // llvm_emit_reader() emits @lang, so we must match that
        var func_name *u8 = add_reader_name;
        var func_name_len i64 = strlen(func_name);

        // Re-stringify the combined AST
        var combined_ast_str *u8 = ast_emit_program(combined_prog);
        var combined_ast_len i64 = strlen(combined_ast_str);

        // Walk combined AST and poke:
        // - self_kernel = combined AST string
        // - embedded_reader_names = append reader name to array_literal
        // - embedded_reader_funcs = append (ident reader_<name>) to array_literal
        var found_self i64 = 0;
        var found_names i64 = 0;
        var found_funcs i64 = 0;

        j = 0;
        while j < total {
            var decl *u8 = get_decl(combined_decls, j);
            if node_kind(decl) == NODE_VAR_DECL {
                var name *u8 = var_decl_name(decl);
                var name_len i64 = var_decl_name_len(decl);

                // self_kernel
                if name_len == 11 && memcmp(name, "self_kernel", 11) {
                    var str_node *u8 = string_expr_alloc();
                    string_expr_set_value(str_node, combined_ast_str);
                    string_expr_set_value_len(str_node, combined_ast_len);
                    var_decl_set_init(decl, str_node);
                    found_self = 1;
                }

                // embedded_reader_names - append reader name to array_literal
                if name_len == 21 && memcmp(name, "embedded_reader_names", 21) {
                    var init *u8 = var_decl_init(decl);
                    if init != nil && node_kind(init) == NODE_ARRAY_LITERAL {
                        // Append string node to array
                        var old_elems *u8 = array_literal_elems(init);
                        var old_count i64 = array_literal_count(init);
                        var new_count i64 = old_count + 1;
                        var new_elems *u8 = alloc(new_count * 8);
                        // Copy old elements
                        var k i64 = 0;
                        while k < old_count {
                            var src **u8 = old_elems + (k * 8);
                            var dst **u8 = new_elems + (k * 8);
                            *dst = *src;
                            k = k + 1;
                        }
                        // Add new string element
                        var str_node *u8 = string_expr_alloc();
                        string_expr_set_value(str_node, add_reader_name);
                        string_expr_set_value_len(str_node, func_name_len);
                        var new_slot **u8 = new_elems + (old_count * 8);
                        *new_slot = str_node;
                        // Update array_literal
                        array_literal_set_elems(init, new_elems);
                        array_literal_set_count(init, new_count);
                    }
                    found_names = 1;
                }

                // embedded_reader_funcs - append ident to array_literal
                if name_len == 21 && memcmp(name, "embedded_reader_funcs", 21) {
                    var init *u8 = var_decl_init(decl);
                    if init != nil && node_kind(init) == NODE_ARRAY_LITERAL {
                        // Append ident node to array
                        var old_elems *u8 = array_literal_elems(init);
                        var old_count i64 = array_literal_count(init);
                        var new_count i64 = old_count + 1;
                        var new_elems *u8 = alloc(new_count * 8);
                        // Copy old elements
                        var k i64 = 0;
                        while k < old_count {
                            var src **u8 = old_elems + (k * 8);
                            var dst **u8 = new_elems + (k * 8);
                            *dst = *src;
                            k = k + 1;
                        }
                        // Add new ident element
                        var ident_node *u8 = ident_expr_alloc();
                        ident_expr_set_name(ident_node, func_name);
                        ident_expr_set_name_len(ident_node, func_name_len);
                        var new_slot **u8 = new_elems + (old_count * 8);
                        *new_slot = ident_node;
                        // Update array_literal
                        array_literal_set_elems(init, new_elems);
                        array_literal_set_count(init, new_count);
                    }
                    found_funcs = 1;
                }
            }
            j = j + 1;
        }

        if found_self == 0 {
            eprintln("Error: self_kernel variable not found in combined AST");
            return 1;
        }

        // Generate using appropriate backend
        var langbe *u8 = getenv("LANGBE");
        if langbe != nil && streq(langbe, "llvm") {
            generate_llvm(combined_prog, output_file);
        } else {
            generate(combined_prog, output_file);
        }

        print("Wrote ");
        print(output_file);
        print(" (added reader: ");
        print(add_reader_name);
        println(")");
        return 0;
    }

    if source_len == 0 {
        eprintln("Error: no input files");
        return 1;
    }

    // Tokenize
    parser_tokenize(source_buf);

    // Check for lexer errors
    i = 0;
    while i < parser_token_count() {
        var tok *u8 = get_token(i);
        if tok_type(tok) == TOKEN_ERROR {
            eprint("Error: ");
            eprintln(tok_lexeme(tok));
            return 1;
        }
        i = i + 1;
    }

    // Parse
    var prog *u8 = parse_program();

    if parse_error_count > 0 {
        return 1;
    }

    // Output based on mode
    if emit_expanded_ast_mode != 0 || emit_exe_ast_mode != 0 {
        // Emit FULLY EXPANDED AST (all includes resolved inline)
        // emit_expanded_ast: for composition (no ___main)
        // emit_exe_ast: for standalone compilation (has ___main)
        expand_included_map = map_new();
        expand_collected_decls = vec_new(1024);
        expand_input_files = input_files;  // Track input files for modules metadata

        // Process all declarations, expanding includes
        var decls *u8 = program_decls(prog);
        var decl_count i64 = program_decl_count(prog);
        i = 0;
        while i < decl_count {
            expand_collect_decl(get_decl(decls, i));
            i = i + 1;
        }

        // Build expanded program
        var expanded_prog *u8 = build_expanded_program();

        // Emit as S-expressions
        var ast_str *u8 = ast_emit_program(expanded_prog);

        // Write to output file
        var fd i64 = file_open(output_file, O_WRONLY_CREAT_TRUNC);
        if fd < 0 {
            eprint("Error: cannot open output file: ");
            eprintln(output_file);
            return 1;
        }
        file_write(fd, ast_str, strlen(ast_str));
        file_close(fd);

        print("Wrote expanded AST to ");
        println(output_file);
    } else if emit_ast_mode != 0 {
        // Emit AST as S-expressions (includes stay as directives)
        var ast_str *u8 = ast_emit_program(prog);

        // Write to output file
        var fd i64 = file_open(output_file, O_WRONLY_CREAT_TRUNC);
        if fd < 0 {
            eprint("Error: cannot open output file: ");
            eprintln(output_file);
            return 1;
        }
        file_write(fd, ast_str, strlen(ast_str));
        file_close(fd);

        print("Wrote AST to ");
        println(output_file);
    } else {
        // Check LANGBE environment variable for backend selection
        var langbe *u8 = getenv("LANGBE");
        if langbe != nil && streq(langbe, "llvm") {
            // LLVM IR backend
            generate_llvm(prog, output_file);
        } else {
            // Default: x86 assembly backend
            generate(prog, output_file);
        }

        print("Wrote ");
        println(output_file);
    }

    return 0;
}
