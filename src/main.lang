// src/main.lang - Main entry point for self-hosting compiler

// Get file extension (returns pointer to extension after last '.')
// Returns nil if no extension found
func get_extension(path *u8) *u8 {
    var len i64 = strlen(path);
    var p *u8 = path + len - 1;

    // Walk backwards to find last '.'
    while p >= path {
        if *p == 46 {  // '.'
            return p + 1;  // Return part after '.'
        }
        if *p == 47 {  // '/' - stop at path separator
            return nil;
        }
        p = p - 1;
    }
    return nil;
}

// Check if extension matches "lang"
func is_lang_extension(ext *u8) i64 {
    if ext == nil {
        return 0;
    }
    // Check "lang\0"
    if *ext == 'l' && *(ext + 1) == 'a' && *(ext + 2) == 'n' && *(ext + 3) == 'g' && *(ext + 4) == 0 {
        return 1;
    }
    return 0;
}

func read_file(path *u8) *u8 {
    var fd i64 = file_open(path, 0);  // O_RDONLY
    if fd < 0 {
        eprint("Error: cannot open file: ");
        eprintln(path);
        return nil;
    }

    var buf *u8 = alloc(1048576);  // 1MB max file size
    var n i64 = file_read(fd, buf, 1048576);
    file_close(fd);

    if n < 0 {
        eprintln("Error: cannot read file");
        return nil;
    }

    // Null-terminate
    *(buf + n) = 0;

    return buf;
}

// Get argv[i] - argv is array of char pointers
// Uses *u8 cast for bootstrap compatibility (works with both old and new compilers)
func get_arg(argv **u8, i i64) *u8 {
    var base *u8 = argv;
    var p **u8 = base + (i * 8);  // Manual byte offset on *u8
    return *p;
}

// Helper to append string to source buffer
func append_str(buf *u8, len *i64, s *u8) void {
    while *s != 0 {
        *(buf + *len) = *s;
        *len = *len + 1;
        s = s + 1;
    }
}

// Global flags for AST modes
var emit_ast_mode i64 = 0;
var emit_expanded_ast_mode i64 = 0;  // Emit with includes fully expanded
var from_ast_mode i64 = 0;
var from_ast_file *u8 = nil;

// Include expansion state for --emit-expanded-ast
var expand_included_map *u8 = nil;
var expand_collected_decls *u8 = nil;  // Vec of declarations

// Recursively expand includes and collect declarations
func expand_collect_decl(decl *u8) void {
    var k i64 = node_kind(decl);

    if k == NODE_INCLUDE_DECL {
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Skip if already included
        var path_str *u8 = str_dup_n(path, path_len);
        if map_has(expand_included_map, path_str) {
            return;
        }
        map_set(expand_included_map, path_str, 1);

        // Read and parse file
        var buf *u8 = alloc(1048576);
        var fd i64 = file_open(path_str, 0);
        if fd < 0 {
            eprint("Error: cannot open include file: ");
            eprintln(path_str);
            return;
        }
        var n i64 = file_read(fd, buf, 1048576);
        file_close(fd);
        if n < 0 { return; }
        *(buf + n) = 0;

        // Parse
        parser_tokenize(buf);
        var prog *u8 = parse_program();
        if prog == nil || parse_error_count > 0 {
            eprint("Error: cannot parse include file: ");
            eprintln(path_str);
            return;
        }

        // Recursively collect declarations
        var inc_decls *u8 = program_decls(prog);
        var inc_count i64 = program_decl_count(prog);
        var j i64 = 0;
        while j < inc_count {
            expand_collect_decl(get_decl(inc_decls, j));
            j = j + 1;
        }
    } else {
        // Non-include declaration - add to collected list
        vec_push(expand_collected_decls, decl);
    }
}

// Build expanded program from collected declarations
func build_expanded_program() *u8 {
    var count i64 = vec_len(expand_collected_decls);
    var decls *u8 = alloc(count * 8);

    var i i64 = 0;
    while i < count {
        var d *u8 = vec_get(expand_collected_decls, i);
        var dp **u8 = decls + (i * 8);
        *dp = d;
        i = i + 1;
    }

    // Build program node
    var prog *u8 = alloc(16);
    var pd **u8 = prog;
    *pd = decls;
    var pc *i64 = prog + 8;
    *pc = count;

    return prog;
}

func main(argc i64, argv **u8) i64 {
    if argc < 2 {
        eprintln("Usage: lang <file.lang>... [-o output.s] [--expand-macros] [--emit-ast] [--from-ast] [-c reader]");
        return 1;
    }

    // Parse arguments - first pass collects files
    var output_file *u8 = nil;
    var gen_compiler *u8 = nil;  // For -c flag: generate compiler for this reader
    var input_files *u8 = vec_new(16);  // Collect input file paths

    var i i64 = 1;
    while i < argc {
        var arg *u8 = get_arg(argv, i);
        var handled i64 = 0;

        // Check for --expand-macros flag
        if *arg == 45 && *(arg + 1) == 45 {  // '--'
            if memcmp(arg + 2, "expand-macros", 13) {
                cg_expand_macros = 1;
                handled = 1;
            }
            // Check for --emit-ast flag
            if handled == 0 && memcmp(arg + 2, "emit-ast", 8) {
                emit_ast_mode = 1;
                handled = 1;
            }
            // Check for --emit-expanded-ast flag (fully expand includes)
            if handled == 0 && memcmp(arg + 2, "emit-expanded-ast", 17) {
                emit_expanded_ast_mode = 1;
                handled = 1;
            }
            // Check for --from-ast flag
            if handled == 0 && memcmp(arg + 2, "from-ast", 8) {
                from_ast_mode = 1;
                handled = 1;
            }
        }

        // Check for -c flag (generate standalone compiler for reader)
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 'c' && *(arg + 2) == 0 {
                i = i + 1;
                if i < argc {
                    gen_compiler = get_arg(argv, i);
                }
                handled = 1;
            }
        }

        // Check for -o flag
        if handled == 0 && *arg == 45 {  // '-'
            if *(arg + 1) == 111 {  // 'o'
                i = i + 1;
                if i < argc {
                    output_file = get_arg(argv, i);
                }
                handled = 1;
            }
        }

        if handled == 0 {
            // Input file - collect for later processing
            vec_push(input_files, arg);
        }
        i = i + 1;
    }

    // Build source based on mode
    var source_buf *u8 = alloc(4194304);  // 4MB for all sources
    var source_len i64 = 0;

    if gen_compiler != nil {
        // -c mode: Generate standalone compiler
        // 1. Include all .lang files from CLI (reader sources)
        //    This ensures the reader gets compiled to .lang-cache/readers/<name>
        i = 0;
        while i < vec_len(input_files) {
            var path *u8 = vec_get(input_files, i);
            append_str(source_buf, &source_len, "include \"");
            append_str(source_buf, &source_len, path);
            append_str(source_buf, &source_len, "\"\n");
            i = i + 1;
        }

        // 2. Generate glue function that calls the reader directly
        append_str(source_buf, &source_len, "func reader_transform(t *u8) *u8 { return ");
        append_str(source_buf, &source_len, gen_compiler);
        append_str(source_buf, &source_len, "(t); }\n");

        // 3. Include standalone template (provides main and compiler infrastructure)
        append_str(source_buf, &source_len, "include \"src/standalone.lang\"\n");

        // 4. Add ___main wrapper (receives envp from _start)
        // Reader mode includes std/core.lang which provides init_environ
        append_str(source_buf, &source_len, "func ___main(argc i64, argv **u8, envp **u8) i64 { init_environ(envp); return main(argc, argv); }\n");

    } else {
        // Normal mode: Compile user program
        i = 0;
        while i < vec_len(input_files) {
            var arg *u8 = vec_get(input_files, i);
            var ext *u8 = get_extension(arg);

            if ext != nil && is_lang_extension(ext) == 0 {
                // Non-.lang file: read content and wrap in #ext{ content }
                var content *u8 = read_file(arg);
                if content == nil {
                    return 1;
                }

                append_str(source_buf, &source_len, "#");
                append_str(source_buf, &source_len, ext);
                append_str(source_buf, &source_len, "{");
                append_str(source_buf, &source_len, content);
                append_str(source_buf, &source_len, "}\n");
            } else {
                // .lang file: generate include statement
                append_str(source_buf, &source_len, "include \"");
                append_str(source_buf, &source_len, arg);
                append_str(source_buf, &source_len, "\"\n");
            }
            i = i + 1;
        }

        // Add ___main wrapper that calls user's main (skip in --emit-ast mode for composition)
        // Passes argc/argv - arg count check skipped for 'main' to support both signatures
        // Skip for LLVM backend - clang provides entry point
        // Note: envp is received but not used - programs needing getenv should call init_environ explicitly
        var langbe_check *u8 = getenv("LANGBE");
        var is_llvm i64 = 0;
        if langbe_check != nil && streq(langbe_check, "llvm") {
            is_llvm = 1;
        }
        if emit_ast_mode == 0 && is_llvm == 0 {
            // Simple ___main - no environment setup for basic programs
            // Programs needing getenv should include std/core.lang
            append_str(source_buf, &source_len, "func ___main(argc i64, argv **u8, envp **u8) i64 { return main(argc, argv); }\n");
        }
    }

    // Null-terminate
    *(source_buf + source_len) = 0;

    if output_file == nil {
        output_file = "a.s";
    }

    // --from-ast mode: parse S-expression AST directly
    if from_ast_mode != 0 {
        if vec_len(input_files) == 0 {
            eprintln("Error: no input file for --from-ast");
            return 1;
        }

        var ast_file *u8 = vec_get(input_files, 0);
        var ast_source *u8 = read_file(ast_file);
        if ast_source == nil {
            return 1;
        }

        var prog *u8 = parse_ast_from_string(ast_source);
        if prog == nil {
            eprintln("Error: failed to parse AST");
            return 1;
        }

        // Generate assembly
        generate(prog, output_file);

        print("Wrote ");
        println(output_file);
        return 0;
    }

    if source_len == 0 {
        eprintln("Error: no input files");
        return 1;
    }

    // Tokenize
    parser_tokenize(source_buf);

    // Check for lexer errors
    i = 0;
    while i < parser_token_count() {
        var tok *u8 = get_token(i);
        if tok_type(tok) == TOKEN_ERROR {
            eprint("Error: ");
            eprintln(tok_lexeme(tok));
            return 1;
        }
        i = i + 1;
    }

    // Parse
    var prog *u8 = parse_program();

    if parse_error_count > 0 {
        return 1;
    }

    // Output based on mode
    if emit_expanded_ast_mode != 0 {
        // Emit FULLY EXPANDED AST (all includes resolved inline)
        expand_included_map = map_new();
        expand_collected_decls = vec_new(1024);

        // Process all declarations, expanding includes
        var decls *u8 = program_decls(prog);
        var decl_count i64 = program_decl_count(prog);
        i = 0;
        while i < decl_count {
            expand_collect_decl(get_decl(decls, i));
            i = i + 1;
        }

        // Build expanded program
        var expanded_prog *u8 = build_expanded_program();

        // Emit as S-expressions
        var ast_str *u8 = ast_emit_program(expanded_prog);

        // Write to output file
        var fd i64 = file_open(output_file, 577);
        if fd < 0 {
            eprint("Error: cannot open output file: ");
            eprintln(output_file);
            return 1;
        }
        file_write(fd, ast_str, strlen(ast_str));
        file_close(fd);

        print("Wrote expanded AST to ");
        println(output_file);
    } else if emit_ast_mode != 0 {
        // Emit AST as S-expressions (includes stay as directives)
        var ast_str *u8 = ast_emit_program(prog);

        // Write to output file
        // O_WRONLY=1 | O_CREAT=64 | O_TRUNC=512 = 577
        var fd i64 = file_open(output_file, 577);
        if fd < 0 {
            eprint("Error: cannot open output file: ");
            eprintln(output_file);
            return 1;
        }
        file_write(fd, ast_str, strlen(ast_str));
        file_close(fd);

        print("Wrote AST to ");
        println(output_file);
    } else {
        // Check LANGBE environment variable for backend selection
        var langbe *u8 = getenv("LANGBE");
        if langbe != nil && streq(langbe, "llvm") {
            // LLVM IR backend
            generate_llvm(prog, output_file);
        } else {
            // Default: x86 assembly backend
            generate(prog, output_file);
        }

        print("Wrote ");
        println(output_file);
    }

    return 0;
}
