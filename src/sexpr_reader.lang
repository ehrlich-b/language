// src/sexpr_reader.lang - Parse S-expression AST format
//
// Hand-written recursive descent parser for S-expressions.
// NO dependency on parser_reader or lang_reader - this breaks the
// kernel -> lang_reader chain that was causing bootstrap issues.
//
// Example input:
//   (program
//     (func main () (type-base i64)
//       (block (return (number 42)))))

include "std/tok.lang"

// ============================================================
// PNode structure for parse tree
// ============================================================

struct PNode {
    kind i64;
    text *u8;
    children *u8;  // Vec of *PNode
}

// PNODE kinds (matching what #parser{} would have generated)
var PNODE_NUMBER i64 = 1;
var PNODE_SYMBOL i64 = 2;
var PNODE_STRING i64 = 3;
var PNODE_LIST i64 = 4;
var PNODE_OPERATOR i64 = 5;

// ============================================================
// AST Version
// ============================================================
// v1 (default): string values include quotes ("hello" = 7 chars)
// v2: string values are raw content (hello = 5 chars)
// sexpr_reader adds quotes for v2 to match codegen expectations

var ast_version i64 = 1;

func ast_get_version() i64 {
    return ast_version;
}

func ast_set_version(v i64) void {
    ast_version = v;
}

// Strip surrounding quotes from a string (for v1 string handling)
// Input: "hello" (7 chars with quotes)
// Output: hello (5 chars raw)
func sexpr_strip_quotes(s *u8) *u8 {
    var len i64 = strlen(s);
    if len < 2 { return s; }
    if *s != '"' { return s; }  // not quoted
    // Allocate new string without quotes
    var buf *u8 = alloc(len - 1);  // -2 for quotes, +1 for null
    var i i64 = 0;
    while i < len - 2 {
        *(buf + i) = *(s + 1 + i);
        i = i + 1;
    }
    *(buf + len - 2) = 0;
    return buf;
}

// Simple string to int conversion for version parsing
func sexpr_atoi(s *u8) i64 {
    var result i64 = 0;
    while *s != 0 {
        var c u8 = *s;
        if c >= '0' && c <= '9' {
            result = result * 10 + (c - '0');
        }
        s = s + 1;
    }
    return result;
}

// ============================================================
// PNode constructors
// ============================================================

func pnode_new(kind i64) *PNode {
    var n *PNode = alloc(24);
    n.kind = kind;
    n.text = nil;
    n.children = nil;
    return n;
}

func pnode_atom(kind i64, text *u8) *PNode {
    var n *PNode = pnode_new(kind);
    n.text = text;
    return n;
}

func pnode_list(children *u8) *PNode {
    var n *PNode = pnode_new(PNODE_LIST);
    n.children = children;
    return n;
}

// ============================================================
// Hand-written S-expression parser
// Grammar: sexpr = number | symbol | string | operator | list
//          list = '(' sexpr* ')'
// ============================================================

func is_operator_token(kind i64) bool {
    return kind == TOK_PLUS || kind == TOK_MINUS || kind == TOK_STAR ||
           kind == TOK_SLASH || kind == TOK_PERCENT || kind == TOK_AMP ||
           kind == TOK_PIPE || kind == TOK_CARET || kind == TOK_LT ||
           kind == TOK_GT || kind == TOK_BANG || kind == TOK_EQ;
}

func parse_sexpr(t *Tokenizer) *PNode {
    var kind i64 = tok_kind(t);

    // number
    if kind == TOK_NUMBER {
        var text *u8 = tok_text(t);
        tok_next(t);
        return pnode_atom(PNODE_NUMBER, text);
    }

    // symbol (identifier)
    if kind == TOK_IDENT {
        var text *u8 = tok_text(t);
        tok_next(t);
        return pnode_atom(PNODE_SYMBOL, text);
    }

    // string
    if kind == TOK_STRING {
        var text *u8 = tok_text(t);
        tok_next(t);
        return pnode_atom(PNODE_STRING, text);
    }

    // operator
    if is_operator_token(kind) {
        var text *u8 = tok_text(t);
        tok_next(t);
        return pnode_atom(PNODE_OPERATOR, text);
    }

    // list: '(' sexpr* ')'
    if kind == TOK_LPAREN {
        tok_next(t);  // consume '('

        var children *u8 = vec_new(8);

        // Parse sexpr*
        while tok_kind(t) != TOK_RPAREN && tok_kind(t) != TOK_EOF {
            var child *PNode = parse_sexpr(t);
            if child == nil {
                return nil;
            }
            vec_push(children, child);
        }

        if tok_kind(t) != TOK_RPAREN {
            eprintln("Error: expected ')' in S-expression");
            return nil;
        }
        tok_next(t);  // consume ')'

        return pnode_list(children);
    }

    // Unknown token
    eprint("Error: unexpected token in S-expression: ");
    eprintln(tok_text(t));
    return nil;
}

// ============================================================
// S-expr list helpers
// ============================================================

// Get element at index from list children
// (Our simple parser puts children directly in node.children)
func sexpr_get(node *PNode, i i64) *PNode {
    return vec_get(node.children, i);
}

// Get count of elements in list
func sexpr_len(node *PNode) i64 {
    return vec_len(node.children);
}

// Identity function - the old #parser{} wrapped list contents,
// but our simple parser puts children directly in node.children.
// This exists for compatibility with code that expects the old structure.
func sexpr_inner(node *PNode) *PNode {
    return node;
}

// Check if node is a symbol with given name
func sexpr_is(node *PNode, name *u8) bool {
    if node == nil { return false; }
    if node.kind != PNODE_SYMBOL { return false; }
    return streq(node.text, name);
}

// Get first element as symbol name (for dispatch)
func sexpr_head(node *PNode) *u8 {
    if node == nil { return nil; }
    if node.kind != PNODE_LIST { return nil; }
    if sexpr_len(node) == 0 { return nil; }
    var first *PNode = sexpr_get(node, 0);
    if first.kind != PNODE_SYMBOL { return nil; }
    return first.text;
}

// ============================================================
// String helpers
// ============================================================

// Duplicate a string
func sexpr_strdup(s *u8) *u8 {
    var len i64 = strlen(s);
    var buf *u8 = alloc(len + 1);
    var i i64 = 0;
    while i < len {
        *(buf + i) = *(s + i);
        i = i + 1;
    }
    *(buf + len) = 0;
    return buf;
}

// Parse a string literal, handling escape sequences
// Input: "hello\nworld" (with quotes)
// Output: hello<newline>world (without quotes, escapes processed)
func sexpr_parse_string(quoted *u8) *u8 {
    var len i64 = strlen(quoted);
    var buf *u8 = alloc(len + 1);
    var out i64 = 0;
    var i i64 = 1;  // Skip opening quote

    while i < len - 1 {  // Stop before closing quote
        var c u8 = *(quoted + i);
        if c == '\\' && i + 1 < len - 1 {
            var next u8 = *(quoted + i + 1);
            if next == 'n' { *(buf + out) = '\n'; out = out + 1; i = i + 2; }
            else if next == 't' { *(buf + out) = '\t'; out = out + 1; i = i + 2; }
            else if next == 'r' { *(buf + out) = '\r'; out = out + 1; i = i + 2; }
            else if next == '0' { *(buf + out) = 0; out = out + 1; i = i + 2; }
            else if next == '"' { *(buf + out) = '"'; out = out + 1; i = i + 2; }
            else if next == '\\' { *(buf + out) = '\\'; out = out + 1; i = i + 2; }
            else { *(buf + out) = c; out = out + 1; i = i + 1; }
        } else {
            *(buf + out) = c;
            out = out + 1;
            i = i + 1;
        }
    }
    *(buf + out) = 0;
    return buf;
}

// ============================================================
// Token type mapping (for operators in binop/unop)
// ============================================================

func sexpr_op_to_token(op *u8) i64 {
    if streq(op, "+") { return TOKEN_PLUS; }
    if streq(op, "-") { return TOKEN_MINUS; }
    if streq(op, "*") { return TOKEN_STAR; }
    if streq(op, "/") { return TOKEN_SLASH; }
    if streq(op, "%") { return TOKEN_PERCENT; }
    if streq(op, "&") { return TOKEN_AMP; }
    if streq(op, "|") { return TOKEN_PIPE; }
    if streq(op, "^") { return TOKEN_CARET; }
    if streq(op, "<<") { return TOKEN_LTLT; }
    if streq(op, ">>") { return TOKEN_GTGT; }
    if streq(op, "==") { return TOKEN_EQEQ; }
    if streq(op, "!=") { return TOKEN_BANGEQ; }
    if streq(op, "<") { return TOKEN_LT; }
    if streq(op, ">") { return TOKEN_GT; }
    if streq(op, "<=") { return TOKEN_LTEQ; }
    if streq(op, ">=") { return TOKEN_GTEQ; }
    if streq(op, "&&") { return TOKEN_AMPAMP; }
    if streq(op, "||") { return TOKEN_PIPEPIPE; }
    if streq(op, "!") { return TOKEN_BANG; }
    if streq(op, "=") { return TOKEN_EQ; }
    // Unknown operator
    return 0;
}

// ============================================================
// Type conversion
// ============================================================

func sexpr_to_type(node *PNode) *u8 {
    if node == nil { return nil; }

    // Check for "nil" symbol
    if node.kind == PNODE_SYMBOL && streq(node.text, "nil") {
        return nil;
    }

    if node.kind != PNODE_LIST { return nil; }

    var head *u8 = sexpr_head(node);
    if head == nil { return nil; }

    // (type-base name)
    if streq(head, "type_base") {
        var t *u8 = base_type_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        base_type_set_name(t, sexpr_strdup(name_node.text));
        base_type_set_name_len(t, strlen(name_node.text));
        return t;
    }

    // (type-ptr elem)
    if streq(head, "type_ptr") {
        var t *u8 = ptr_type_alloc();
        ptr_type_set_elem(t, sexpr_to_type(sexpr_get(node, 1)));
        return t;
    }

    // (type-func (param-types...) ret)
    if streq(head, "type_func") {
        var t *u8 = func_type_alloc();
        var params_node *PNode = sexpr_get(node, 1);
        var params_inner *PNode = sexpr_inner(params_node);
        var count i64 = vec_len(params_inner.children);
        var params *u8 = vec_new(count);
        var i i64 = 0;
        while i < count {
            var pt *u8 = sexpr_to_type(vec_get(params_inner.children, i));
            vec_push(params, pt);
            i = i + 1;
        }
        func_type_set_params(t, params);
        func_type_set_param_count(t, count);
        func_type_set_ret(t, sexpr_to_type(sexpr_get(node, 2)));
        return t;
    }

    // (type-closure (param-types...) ret)
    if streq(head, "type_closure") {
        var t *u8 = closure_type_alloc();
        var params_node *PNode = sexpr_get(node, 1);
        var params_inner *PNode = sexpr_inner(params_node);
        var count i64 = vec_len(params_inner.children);
        var params *u8 = vec_new(count);
        var i i64 = 0;
        while i < count {
            var pt *u8 = sexpr_to_type(vec_get(params_inner.children, i));
            vec_push(params, pt);
            i = i + 1;
        }
        closure_type_set_params(t, params);
        closure_type_set_param_count(t, count);
        closure_type_set_ret(t, sexpr_to_type(sexpr_get(node, 2)));
        return t;
    }

    // (type_array size elem)
    if streq(head, "type_array") {
        var t *u8 = array_type_alloc();
        var size_node *PNode = sexpr_get(node, 1);
        var size i64 = sexpr_atoi(size_node.text);
        array_type_set_size(t, size);
        array_type_set_elem(t, sexpr_to_type(sexpr_get(node, 2)));
        return t;
    }

    return nil;
}

// ============================================================
// Pattern conversion
// ============================================================

func sexpr_to_pattern(node *PNode) *u8 {
    if node == nil { return nil; }
    if node.kind != PNODE_LIST { return nil; }

    var head *u8 = sexpr_head(node);
    if head == nil { return nil; }

    // (pattern-wildcard)
    if streq(head, "pattern_wildcard") {
        return pattern_wildcard_alloc();
    }

    // (pattern-variant enum variant binding?)
    if streq(head, "pattern_variant") {
        var p *u8 = pattern_variant_alloc();
        var enum_node *PNode = sexpr_get(node, 1);
        var var_node *PNode = sexpr_get(node, 2);
        pattern_variant_set_enum_name(p, sexpr_strdup(enum_node.text));
        pattern_variant_set_enum_len(p, strlen(enum_node.text));
        pattern_variant_set_name(p, sexpr_strdup(var_node.text));
        pattern_variant_set_name_len(p, strlen(var_node.text));
        if sexpr_len(node) > 3 {
            var bind_node *PNode = sexpr_get(node, 3);
            pattern_variant_set_binding(p, sexpr_strdup(bind_node.text));
            pattern_variant_set_binding_len(p, strlen(bind_node.text));
        } else {
            pattern_variant_set_binding(p, nil);
            pattern_variant_set_binding_len(p, 0);
        }
        return p;
    }

    return nil;
}

// ============================================================
// Param conversion
// ============================================================

func sexpr_to_param(node *PNode, params_buf *u8, index i64) void {
    // (param name type)
    var name_node *PNode = sexpr_get(node, 1);
    var type_node *PNode = sexpr_get(node, 2);

    var p *u8 = params_buf + (index * 24);
    param_set_name(p, sexpr_strdup(name_node.text));
    param_set_name_len(p, strlen(name_node.text));
    param_set_type(p, sexpr_to_type(type_node));
}

// ============================================================
// Main node conversion
// ============================================================

func sexpr_to_node(node *PNode) *u8 {
    if node == nil { return nil; }

    // Check for "nil" symbol
    if node.kind == PNODE_SYMBOL && streq(node.text, "nil") {
        return nil;
    }

    if node.kind != PNODE_LIST {
        eprintln("Error: expected S-expression list");
        return nil;
    }

    var head *u8 = sexpr_head(node);
    if head == nil {
        eprintln("Error: empty S-expression");
        return nil;
    }

    // ============================================================
    // Declarations
    // ============================================================

    // (func name (params...) ret-type body)
    // (extern_func name (params...) ret-type body) - same but sets is_extern
    var is_extern_func i64 = 0;
    if streq(head, "extern_func") {
        is_extern_func = 1;
    }
    if streq(head, "func") || is_extern_func {
        var n *u8 = func_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        func_decl_set_name(n, sexpr_strdup(name_node.text));
        func_decl_set_name_len(n, strlen(name_node.text));

        // Parse params
        var params_list *PNode = sexpr_get(node, 2);
        var params_inner *PNode = sexpr_inner(params_list);
        var param_count i64 = vec_len(params_inner.children);
        var params *u8 = alloc(param_count * 24);
        var i i64 = 0;
        while i < param_count {
            sexpr_to_param(vec_get(params_inner.children, i), params, i);
            i = i + 1;
        }
        func_decl_set_params(n, params);
        func_decl_set_param_count(n, param_count);

        func_decl_set_ret_type(n, sexpr_to_type(sexpr_get(node, 3)));
        func_decl_set_body(n, sexpr_to_node(sexpr_get(node, 4)));
        func_decl_set_is_extern(n, is_extern_func);
        return n;
    }

    // (var name type init?)
    // (extern_var name type) - same but sets is_extern
    var is_extern_var i64 = 0;
    if streq(head, "extern_var") {
        is_extern_var = 1;
    }
    if streq(head, "var") || is_extern_var {
        var n *u8 = var_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        var_decl_set_name(n, sexpr_strdup(name_node.text));
        var_decl_set_name_len(n, strlen(name_node.text));
        var_decl_set_type(n, sexpr_to_type(sexpr_get(node, 2)));
        if sexpr_len(node) > 3 {
            var_decl_set_init(n, sexpr_to_node(sexpr_get(node, 3)));
        } else {
            var_decl_set_init(n, nil);
        }
        var_decl_set_is_extern(n, is_extern_var);
        return n;
    }

    // (struct name (fields...))
    if streq(head, "struct") {
        var n *u8 = struct_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        struct_decl_set_name(n, sexpr_strdup(name_node.text));
        struct_decl_set_name_len(n, strlen(name_node.text));

        var fields_list *PNode = sexpr_get(node, 2);
        var fields_inner *PNode = sexpr_inner(fields_list);
        var field_count i64 = vec_len(fields_inner.children);
        var fields *u8 = alloc(field_count * 24);
        var i i64 = 0;
        while i < field_count {
            // (field-decl name type)
            var f_node *PNode = vec_get(fields_inner.children, i);
            var f *u8 = fields + (i * 24);
            var fname *PNode = sexpr_get(f_node, 1);
            struct_field_set_name(f, sexpr_strdup(fname.text));
            struct_field_set_name_len(f, strlen(fname.text));
            struct_field_set_type(f, sexpr_to_type(sexpr_get(f_node, 2)));
            i = i + 1;
        }
        struct_decl_set_fields(n, fields);
        struct_decl_set_field_count(n, field_count);
        return n;
    }

    // (macro name (params...) body)
    if streq(head, "macro") {
        var n *u8 = macro_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        macro_decl_set_name(n, sexpr_strdup(name_node.text));
        macro_decl_set_name_len(n, strlen(name_node.text));

        // Parse params (just identifiers, no types)
        var params_list *PNode = sexpr_get(node, 2);
        var params_inner *PNode = sexpr_inner(params_list);
        var param_count i64 = vec_len(params_inner.children);
        var params *u8 = alloc(param_count * 24);
        var i i64 = 0;
        while i < param_count {
            var pname *PNode = vec_get(params_inner.children, i);
            var p *u8 = params + (i * 24);
            param_set_name(p, sexpr_strdup(pname.text));
            param_set_name_len(p, strlen(pname.text));
            param_set_type(p, nil);
            i = i + 1;
        }
        macro_decl_set_params(n, params);
        macro_decl_set_param_count(n, param_count);
        macro_decl_set_body(n, sexpr_to_node(sexpr_get(node, 3)));
        return n;
    }

    // (enum name (variants...))
    if streq(head, "enum") {
        var n *u8 = enum_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        enum_decl_set_name(n, sexpr_strdup(name_node.text));
        enum_decl_set_name_len(n, strlen(name_node.text));

        var variants_list *PNode = sexpr_get(node, 2);
        var variants_inner *PNode = sexpr_inner(variants_list);
        var variant_count i64 = vec_len(variants_inner.children);
        var variants *u8 = alloc(variant_count * 32);
        var i i64 = 0;
        while i < variant_count {
            // (variant-decl name type?)
            var v_node *PNode = vec_get(variants_inner.children, i);
            var v *u8 = variants + (i * 32);
            var vname *PNode = sexpr_get(v_node, 1);
            enum_variant_set_name(v, sexpr_strdup(vname.text));
            enum_variant_set_name_len(v, strlen(vname.text));
            if sexpr_len(v_node) > 2 {
                enum_variant_set_type(v, sexpr_to_type(sexpr_get(v_node, 2)));
            } else {
                enum_variant_set_type(v, nil);
            }
            enum_variant_set_tag(v, i);
            i = i + 1;
        }
        enum_decl_set_variants(n, variants);
        enum_decl_set_variant_count(n, variant_count);
        return n;
    }

    // (effect name (param-types...) ret-type)
    if streq(head, "effect") {
        var n *u8 = effect_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        effect_decl_set_name(n, sexpr_strdup(name_node.text));
        effect_decl_set_name_len(n, strlen(name_node.text));

        var params_list *PNode = sexpr_get(node, 2);
        var params_inner *PNode = sexpr_inner(params_list);
        var param_count i64 = vec_len(params_inner.children);
        var params *u8 = alloc(param_count * 8);
        var i i64 = 0;
        while i < param_count {
            var pt *u8 = sexpr_to_type(vec_get(params_inner.children, i));
            var pp **u8 = params + (i * 8);
            *pp = pt;
            i = i + 1;
        }
        effect_decl_set_param_types(n, params);
        effect_decl_set_param_type_count(n, param_count);
        effect_decl_set_return_type(n, sexpr_to_type(sexpr_get(node, 3)));
        return n;
    }

    // (include "path")
    if streq(head, "include") {
        var n *u8 = include_decl_alloc();
        var path_node *PNode = sexpr_get(node, 1);
        var path *u8 = sexpr_parse_string(path_node.text);
        include_decl_set_path(n, path);
        include_decl_set_path_len(n, strlen(path));
        return n;
    }

    // (reader name param body)
    if streq(head, "reader") {
        var n *u8 = reader_decl_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        reader_decl_set_name(n, sexpr_strdup(name_node.text));
        reader_decl_set_name_len(n, strlen(name_node.text));
        var param_node *PNode = sexpr_get(node, 2);
        reader_decl_set_param_name(n, sexpr_strdup(param_node.text));
        reader_decl_set_param_len(n, strlen(param_node.text));
        reader_decl_set_body(n, sexpr_to_node(sexpr_get(node, 3)));
        return n;
    }

    // ============================================================
    // Statements
    // ============================================================

    // (block stmts...)
    if streq(head, "block") {
        var n *u8 = block_stmt_alloc();
        var count i64 = sexpr_len(node) - 1;  // Exclude "block" symbol
        var stmts *u8 = alloc(count * 8);
        var i i64 = 0;
        while i < count {
            var stmt *u8 = sexpr_to_node(sexpr_get(node, i + 1));
            var sp **u8 = stmts + (i * 8);
            *sp = stmt;
            i = i + 1;
        }
        block_stmt_set_stmts(n, stmts);
        block_stmt_set_count(n, count);
        return n;
    }

    // (block-expr stmts... tail)
    if streq(head, "block_expr") {
        var n *u8 = block_expr_alloc();
        var total i64 = sexpr_len(node) - 1;
        var stmt_count i64 = total - 1;
        var stmts *u8 = alloc(stmt_count * 8);
        var i i64 = 0;
        while i < stmt_count {
            var stmt *u8 = sexpr_to_node(sexpr_get(node, i + 1));
            var sp **u8 = stmts + (i * 8);
            *sp = stmt;
            i = i + 1;
        }
        block_expr_set_stmts(n, stmts);
        block_expr_set_count(n, stmt_count);
        block_expr_set_tail(n, sexpr_to_node(sexpr_get(node, total)));
        return n;
    }

    // (array_literal e1 e2 ...)
    if streq(head, "array_literal") {
        var n *u8 = array_literal_alloc();
        var count i64 = sexpr_len(node) - 1;
        var elems *u8 = alloc(count * 8);
        var i i64 = 0;
        while i < count {
            var elem *u8 = sexpr_to_node(sexpr_get(node, i + 1));
            var ep **u8 = elems + (i * 8);
            *ep = elem;
            i = i + 1;
        }
        array_literal_set_elems(n, elems);
        array_literal_set_count(n, count);
        return n;
    }

    // (if cond then else?)
    if streq(head, "if") {
        var n *u8 = if_stmt_alloc();
        if_stmt_set_cond(n, sexpr_to_node(sexpr_get(node, 1)));
        if_stmt_set_then(n, sexpr_to_node(sexpr_get(node, 2)));
        if sexpr_len(node) > 3 {
            if_stmt_set_else(n, sexpr_to_node(sexpr_get(node, 3)));
        } else {
            if_stmt_set_else(n, nil);
        }
        return n;
    }

    // (while cond body label?)
    if streq(head, "while") {
        var n *u8 = while_stmt_alloc();
        while_stmt_set_cond(n, sexpr_to_node(sexpr_get(node, 1)));
        while_stmt_set_body(n, sexpr_to_node(sexpr_get(node, 2)));
        if sexpr_len(node) > 3 {
            var label_node *PNode = sexpr_get(node, 3);
            while_stmt_set_label(n, sexpr_strdup(label_node.text));
            while_stmt_set_label_len(n, strlen(label_node.text));
        } else {
            while_stmt_set_label(n, nil);
            while_stmt_set_label_len(n, 0);
        }
        return n;
    }

    // (return expr?)
    if streq(head, "return") {
        var n *u8 = return_stmt_alloc();
        if sexpr_len(node) > 1 {
            return_stmt_set_value(n, sexpr_to_node(sexpr_get(node, 1)));
        } else {
            return_stmt_set_value(n, nil);
        }
        return n;
    }

    // (break label?)
    if streq(head, "break") {
        var n *u8 = break_stmt_alloc();
        if sexpr_len(node) > 1 {
            var label_node *PNode = sexpr_get(node, 1);
            break_stmt_set_label(n, sexpr_strdup(label_node.text));
            break_stmt_set_label_len(n, strlen(label_node.text));
        } else {
            break_stmt_set_label(n, nil);
            break_stmt_set_label_len(n, 0);
        }
        return n;
    }

    // (continue label?)
    if streq(head, "continue") {
        var n *u8 = continue_stmt_alloc();
        if sexpr_len(node) > 1 {
            var label_node *PNode = sexpr_get(node, 1);
            continue_stmt_set_label(n, sexpr_strdup(label_node.text));
            continue_stmt_set_label_len(n, strlen(label_node.text));
        } else {
            continue_stmt_set_label(n, nil);
            continue_stmt_set_label_len(n, 0);
        }
        return n;
    }

    // (expr-stmt expr)
    if streq(head, "expr_stmt") {
        var n *u8 = expr_stmt_alloc();
        expr_stmt_set_expr(n, sexpr_to_node(sexpr_get(node, 1)));
        return n;
    }

    // (assign target value)
    if streq(head, "assign") {
        var n *u8 = assign_stmt_alloc();
        assign_stmt_set_target(n, sexpr_to_node(sexpr_get(node, 1)));
        assign_stmt_set_value(n, sexpr_to_node(sexpr_get(node, 2)));
        return n;
    }

    // ============================================================
    // Expressions
    // ============================================================

    // (ident name)
    if streq(head, "ident") {
        var n *u8 = ident_expr_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        ident_expr_set_name(n, sexpr_strdup(name_node.text));
        ident_expr_set_name_len(n, strlen(name_node.text));
        return n;
    }

    // (number value)
    if streq(head, "number") {
        var n *u8 = number_expr_alloc();
        var val_node *PNode = sexpr_get(node, 1);
        number_expr_set_value(n, sexpr_strdup(val_node.text));
        number_expr_set_value_len(n, strlen(val_node.text));
        return n;
    }

    // (string "value")
    // Strings are stored RAW (no surrounding quotes) in the AST.
    // sexpr_parse_string processes escape sequences: "\"\n" -> [34, 10]
    if streq(head, "string") {
        var n *u8 = string_expr_alloc();
        var val_node *PNode = sexpr_get(node, 1);
        var val *u8 = sexpr_parse_string(val_node.text);
        string_expr_set_value(n, val);
        string_expr_set_value_len(n, strlen(val));
        return n;
    }

    // (bool true/false)
    if streq(head, "bool") {
        var n *u8 = bool_expr_alloc();
        var val_node *PNode = sexpr_get(node, 1);
        if streq(val_node.text, "true") {
            bool_expr_set_value(n, 1);
        } else {
            bool_expr_set_value(n, 0);
        }
        return n;
    }

    // (nil)
    if streq(head, "nil") {
        return nil_expr_alloc();
    }

    // (binop op left right)
    if streq(head, "binop") {
        var n *u8 = binary_expr_alloc();
        var op_node *PNode = sexpr_get(node, 1);
        binary_expr_set_op(n, sexpr_op_to_token(op_node.text));
        binary_expr_set_left(n, sexpr_to_node(sexpr_get(node, 2)));
        binary_expr_set_right(n, sexpr_to_node(sexpr_get(node, 3)));
        return n;
    }

    // (unop op expr)
    if streq(head, "unop") {
        var n *u8 = unary_expr_alloc();
        var op_node *PNode = sexpr_get(node, 1);
        unary_expr_set_op(n, sexpr_op_to_token(op_node.text));
        unary_expr_set_expr(n, sexpr_to_node(sexpr_get(node, 2)));
        return n;
    }

    // (call func args...)
    if streq(head, "call") {
        var n *u8 = call_expr_alloc();
        call_expr_set_func(n, sexpr_to_node(sexpr_get(node, 1)));
        var arg_count i64 = sexpr_len(node) - 2;
        var args *u8 = alloc(arg_count * 8);
        var i i64 = 0;
        while i < arg_count {
            var arg *u8 = sexpr_to_node(sexpr_get(node, i + 2));
            var ap **u8 = args + (i * 8);
            *ap = arg;
            i = i + 1;
        }
        call_expr_set_args(n, args);
        call_expr_set_arg_count(n, arg_count);
        return n;
    }

    // (field expr name)
    if streq(head, "field") {
        var n *u8 = alloc(32);
        node_set_kind(n, NODE_FIELD_EXPR);
        var pe **u8 = n + 8;
        *pe = sexpr_to_node(sexpr_get(node, 1));
        var name_node *PNode = sexpr_get(node, 2);
        var pf **u8 = n + 16;
        *pf = sexpr_strdup(name_node.text);
        var pfl *i64 = n + 24;
        *pfl = strlen(name_node.text);
        return n;
    }

    // (index expr index)
    if streq(head, "index") {
        var n *u8 = alloc(24);
        node_set_kind(n, NODE_INDEX_EXPR);
        var pe **u8 = n + 8;
        *pe = sexpr_to_node(sexpr_get(node, 1));
        var pi **u8 = n + 16;
        *pi = sexpr_to_node(sexpr_get(node, 2));
        return n;
    }

    // (quote expr) - macro quote expression
    if streq(head, "quote") {
        var n *u8 = quote_expr_alloc();
        quote_expr_set_expr(n, sexpr_to_node(sexpr_get(node, 1)));
        return n;
    }

    // (unquote name) - macro unquote (splice AST)
    if streq(head, "unquote") {
        var n *u8 = unquote_expr_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        unquote_expr_set_name(n, sexpr_strdup(name_node.text));
        unquote_expr_set_name_len(n, strlen(name_node.text));
        return n;
    }

    // (unquote_string name) - macro unquote as string literal
    if streq(head, "unquote_string") {
        var n *u8 = unquote_string_expr_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        unquote_string_expr_set_name(n, sexpr_strdup(name_node.text));
        unquote_string_expr_set_name_len(n, strlen(name_node.text));
        return n;
    }

    // (let name type? init body)
    if streq(head, "let") {
        var n *u8 = let_expr_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        let_expr_set_name(n, sexpr_strdup(name_node.text));
        let_expr_set_name_len(n, strlen(name_node.text));

        // Check if we have type or not
        var next *PNode = sexpr_get(node, 2);
        if next.kind == PNODE_LIST && streq(sexpr_head(next), "type_base") {
            let_expr_set_type(n, sexpr_to_type(next));
            let_expr_set_init(n, sexpr_to_node(sexpr_get(node, 3)));
            let_expr_set_body(n, sexpr_to_node(sexpr_get(node, 4)));
        } else if next.kind == PNODE_LIST && streq(sexpr_head(next), "type_ptr") {
            let_expr_set_type(n, sexpr_to_type(next));
            let_expr_set_init(n, sexpr_to_node(sexpr_get(node, 3)));
            let_expr_set_body(n, sexpr_to_node(sexpr_get(node, 4)));
        } else {
            let_expr_set_type(n, nil);
            let_expr_set_init(n, sexpr_to_node(next));
            let_expr_set_body(n, sexpr_to_node(sexpr_get(node, 3)));
        }
        return n;
    }

    // (lambda (params...) ret-type body)
    if streq(head, "lambda") {
        var n *u8 = lambda_expr_alloc();

        var params_list *PNode = sexpr_get(node, 1);
        var params_inner *PNode = sexpr_inner(params_list);
        var param_count i64 = vec_len(params_inner.children);
        var params *u8 = alloc(param_count * 24);
        var i i64 = 0;
        while i < param_count {
            sexpr_to_param(vec_get(params_inner.children, i), params, i);
            i = i + 1;
        }
        lambda_expr_set_params(n, params);
        lambda_expr_set_param_count(n, param_count);
        lambda_expr_set_ret_type(n, sexpr_to_type(sexpr_get(node, 2)));
        lambda_expr_set_body(n, sexpr_to_node(sexpr_get(node, 3)));
        return n;
    }

    // (match scrutinee (cases...))
    if streq(head, "match") {
        var n *u8 = match_expr_alloc();
        match_expr_set_scrutinee(n, sexpr_to_node(sexpr_get(node, 1)));

        var cases_list *PNode = sexpr_get(node, 2);
        var cases_inner *PNode = sexpr_inner(cases_list);
        var arm_count i64 = vec_len(cases_inner.children);
        var arms *u8 = alloc(arm_count * 16);
        var i i64 = 0;
        while i < arm_count {
            // (case pattern body)
            var case_node *PNode = vec_get(cases_inner.children, i);
            var arm *u8 = arms + (i * 16);
            match_arm_set_pattern(arm, sexpr_to_pattern(sexpr_get(case_node, 1)));
            match_arm_set_body(arm, sexpr_to_node(sexpr_get(case_node, 2)));
            i = i + 1;
        }
        match_expr_set_arms(n, arms);
        match_expr_set_arm_count(n, arm_count);
        return n;
    }

    // (perform effect-name args...)
    if streq(head, "perform") {
        var n *u8 = perform_expr_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        perform_expr_set_name(n, sexpr_strdup(name_node.text));
        perform_expr_set_name_len(n, strlen(name_node.text));

        var arg_count i64 = sexpr_len(node) - 2;
        var args *u8 = alloc(arg_count * 8);
        var i i64 = 0;
        while i < arg_count {
            var arg *u8 = sexpr_to_node(sexpr_get(node, i + 2));
            var ap **u8 = args + (i * 8);
            *ap = arg;
            i = i + 1;
        }
        perform_expr_set_args(n, args);
        perform_expr_set_arg_count(n, arg_count);
        return n;
    }

    // (handle body (return-handler ...) (effect-handler ...)...)
    if streq(head, "handle") {
        var n *u8 = handle_expr_alloc();
        handle_expr_set_body(n, sexpr_to_node(sexpr_get(node, 1)));

        // (return-handler binding body)
        var ret_handler *PNode = sexpr_get(node, 2);
        var ret_bind *PNode = sexpr_get(ret_handler, 1);
        handle_expr_set_ret_bind(n, sexpr_strdup(ret_bind.text));
        handle_expr_set_ret_bind_len(n, strlen(ret_bind.text));
        handle_expr_set_ret_body(n, sexpr_to_node(sexpr_get(ret_handler, 2)));

        // Effect handlers
        var effect_count i64 = sexpr_len(node) - 3;
        var cases *u8 = alloc(effect_count * 56);
        var i i64 = 0;
        while i < effect_count {
            // (effect-handler name binding k body)
            var eh *PNode = sexpr_get(node, i + 3);
            var c *u8 = cases + (i * 56);

            var ename *PNode = sexpr_get(eh, 1);
            var cp **u8 = c;
            *cp = sexpr_strdup(ename.text);
            var cl *i64 = c + 8;
            *cl = strlen(ename.text);

            var ebind *PNode = sexpr_get(eh, 2);
            var bp **u8 = c + 16;
            if streq(ebind.text, "_") {
                *bp = nil;
                var bl *i64 = c + 24;
                *bl = 0;
            } else {
                *bp = sexpr_strdup(ebind.text);
                var bl *i64 = c + 24;
                *bl = strlen(ebind.text);
            }

            var ek *PNode = sexpr_get(eh, 3);
            var kp **u8 = c + 32;
            if streq(ek.text, "_") {
                *kp = nil;
                var kl *i64 = c + 40;
                *kl = 0;
            } else {
                *kp = sexpr_strdup(ek.text);
                var kl *i64 = c + 40;
                *kl = strlen(ek.text);
            }

            var bodyp **u8 = c + 48;
            *bodyp = sexpr_to_node(sexpr_get(eh, 4));

            i = i + 1;
        }
        handle_expr_set_cases(n, cases);
        handle_expr_set_case_count(n, effect_count);
        return n;
    }

    // (resume k value?)
    if streq(head, "resume") {
        var n *u8 = resume_expr_alloc();
        resume_expr_set_k(n, sexpr_to_node(sexpr_get(node, 1)));
        if sexpr_len(node) > 2 {
            resume_expr_set_value(n, sexpr_to_node(sexpr_get(node, 2)));
        } else {
            resume_expr_set_value(n, nil);
        }
        return n;
    }

    // (reader_expr name "content")
    if streq(head, "reader_expr") {
        var n *u8 = reader_expr_alloc();
        var name_node *PNode = sexpr_get(node, 1);
        reader_expr_set_name(n, sexpr_strdup(name_node.text));
        reader_expr_set_name_len(n, strlen(name_node.text));
        var content_node *PNode = sexpr_get(node, 2);
        var content *u8 = sexpr_parse_string(content_node.text);
        reader_expr_set_content(n, content);
        reader_expr_set_content_len(n, strlen(content));
        return n;
    }

    // Unknown node type
    eprint("Error: unknown S-expression node type: ");
    eprintln(head);
    return nil;
}

// ============================================================
// Program conversion
// ============================================================

func sexpr_to_program(node *PNode) *u8 {
    // (program decl1 decl2 ...)
    // Optional: (program (ast-version 2) decl1 decl2 ...)

    // Reset version to default for each program
    ast_version = 1;

    if node.kind != PNODE_LIST {
        eprintln("Error: expected (program ...)");
        return nil;
    }

    var head *u8 = sexpr_head(node);
    if head == nil || streq(head, "program") == false {
        eprintln("Error: expected (program ...)");
        return nil;
    }

    var total_children i64 = sexpr_len(node) - 1;
    var start_index i64 = 1;  // Skip "program" head

    // Check for (ast-version N) as first child
    if total_children > 0 {
        var first_child *PNode = sexpr_get(node, 1);
        if first_child.kind == PNODE_LIST {
            var first_head *u8 = sexpr_head(first_child);
            if first_head != nil && streq(first_head, "ast-version") {
                var ver_node *PNode = sexpr_get(first_child, 1);
                if ver_node != nil && ver_node.kind == PNODE_NUMBER {
                    ast_version = sexpr_atoi(ver_node.text);
                }
                start_index = 2;  // Skip version declaration
                total_children = total_children - 1;
            }
        }
    }

    var decl_count i64 = total_children;
    var decls *u8 = alloc(decl_count * 8);

    var i i64 = 0;
    while i < decl_count {
        var decl *u8 = sexpr_to_node(sexpr_get(node, start_index + i));
        var dp **u8 = decls + (i * 8);
        *dp = decl;
        i = i + 1;
    }

    // Build program node: [decls:8][count:8]
    var prog *u8 = alloc(16);
    var pd **u8 = prog;
    *pd = decls;
    var pc *i64 = prog + 8;
    *pc = decl_count;

    return prog;
}

// ============================================================
// Main entry point
// ============================================================

func parse_ast_from_string(source *u8) *u8 {
    var t *Tokenizer = tok_new(source);
    var node *PNode = parse_sexpr(t);

    if node == nil {
        eprintln("Error: failed to parse S-expression");
        return nil;
    }

    return sexpr_to_program(node);
}

// Parse a single expression from S-expr AST text (for inline readers)
func parse_ast_expression_from_string(source *u8) *u8 {
    var t *Tokenizer = tok_new(source);
    var node *PNode = parse_sexpr(t);

    if node == nil {
        eprintln("Error: failed to parse S-expression");
        return nil;
    }

    return sexpr_to_node(node);
}
