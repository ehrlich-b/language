// src/standalone.lang - Template for standalone compilers
//
// Usage: Generate source that:
//   1. Includes reader source (so the reader gets compiled to /tmp)
//   2. Defines reader_transform() glue function
//   3. Includes this file
//
// This template provides the compiler infrastructure and main().

include "src/lexer.lang"
include "src/parser.lang"
include "src/codegen.lang"
include "src/sexpr_reader.lang"

// Helper to append string to buffer
func standalone_append(buf *u8, len *i64, s *u8) void {
    while *s != 0 {
        *(buf + *len) = *s;
        *len = *len + 1;
        s = s + 1;
    }
}

func standalone_read_file(path *u8) *u8 {
    var fd i64 = file_open(path, 0);
    if fd < 0 {
        eprint("Error: cannot open file: ");
        eprintln(path);
        return nil;
    }
    var buf *u8 = alloc(1048576);
    var n i64 = file_read(fd, buf, 1048576);
    file_close(fd);
    if n < 0 {
        eprintln("Error: cannot read file");
        return nil;
    }
    *(buf + n) = 0;
    return buf;
}

func standalone_get_arg(argv **u8, i i64) *u8 {
    var base *u8 = argv;
    var p **u8 = base + (i * 8);  // Manual byte offset on *u8
    return *p;
}

// reader_transform is defined by the generated glue code
// It calls the reader function directly (e.g., lisp(content))

func main(argc i64, argv **u8) i64 {
    if argc < 2 {
        eprintln("Usage: <compiler> <file>... [-o output.s]");
        return 1;
    }

    var output_file *u8 = nil;
    var ast_buf *u8 = alloc(4194304);
    var ast_len i64 = 0;

    // Start with "(program " wrapper - we'll collect all declarations
    standalone_append(ast_buf, &ast_len, "(program\n");

    var i i64 = 1;
    while i < argc {
        var arg *u8 = standalone_get_arg(argv, i);

        // Check for -o flag
        if *arg == '-' && *(arg + 1) == 'o' {
            i = i + 1;
            if i < argc {
                output_file = standalone_get_arg(argv, i);
            }
        } else {
            // Input file - read and transform through reader
            var content *u8 = standalone_read_file(arg);
            if content == nil {
                return 1;
            }

            // Transform through reader â†’ S-expression AST
            var ast *u8 = reader_transform(content);
            if ast == nil {
                return 1;
            }

            // Reader outputs "(program ...)" - skip the outer wrapper
            // Find opening paren and skip "program" keyword
            var p *u8 = ast;
            while *p == 32 || *p == 10 || *p == 13 || *p == 9 { p = p + 1; }
            if *p == 40 {  // '('
                p = p + 1;
                while *p == 32 || *p == 10 { p = p + 1; }
                // Skip "program" if present
                if *p == 112 && *(p+1) == 114 && *(p+2) == 111 && *(p+3) == 103 &&
                   *(p+4) == 114 && *(p+5) == 97 && *(p+6) == 109 {  // "program"
                    p = p + 7;
                    // Now p points to the declarations - find the closing paren
                    // and copy everything before it
                    var end *u8 = p;
                    var depth i64 = 1;
                    while *end != 0 && depth > 0 {
                        if *end == 40 { depth = depth + 1; }
                        if *end == 41 { depth = depth - 1; }
                        end = end + 1;
                    }
                    // end is one past the closing paren of (program ...)
                    // back up to exclude that closing paren
                    if depth == 0 { end = end - 1; }
                    // Copy everything from p to end (the declarations)
                    while p < end {
                        *(ast_buf + ast_len) = *p;
                        ast_len = ast_len + 1;
                        p = p + 1;
                    }
                } else {
                    // Not a program, just append as-is
                    standalone_append(ast_buf, &ast_len, ast);
                }
            } else {
                standalone_append(ast_buf, &ast_len, ast);
            }
            *(ast_buf + ast_len) = 10;  // newline
            ast_len = ast_len + 1;
        }
        i = i + 1;
    }

    // Add ___main wrapper as AST
    standalone_append(ast_buf, &ast_len, "(func ___main ((param argc (type_base i64)) (param argv (type_ptr (type_ptr (type_base u8))))) (type_base i64) (block (return (call (ident main) (ident argc) (ident argv)))))\n");

    // Close the program wrapper
    standalone_append(ast_buf, &ast_len, ")\n");
    *(ast_buf + ast_len) = 0;

    if ast_len <= 12 {  // "(program\n)\n" is 11 chars
        eprintln("Error: no input files");
        return 1;
    }

    if output_file == nil {
        output_file = "a.s";
    }

    // Parse AST from reader output (S-expression format)
    var prog *u8 = parse_ast_from_string(ast_buf);
    if prog == nil {
        eprintln("Error: failed to parse reader output");
        return 1;
    }

    generate(prog, output_file);

    print("Wrote ");
    println(output_file);

    return 0;
}
