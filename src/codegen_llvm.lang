// src/codegen_llvm.lang - LLVM IR backend
//
// Emits LLVM IR text format (.ll files) instead of x86 assembly.
// This enables:
// - Cross-platform compilation via clang
// - Access to LLVM optimizations
// - Future: stack maps for precise GC, custom calling conventions
//
// LLVM IR is just different text output. The kernel walks AST and emits strings.
// Pattern:
//   x86:  movq $42, %rax; ret
//   LLVM: ret i64 42

// ============================================================
// Output buffer
// ============================================================

var llvm_out_fd i64 = 0;
var llvm_buf *u8 = nil;
var llvm_len i64 = 0;
var llvm_buf_size i64 = 0;

func llvm_init_output(output_file *u8) void {
    llvm_buf_size = 1024 * 1024;  // 1MB buffer
    llvm_buf = alloc(llvm_buf_size);
    llvm_len = 0;

    // O_WRONLY=1 | O_CREAT=64 | O_TRUNC=512 = 577
    llvm_out_fd = file_open(output_file, 577);
    if llvm_out_fd < 0 {
        eprint("Error: cannot open output file: ");
        eprintln(output_file);
        exit(1);
    }
}

func llvm_emit_char(c u8) void {
    if llvm_len >= llvm_buf_size {
        eprintln("Error: LLVM output buffer overflow");
        exit(1);
    }
    *(llvm_buf + llvm_len) = c;
    llvm_len = llvm_len + 1;
}

func llvm_emit_str(s *u8) void {
    var i i64 = 0;
    while *(s + i) != 0 {
        llvm_emit_char(*(s + i));
        i = i + 1;
    }
}

func llvm_emit_line(s *u8) void {
    llvm_emit_str(s);
    llvm_emit_char(10);  // newline
}

func llvm_emit_int(n i64) void {
    if n < 0 {
        llvm_emit_char(45);  // '-'
        n = 0 - n;
    }
    if n == 0 {
        llvm_emit_char(48);  // '0'
        return;
    }
    // Find highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }
    // Emit digits
    while divisor > 0 {
        var digit i64 = n / divisor;
        llvm_emit_char(48 + digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

func llvm_emit_n(s *u8, len i64) void {
    var i i64 = 0;
    while i < len {
        llvm_emit_char(*(s + i));
        i = i + 1;
    }
}

func llvm_flush() void {
    file_write(llvm_out_fd, llvm_buf, llvm_len);
    file_close(llvm_out_fd);
}

// ============================================================
// Type emission
// ============================================================

func llvm_emit_type(type_node *u8) void {
    if type_node == nil {
        llvm_emit_str("void");
        return;
    }

    var k i64 = type_kind(type_node);

    if k == TYPE_BASE {
        var name *u8 = base_type_name(type_node);
        var len i64 = base_type_name_len(type_node);

        // Map lang types to LLVM types
        if len == 3 && memcmp(name, "i64", 3) {
            llvm_emit_str("i64");
        } else if len == 3 && memcmp(name, "i32", 3) {
            llvm_emit_str("i32");
        } else if len == 3 && memcmp(name, "i16", 3) {
            llvm_emit_str("i16");
        } else if len == 2 && memcmp(name, "i8", 2) {
            llvm_emit_str("i8");
        } else if len == 3 && memcmp(name, "u64", 3) {
            llvm_emit_str("i64");  // LLVM doesn't distinguish signed/unsigned in types
        } else if len == 3 && memcmp(name, "u32", 3) {
            llvm_emit_str("i32");
        } else if len == 3 && memcmp(name, "u16", 3) {
            llvm_emit_str("i16");
        } else if len == 2 && memcmp(name, "u8", 2) {
            llvm_emit_str("i8");
        } else if len == 4 && memcmp(name, "bool", 4) {
            llvm_emit_str("i1");
        } else if len == 4 && memcmp(name, "void", 4) {
            llvm_emit_str("void");
        } else {
            llvm_emit_str("i64");  // Default
        }
        return;
    }

    if k == TYPE_PTR {
        llvm_emit_str("i8*");  // Use typed pointers for older LLVM
        return;
    }

    // Default fallback
    llvm_emit_str("i64");
}

func llvm_is_pointer_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    return type_kind(t) == TYPE_PTR;
}

// ============================================================
// Expression emission
// ============================================================

// Label counter for generating unique labels
var llvm_label_counter i64 = 0;

func llvm_next_label() i64 {
    var n i64 = llvm_label_counter;
    llvm_label_counter = llvm_label_counter + 1;
    return n;
}

// Temp register counter
var llvm_temp_counter i64 = 0;

func llvm_next_temp() i64 {
    var n i64 = llvm_temp_counter;
    llvm_temp_counter = llvm_temp_counter + 1;
    return n;
}

// Track local variables (need load) vs parameters (use directly)
var llvm_locals *u8 = nil;

// Track if last emitted instruction was a terminator (ret, br)
var llvm_emitted_terminator i64 = 0;

// Current function's return type (for correct return statement emission)
var llvm_current_ret_type *u8 = nil;

func llvm_reset_locals() void {
    llvm_locals = map_new();
}

func llvm_add_local(name *u8, len i64) void {
    var key *u8 = str_dup_n(name, len);
    map_set(llvm_locals, key, 1);
}

func llvm_is_local(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    return map_has(llvm_locals, key);
}

// Let binding stack for name remapping (SSA unique names)
// Each entry: [orig_name:8][orig_len:8][unique_name:8][unique_len:8] = 32 bytes
var llvm_let_bindings *u8 = nil;
var llvm_let_depth i64 = 0;

func llvm_init_let_bindings() void {
    llvm_let_bindings = alloc(256 * 32);  // Max 256 nested let bindings
    llvm_let_depth = 0;
}

func llvm_push_let_binding(name *u8, name_len i64, unique *u8, unique_len i64) void {
    var entry *u8 = llvm_let_bindings + (llvm_let_depth * 32);
    var p_name **u8 = entry;
    *p_name = name;
    var p_name_len *i64 = entry + 8;
    *p_name_len = name_len;
    var p_unique **u8 = entry + 16;
    *p_unique = unique;
    var p_unique_len *i64 = entry + 24;
    *p_unique_len = unique_len;
    llvm_let_depth = llvm_let_depth + 1;
}

func llvm_pop_let_binding() void {
    if llvm_let_depth > 0 {
        llvm_let_depth = llvm_let_depth - 1;
    }
}

// Look up let binding and return unique name if found
// Returns nil if not found
func llvm_find_let_binding(name *u8, name_len i64) *u8 {
    var i i64 = llvm_let_depth - 1;
    while i >= 0 {
        var entry *u8 = llvm_let_bindings + (i * 32);
        var p_name **u8 = entry;
        var p_name_len *i64 = entry + 8;
        if *p_name_len == name_len {
            var j i64 = 0;
            var same i64 = 1;
            while j < name_len {
                if *(*p_name + j) != *(name + j) {
                    same = 0;
                }
                j = j + 1;
            }
            if same != 0 {
                return entry;  // Return entry pointer (unique name at offset 16)
            }
        }
        i = i - 1;
    }
    return nil;
}

func llvm_let_unique_name(entry *u8) *u8 {
    var p **u8 = entry + 16;
    return *p;
}

func llvm_let_unique_len(entry *u8) i64 {
    var p *i64 = entry + 24;
    return *p;
}

// Global variable table
var llvm_globals *u8 = nil;

func llvm_init_globals() void {
    llvm_globals = map_new();
}

func llvm_add_global(name *u8, len i64) void {
    var key *u8 = str_dup_n(name, len);
    map_set(llvm_globals, key, 1);
}

func llvm_is_global(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    return map_has(llvm_globals, key);
}

// String literal tracking
// Each entry: [ptr:8][len:8] = 16 bytes
var llvm_strings *u8 = nil;
var llvm_string_count i64 = 0;

func llvm_init_strings() void {
    llvm_strings = alloc(3000 * 16);  // Max 3000 strings
    llvm_string_count = 0;
}

func llvm_add_string(ptr *u8, len i64) i64 {
    // Check if this string already exists (dedup)
    var i i64 = 0;
    while i < llvm_string_count {
        var entry *u8 = llvm_strings + (i * 16);
        var existing_ptr **u8 = entry;
        var existing_len *i64 = entry + 8;
        if *existing_len == len {
            var j i64 = 0;
            var same i64 = 1;
            while j < len {
                if *(*existing_ptr + j) != *(ptr + j) {
                    same = 0;
                }
                j = j + 1;
            }
            if same != 0 {
                return i;
            }
        }
        i = i + 1;
    }

    // Add new string
    var entry *u8 = llvm_strings + (llvm_string_count * 16);
    var entry_ptr **u8 = entry;
    var entry_len *i64 = entry + 8;
    *entry_ptr = ptr;
    *entry_len = len;
    var idx i64 = llvm_string_count;
    llvm_string_count = llvm_string_count + 1;
    return idx;
}

func llvm_emit_all_strings() void {
    var i i64 = 0;
    while i < llvm_string_count {
        var entry *u8 = llvm_strings + (i * 16);
        var ptr **u8 = entry;
        var len *i64 = entry + 8;

        // @.str0 = private constant [6 x i8] c"hello\00"
        llvm_emit_str("@.str");
        llvm_emit_int(i);
        llvm_emit_str(" = private constant [");
        llvm_emit_int(*len + 1);  // +1 for null terminator
        llvm_emit_str(" x i8] c\"");

        // Emit string with escape handling
        var j i64 = 0;
        while j < *len {
            var c u8 = *(*ptr + j);
            if c == 10 {  // newline
                llvm_emit_str("\\0A");
            } else if c == 13 {  // carriage return
                llvm_emit_str("\\0D");
            } else if c == 9 {  // tab
                llvm_emit_str("\\09");
            } else if c == 0 {  // null
                llvm_emit_str("\\00");
            } else if c == 34 {  // double quote
                llvm_emit_str("\\22");
            } else if c == 92 {  // backslash
                llvm_emit_str("\\5C");
            } else {
                llvm_emit_char(c);
            }
            j = j + 1;
        }
        llvm_emit_line("\\00\"");

        i = i + 1;
    }
    if llvm_string_count > 0 {
        llvm_emit_char(10);
    }
}

// Loop stack for break/continue
// Each entry: [name_ptr:8][name_len:8][break_label:8][continue_label:8] = 32 bytes
var llvm_loop_stack *u8 = nil;
var llvm_loop_depth i64 = 0;

func llvm_init_loop_stack() void {
    llvm_loop_stack = alloc(256 * 32);  // Max 256 nested loops
    llvm_loop_depth = 0;
}

func llvm_push_loop_labeled(name *u8, name_len i64, break_label i64, continue_label i64) void {
    var entry *u8 = llvm_loop_stack + (llvm_loop_depth * 32);
    var p_name **u8 = entry;
    *p_name = name;
    var p_len *i64 = entry + 8;
    *p_len = name_len;
    var p_break *i64 = entry + 16;
    *p_break = break_label;
    var p_cont *i64 = entry + 24;
    *p_cont = continue_label;
    llvm_loop_depth = llvm_loop_depth + 1;
}

func llvm_push_loop(break_label i64, continue_label i64) void {
    llvm_push_loop_labeled(nil, 0, break_label, continue_label);
}

func llvm_pop_loop() void {
    llvm_loop_depth = llvm_loop_depth - 1;
}

func llvm_find_loop(name *u8, name_len i64) *u8 {
    // Search from top of stack (innermost loop first)
    var i i64 = llvm_loop_depth - 1;
    while i >= 0 {
        var entry *u8 = llvm_loop_stack + (i * 32);
        var p_name **u8 = entry;
        var entry_name *u8 = *p_name;
        var p_len *i64 = entry + 8;
        var entry_len i64 = *p_len;

        if name == nil {
            // No label specified, return innermost loop
            return entry;
        }
        if entry_name != nil && entry_len == name_len {
            // Compare names
            var is_match i64 = 1;
            var j i64 = 0;
            while j < name_len {
                if *(name + j) != *(entry_name + j) {
                    is_match = 0;
                }
                j = j + 1;
            }
            if is_match == 1 {
                return entry;
            }
        }
        i = i - 1;
    }
    return nil;
}

func llvm_loop_break_label(entry *u8) i64 {
    var p *i64 = entry + 16;
    return *p;
}

func llvm_loop_continue_label(entry *u8) i64 {
    var p *i64 = entry + 24;
    return *p;
}

// Function table: track return types (1=void, 0=non-void)
var llvm_func_ret_types *u8 = nil;

func llvm_is_void_type(t *u8) i64 {
    if t == nil {
        return 1;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 4 {
            if memcmp(name, "void", 4) {
                return 1;
            }
        }
    }
    return 0;
}

func llvm_init_func_table() void {
    llvm_func_ret_types = map_new();
}

func llvm_register_func(name *u8, len i64, ret_type *u8) void {
    var key *u8 = str_dup_n(name, len);
    // Store: 0 = i64, 1 = void, 2 = pointer
    var ret_kind i64 = 0;
    if llvm_is_void_type(ret_type) {
        ret_kind = 1;
    } else if llvm_is_pointer_type(ret_type) {
        ret_kind = 2;
    }
    map_set(llvm_func_ret_types, key, ret_kind);
}

func llvm_func_returns_void(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 1;
    }
    return 0;  // Default: assume non-void
}

func llvm_func_returns_ptr(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 2;
    }
    return 0;  // Default: assume i64
}

// Set llvm_expr_result to "%t{n}"
// Use simple sprintf-like approach: build string from scratch
func llvm_set_result_temp(n i64) void {
    // Build "%tN" where N is the number
    var buf *u8 = llvm_expr_result;
    var idx i64 = 0;

    // Always starts with "%t"
    *(buf + idx) = 37;  // '%'
    idx = idx + 1;
    *(buf + idx) = 116; // 't'
    idx = idx + 1;

    if n == 0 {
        *(buf + idx) = 48;  // '0'
        idx = idx + 1;
        *(buf + idx) = 0;   // null
        return;
    }

    // For multi-digit numbers, we need to reverse
    // First, count digits and collect them
    var num_buf *u8 = alloc(32);
    var num_idx i64 = 0;
    var tmp i64 = n;
    while tmp > 0 {
        *(num_buf + num_idx) = 48 + (tmp % 10);
        tmp = tmp / 10;
        num_idx = num_idx + 1;
    }

    // Copy digits in reverse order
    var i i64 = num_idx - 1;
    while i >= 0 {
        *(buf + idx) = *(num_buf + i);
        idx = idx + 1;
        i = i - 1;
    }

    // Null terminator
    *(buf + idx) = 0;
}

// Set llvm_expr_result to an integer literal
func llvm_set_result_int(n i64) void {
    var buf *u8 = llvm_expr_result;
    itoa(n, buf);
}

// Emit expression, return the LLVM value reference (e.g., "%1" or "42")
// Result is written to a temp buffer that caller must use immediately
var llvm_expr_result *u8 = nil;

func llvm_emit_expr(expr *u8) void {
    if llvm_expr_result == nil {
        llvm_expr_result = alloc(256);
    }

    if expr == nil {
        // Return void/undef
        var p *u8 = llvm_expr_result;
        *p = 48;  // "0"
        *(p + 1) = 0;
        return;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        // Emit literal number - value is stored as a string
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        var i i64 = 0;
        while i < len {
            *(llvm_expr_result + i) = *(ptr + i);
            i = i + 1;
        }
        *(llvm_expr_result + len) = 0;
        return;
    }

    if k == NODE_BOOL_EXPR {
        // Emit boolean: true=1, false=0
        var val i64 = bool_expr_value(expr);
        if val != 0 {
            *(llvm_expr_result) = 49;  // '1'
        } else {
            *(llvm_expr_result) = 48;  // '0'
        }
        *(llvm_expr_result + 1) = 0;
        return;
    }

    if k == NODE_STRING_EXPR {
        // Add string to table and get pointer
        // Note: string value includes quotes, so skip first and last char
        var str_val *u8 = string_expr_value(expr) + 1;  // Skip opening quote
        var str_len i64 = string_expr_value_len(expr) - 2;  // Remove both quotes
        var idx i64 = llvm_add_string(str_val, str_len);

        // GEP to get pointer to first element
        // %t = ptrtoint i8* getelementptr inbounds ([N x i8], [N x i8]* @.strI, i64 0, i64 0) to i64
        var temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(temp);
        llvm_emit_str(" = ptrtoint i8* getelementptr inbounds ([");
        llvm_emit_int(str_len + 1);
        llvm_emit_str(" x i8], [");
        llvm_emit_int(str_len + 1);
        llvm_emit_str(" x i8]* @.str");
        llvm_emit_int(idx);
        llvm_emit_line(", i64 0, i64 0) to i64");
        llvm_set_result_temp(temp);
        return;
    }

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var len i64 = ident_expr_name_len(expr);

        // Check for let binding first (SSA unique names)
        var let_entry *u8 = llvm_find_let_binding(name, len);
        if let_entry != nil {
            // Let binding: use unique name
            var unique *u8 = llvm_let_unique_name(let_entry);
            var unique_len i64 = llvm_let_unique_len(let_entry);
            var temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = load i64, i64* %");
            llvm_emit_n(unique, unique_len);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        } else if llvm_is_local(name, len) {
            // Local variable: emit load
            var temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = load i64, i64* %");
            llvm_emit_n(name, len);
            llvm_emit_char(10);

            // Set result to temp - use llvm_set_result_temp for consistency
            llvm_set_result_temp(temp);
        } else if llvm_is_global(name, len) {
            // Global variable: emit load from @name
            var temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = load i64, i64* @");
            llvm_emit_n(name, len);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        } else {
            // Parameter: use directly
            *(llvm_expr_result) = 37;  // '%'
            var i i64 = 0;
            while i < len {
                *(llvm_expr_result + 1 + i) = *(name + i);
                i = i + 1;
            }
            *(llvm_expr_result + 1 + len) = 0;
        }
        return;
    }

    if k == NODE_CALL_EXPR {
        // Function call: emit call instruction and store result in temp
        var func_expr *u8 = call_expr_func(expr);

        // Get function name from the function expression (usually an ident)
        var func_name *u8 = nil;
        var func_name_len i64 = 0;
        if node_kind(func_expr) == NODE_IDENT_EXPR {
            func_name = ident_expr_name(func_expr);
            func_name_len = ident_expr_name_len(func_expr);
        }

        // First, emit all argument expressions and collect their values
        var args *u8 = call_expr_args(expr);
        var arg_count i64 = call_expr_arg_count(expr);
        var arg_vals **u8 = alloc(arg_count * 8);
        var i i64 = 0;
        while i < arg_count {
            var arg_ptr *u8 = args + (i * 8);
            var arg **u8 = arg_ptr;
            llvm_emit_expr(*arg);
            *(arg_vals + i) = str_dup(llvm_expr_result);
            i = i + 1;
        }

        // Check if function returns void or pointer
        var is_void i64 = llvm_func_returns_void(func_name, func_name_len);
        var is_ptr i64 = llvm_func_returns_ptr(func_name, func_name_len);

        // Check if this is syscall (variadic)
        var is_syscall i64 = 0;
        if func_name_len == 7 {
            if memcmp(func_name, "syscall", 7) {
                is_syscall = 1;
            }
        }

        // Now emit the call with pre-computed argument values
        var call_temp i64 = 0;
        if is_void {
            // Void function: no result assignment
            llvm_emit_str("    call void @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else if is_syscall {
            // Syscall is variadic: call i64 (i64, ...) @syscall(...)
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 (i64, ...) @syscall(");
        } else if is_ptr {
            // Pointer-returning function: call i8*
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i8* @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else {
            // Non-void function returning i64: assign result to temp
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        }

        i = 0;
        while i < arg_count {
            if i > 0 {
                llvm_emit_str(", ");
            }
            llvm_emit_str("i64 ");
            llvm_emit_str(*(arg_vals + i));
            i = i + 1;
        }
        llvm_emit_line(")");

        // For pointer-returning functions, convert to i64 for internal use
        if is_ptr {
            var conv_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(conv_temp);
            llvm_emit_str(" = ptrtoint i8* %t");
            llvm_emit_int(call_temp);
            llvm_emit_line(" to i64");
            call_temp = conv_temp;
        }

        // Set result to the temp (only meaningful for non-void)
        if is_void == 0 {
            llvm_set_result_temp(call_temp);
        }
        return;
    }

    if k == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);
        var left *u8 = binary_expr_left(expr);
        var right *u8 = binary_expr_right(expr);

        // Check for assignment first (op == 32 is TOKEN_EQ)
        if op == 32 {
            // Assignment: store to left (must be ident)
            if node_kind(left) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(left);
                var len i64 = ident_expr_name_len(left);

                // Emit right side
                llvm_emit_expr(right);
                var val *u8 = str_dup(llvm_expr_result);

                // Check if local or global
                if llvm_is_local(name, len) {
                    llvm_emit_str("    store i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", i64* %");
                    llvm_emit_n(name, len);
                    llvm_emit_char(10);
                } else if llvm_is_global(name, len) {
                    llvm_emit_str("    store i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", i64* @");
                    llvm_emit_n(name, len);
                    llvm_emit_char(10);
                }

                // Assignment result is the value
                var i i64 = 0;
                while *(val + i) != 0 {
                    *(llvm_expr_result + i) = *(val + i);
                    i = i + 1;
                }
                *(llvm_expr_result + i) = 0;
                return;
            }
        }

        // Handle short-circuit && with control flow
        if op == 39 {  // TOKEN_AMPAMP (&&)
            // a && b: if a is false, result is 0, don't evaluate b
            var right_label i64 = llvm_next_label();
            var end_label i64 = llvm_next_label();

            // Allocate result slot
            var result_slot i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result_slot);
            llvm_emit_line(" = alloca i64");
            llvm_emit_str("    store i64 0, i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            // Evaluate left
            llvm_emit_expr(left);
            var left_val *u8 = str_dup(llvm_expr_result);

            // Check left - if non-zero, evaluate right
            var l_bool i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(" = icmp ne i64 ");
            llvm_emit_str(left_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    br i1 %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(", label %L");
            llvm_emit_int(right_label);
            llvm_emit_str(", label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // Right label - evaluate right and store result
            llvm_emit_str("L");
            llvm_emit_int(right_label);
            llvm_emit_line(":");
            llvm_emit_expr(right);
            var right_val *u8 = str_dup(llvm_expr_result);
            var r_bool i64 = llvm_next_temp();
            var r_ext i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(r_bool);
            llvm_emit_str(" = icmp ne i64 ");
            llvm_emit_str(right_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(r_bool);
            llvm_emit_line(" to i64");
            llvm_emit_str("    store i64 %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(", i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);
            llvm_emit_str("    br label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // End label - load result
            llvm_emit_str("L");
            llvm_emit_int(end_label);
            llvm_emit_line(":");
            var result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            llvm_set_result_temp(result);
            return;
        }

        // Handle short-circuit || with control flow
        if op == 40 {  // TOKEN_PIPEPIPE (||)
            // a || b: if a is true, result is 1, don't evaluate b
            var right_label i64 = llvm_next_label();
            var end_label i64 = llvm_next_label();

            // Allocate result slot
            var result_slot i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result_slot);
            llvm_emit_line(" = alloca i64");
            llvm_emit_str("    store i64 1, i64* %t");  // Default to 1 (true)
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            // Evaluate left
            llvm_emit_expr(left);
            var left_val *u8 = str_dup(llvm_expr_result);

            // Check left - if zero, evaluate right
            var l_bool i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(" = icmp eq i64 ");  // eq 0 means false
            llvm_emit_str(left_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    br i1 %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(", label %L");
            llvm_emit_int(right_label);
            llvm_emit_str(", label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // Right label - evaluate right and store result
            llvm_emit_str("L");
            llvm_emit_int(right_label);
            llvm_emit_line(":");
            llvm_emit_expr(right);
            var right_val *u8 = str_dup(llvm_expr_result);
            var r_bool i64 = llvm_next_temp();
            var r_ext i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(r_bool);
            llvm_emit_str(" = icmp ne i64 ");
            llvm_emit_str(right_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(r_bool);
            llvm_emit_line(" to i64");
            llvm_emit_str("    store i64 %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(", i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);
            llvm_emit_str("    br label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // End label - load result
            llvm_emit_str("L");
            llvm_emit_int(end_label);
            llvm_emit_line(":");
            var result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            llvm_set_result_temp(result);
            return;
        }

        // For other operations, evaluate both operands
        llvm_emit_expr(left);
        var left_val *u8 = str_dup(llvm_expr_result);

        llvm_emit_expr(right);
        var right_val *u8 = str_dup(llvm_expr_result);

        // Pointer arithmetic scaling: ptr + n -> ptr + (n * sizeof(*ptr))
        if op == 25 || op == 26 {  // TOKEN_PLUS or TOKEN_MINUS
            var left_type *u8 = get_expr_type(left);
            if left_type != nil && type_kind(left_type) == TYPE_PTR {
                var elem_type *u8 = ptr_type_elem(left_type);
                var elem_size i64 = 8;  // default
                if elem_type != nil {
                    elem_size = get_type_size(elem_type);
                }
                if elem_size > 1 {
                    // Multiply right operand by element size
                    var scale_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(scale_temp);
                    llvm_emit_str(" = mul i64 ");
                    llvm_emit_str(right_val);
                    llvm_emit_str(", ");
                    llvm_emit_int(elem_size);
                    llvm_emit_char(10);
                    // Replace right_val with scaled value
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(scale_temp, buf + 2);
                    right_val = buf;
                }
            }
        }

        // Check if it's a comparison
        var is_cmp i64 = 0;
        if op >= 33 && op <= 38 { is_cmp = 1; }

        // Allocate temp for result
        var temp i64 = llvm_next_temp();

        if is_cmp == 1 {
            // Comparison: icmp returns i1, extend to i64
            var cmp_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_str(" = icmp ");

            if op == 33 { llvm_emit_str("eq"); }       // ==
            else if op == 34 { llvm_emit_str("ne"); }  // !=
            else if op == 35 { llvm_emit_str("slt"); } // <
            else if op == 36 { llvm_emit_str("sgt"); } // >
            else if op == 37 { llvm_emit_str("sle"); } // <=
            else if op == 38 { llvm_emit_str("sge"); } // >=

            llvm_emit_str(" i64 ");
            llvm_emit_str(left_val);
            llvm_emit_str(", ");
            llvm_emit_str(right_val);
            llvm_emit_char(10);

            // Extend i1 to i64
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_line(" to i64");
        } else {
            // Arithmetic
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = ");

            if op == 25 {  // TOKEN_PLUS
                llvm_emit_str("add");
            } else if op == 26 {  // TOKEN_MINUS
                llvm_emit_str("sub");
            } else if op == 27 {  // TOKEN_STAR
                llvm_emit_str("mul");
            } else if op == 28 {  // TOKEN_SLASH
                llvm_emit_str("sdiv");
            } else if op == 29 {  // TOKEN_PERCENT
                llvm_emit_str("srem");
            } else if op == 62 {  // TOKEN_LTLT (<<)
                llvm_emit_str("shl");
            } else if op == 63 {  // TOKEN_GTGT (>>)
                llvm_emit_str("ashr");
            } else if op == 30 {  // TOKEN_AMP (&)
                llvm_emit_str("and");
            } else if op == 60 {  // TOKEN_PIPE (|)
                llvm_emit_str("or");
            } else if op == 61 {  // TOKEN_CARET (^)
                llvm_emit_str("xor");
            } else {
                llvm_emit_str("add");  // Default
            }

            llvm_emit_str(" i64 ");
            llvm_emit_str(left_val);
            llvm_emit_str(", ");
            llvm_emit_str(right_val);
            llvm_emit_char(10);
        }

        // Set result
        llvm_set_result_temp(temp);
        return;
    }

    if k == NODE_GROUP_EXPR {
        // Parenthesized expression - just emit the inner expression
        llvm_emit_expr(group_expr_expr(expr));
        return;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        var inner *u8 = unary_expr_expr(expr);

        // Handle address-of specially - don't evaluate inner, just get its address
        if op == 30 {  // TOKEN_AMP (address-of &x)
            var temp i64 = llvm_next_temp();
            if node_kind(inner) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(inner);
                var len i64 = ident_expr_name_len(inner);

                // Check if inner is a struct type (needs different LLVM type)
                var inner_type *u8 = get_expr_type(inner);
                var struct_size i64 = 0;
                if inner_type != nil && type_kind(inner_type) == TYPE_BASE {
                    var type_name *u8 = base_type_name(inner_type);
                    var type_name_len i64 = base_type_name_len(inner_type);
                    var struct_decl *u8 = find_struct(type_name, type_name_len);
                    if struct_decl != nil {
                        struct_size = get_struct_size(struct_decl);
                    }
                }

                // ptrtoint converts pointer to integer
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                if struct_size > 8 {
                    llvm_emit_str(" = ptrtoint [");
                    llvm_emit_int(struct_size);
                    llvm_emit_str(" x i8]* %");
                } else {
                    llvm_emit_str(" = ptrtoint i64* %");
                }
                llvm_emit_n(name, len);
                llvm_emit_line(" to i64");
                llvm_set_result_temp(temp);
            }
            return;
        }

        // For other unary ops, evaluate inner first
        llvm_emit_expr(inner);
        var inner_val *u8 = str_dup(llvm_expr_result);

        var temp i64 = llvm_next_temp();

        if op == 26 {  // TOKEN_MINUS (negation)
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = sub i64 0, ");
            llvm_emit_str(inner_val);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        } else if op == 31 {  // TOKEN_BANG (logical not)
            // Compare to 0, result is 1 if equal (was false), 0 otherwise
            var cmp_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_str(" = icmp eq i64 ");
            llvm_emit_str(inner_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_line(" to i64");
            llvm_set_result_temp(temp);
        } else if op == 27 {  // TOKEN_STAR (dereference *p)
            // Get the type of what we're dereferencing
            var ptr_type *u8 = get_expr_type(inner);
            var elem_type *u8 = get_pointed_type(ptr_type);
            var size i64 = 8;
            if elem_type != nil {
                size = get_type_size(elem_type);
            }

            var ptr_temp i64 = llvm_next_temp();

            if size == 1 {
                // Load i8, then zext to i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i8*");
                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i8, i8* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = zext i8 %t");
                llvm_emit_int(load_temp);
                llvm_emit_line(" to i64");
            } else if size == 2 {
                // Load i16, then zext to i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i16*");
                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i16, i16* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = zext i16 %t");
                llvm_emit_int(load_temp);
                llvm_emit_line(" to i64");
            } else if size == 4 {
                // Load i32, then zext to i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i32*");
                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i32, i32* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = zext i32 %t");
                llvm_emit_int(load_temp);
                llvm_emit_line(" to i64");
            } else {
                // Default: load i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i64*");
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = load i64, i64* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
            }
            llvm_set_result_temp(temp);
        } else {
            // Unknown unary op, just pass through
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = add i64 0, ");
            llvm_emit_str(inner_val);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        }
        return;
    }

    if k == NODE_LET_EXPR {
        // Save local scope for restoration after body
        var saved_local_count i64 = cg_local_count;

        var name *u8 = let_expr_name(expr);
        var name_len i64 = let_expr_name_len(expr);
        var var_type *u8 = let_expr_type(expr);

        // Generate unique name for this let binding (SSA requires unique names)
        var let_id i64 = llvm_next_temp();
        var unique_name *u8 = alloc(64);
        var pos i64 = 0;
        var i i64 = 0;
        while i < name_len {
            *(unique_name + pos) = *(name + i);
            pos = pos + 1;
            i = i + 1;
        }
        *(unique_name + pos) = 46;  // '.'
        pos = pos + 1;
        // Append number
        var tmp *u8 = alloc(16);
        itoa(let_id, tmp);
        i = 0;
        while *(tmp + i) != 0 {
            *(unique_name + pos) = *(tmp + i);
            pos = pos + 1;
            i = i + 1;
        }
        *(unique_name + pos) = 0;
        var unique_len i64 = pos;

        // Register type info for get_expr_type
        add_local(name, name_len, 0, var_type);

        // Push let binding for name->unique_name mapping
        llvm_push_let_binding(name, name_len, unique_name, unique_len);

        // Allocate stack slot for let binding
        llvm_emit_str("    %");
        llvm_emit_n(unique_name, unique_len);
        llvm_emit_line(" = alloca i64");

        // Generate init expression
        llvm_emit_expr(let_expr_init(expr));
        var init_val *u8 = str_dup(llvm_expr_result);

        // Store init value
        llvm_emit_str("    store i64 ");
        llvm_emit_str(init_val);
        llvm_emit_str(", i64* %");
        llvm_emit_n(unique_name, unique_len);
        llvm_emit_char(10);

        // Generate body expression (result becomes the let expression's result)
        llvm_emit_expr(let_expr_body(expr));

        // Pop let binding and restore local scope
        llvm_pop_let_binding();
        cg_local_count = saved_local_count;
        return;
    }

    if k == NODE_FIELD_EXPR {
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Get type of base expression to find struct
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            llvm_set_result_int(0);
            return;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;
        var is_pointer i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
                is_pointer = 1;
            }
        }

        if struct_name == nil {
            llvm_set_result_int(0);
            return;
        }

        // Find struct and get field offset
        var struct_decl *u8 = find_struct(struct_name, struct_name_len);
        if struct_decl == nil {
            llvm_set_result_int(0);
            return;
        }

        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
        if field_offset < 0 {
            llvm_set_result_int(0);
            return;
        }

        // Get base address
        if is_pointer != 0 {
            // Pointer to struct - evaluate to get address
            llvm_emit_expr(base_expr);
            var ptr_val *u8 = str_dup(llvm_expr_result);

            // Add offset if needed
            var addr_val *u8 = ptr_val;
            if field_offset > 0 {
                var offset_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(offset_temp);
                llvm_emit_str(" = add i64 ");
                llvm_emit_str(ptr_val);
                llvm_emit_str(", ");
                llvm_emit_int(field_offset);
                llvm_emit_char(10);
                var buf *u8 = alloc(32);
                *buf = 37; *(buf+1) = 116;  // "%t"
                itoa(offset_temp, buf + 2);
                addr_val = buf;
            }

            // Load value from field
            var ptr_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(ptr_temp);
            llvm_emit_str(" = inttoptr i64 ");
            llvm_emit_str(addr_val);
            llvm_emit_line(" to i64*");

            var load_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(load_temp);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(ptr_temp);
            llvm_emit_char(10);

            llvm_set_result_temp(load_temp);
        } else {
            // Direct struct - base is the local variable, need its address
            if node_kind(base_expr) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(base_expr);
                var name_len i64 = ident_expr_name_len(base_expr);

                // Get address of struct and add offset
                var addr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(addr_temp);
                llvm_emit_str(" = ptrtoint [");
                // Get struct size
                var struct_size i64 = get_struct_size(struct_decl);
                llvm_emit_int(struct_size);
                llvm_emit_str(" x i8]* %");
                llvm_emit_n(name, name_len);
                llvm_emit_line(" to i64");

                // Add offset
                var addr_val *u8 = nil;
                if field_offset > 0 {
                    var offset_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(offset_temp);
                    llvm_emit_str(" = add i64 %t");
                    llvm_emit_int(addr_temp);
                    llvm_emit_str(", ");
                    llvm_emit_int(field_offset);
                    llvm_emit_char(10);
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(offset_temp, buf + 2);
                    addr_val = buf;
                } else {
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(addr_temp, buf + 2);
                    addr_val = buf;
                }

                // Load value from field
                var ptr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(addr_val);
                llvm_emit_line(" to i64*");

                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i64, i64* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);

                llvm_set_result_temp(load_temp);
            } else {
                // Nested field access - evaluate base, load field
                llvm_emit_expr(base_expr);
                var base_val *u8 = str_dup(llvm_expr_result);

                // Add offset
                var addr_val *u8 = base_val;
                if field_offset > 0 {
                    var offset_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(offset_temp);
                    llvm_emit_str(" = add i64 ");
                    llvm_emit_str(base_val);
                    llvm_emit_str(", ");
                    llvm_emit_int(field_offset);
                    llvm_emit_char(10);
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(offset_temp, buf + 2);
                    addr_val = buf;
                }

                // Load value from field
                var ptr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(addr_val);
                llvm_emit_line(" to i64*");

                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i64, i64* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);

                llvm_set_result_temp(load_temp);
            }
        }
        return;
    }

    // For now, unsupported expressions return 0
    var p *u8 = llvm_expr_result;
    *p = 48;  // "0"
    *(p + 1) = 0;
}

// ============================================================
// Statement emission
// ============================================================

func llvm_emit_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }

    var k i64 = node_kind(stmt);

    if k == NODE_RETURN_STMT {
        var ret_expr *u8 = return_stmt_value(stmt);
        if ret_expr == nil {
            llvm_emit_line("    ret void");
        } else {
            llvm_emit_expr(ret_expr);
            var val *u8 = str_dup(llvm_expr_result);

            // If returning pointer type but value is i64, convert with inttoptr
            if llvm_is_pointer_type(llvm_current_ret_type) {
                var conv_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(conv_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(val);
                llvm_emit_str(" to ");
                llvm_emit_type(llvm_current_ret_type);
                llvm_emit_char(10);

                llvm_emit_str("    ret ");
                llvm_emit_type(llvm_current_ret_type);
                llvm_emit_str(" %t");
                llvm_emit_int(conv_temp);
                llvm_emit_char(10);
            } else {
                llvm_emit_str("    ret ");
                llvm_emit_type(llvm_current_ret_type);
                llvm_emit_str(" ");
                llvm_emit_str(val);
                llvm_emit_char(10);
            }
        }
        llvm_emitted_terminator = 1;
        return;
    }

    if k == NODE_IF_STMT {
        var cond *u8 = if_stmt_cond(stmt);
        var then_block *u8 = if_stmt_then(stmt);
        var else_block *u8 = if_stmt_else(stmt);

        // Generate labels
        var then_label i64 = llvm_next_label();
        var else_label i64 = llvm_next_label();
        var end_label i64 = llvm_next_label();

        // Emit condition
        llvm_emit_expr(cond);
        var cond_val *u8 = str_dup(llvm_expr_result);

        // Convert to i1 (LLVM bool)
        var cmp_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(" = icmp ne i64 ");
        llvm_emit_str(cond_val);
        llvm_emit_line(", 0");

        // Branch
        llvm_emit_str("    br i1 %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(", label %L");
        llvm_emit_int(then_label);
        llvm_emit_str(", label %L");
        if else_block != nil {
            llvm_emit_int(else_label);
        } else {
            llvm_emit_int(end_label);
        }
        llvm_emit_char(10);

        // Then block
        llvm_emit_str("L");
        llvm_emit_int(then_label);
        llvm_emit_line(":");
        llvm_emitted_terminator = 0;
        llvm_emit_block(then_block);
        var then_ended i64 = llvm_emitted_terminator;
        if then_ended == 0 {
            llvm_emit_str("    br label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);
        }

        // Else block
        var else_ended i64 = 0;
        if else_block != nil {
            llvm_emit_str("L");
            llvm_emit_int(else_label);
            llvm_emit_line(":");
            llvm_emitted_terminator = 0;
            // Check if else_block is a block or a statement (for else-if)
            if node_kind(else_block) == NODE_BLOCK_STMT {
                llvm_emit_block(else_block);
            } else {
                // else-if: else_block is an IF_STMT
                llvm_emit_stmt(else_block);
            }
            else_ended = llvm_emitted_terminator;
            if else_ended == 0 {
                llvm_emit_str("    br label %L");
                llvm_emit_int(end_label);
                llvm_emit_char(10);
            }
        }

        // End label - only needed if at least one branch falls through
        if then_ended == 0 || else_ended == 0 || else_block == nil {
            llvm_emit_str("L");
            llvm_emit_int(end_label);
            llvm_emit_line(":");
            llvm_emitted_terminator = 0;
        } else {
            // Both branches terminate - this if terminates
            llvm_emitted_terminator = 1;
        }
        return;
    }

    if k == NODE_WHILE_STMT {
        var cond *u8 = while_stmt_cond(stmt);
        var body *u8 = while_stmt_body(stmt);
        var loop_name *u8 = while_stmt_label(stmt);
        var loop_name_len i64 = while_stmt_label_len(stmt);

        var cond_label i64 = llvm_next_label();
        var body_label i64 = llvm_next_label();
        var end_label i64 = llvm_next_label();

        // Jump to condition
        llvm_emit_str("    br label %L");
        llvm_emit_int(cond_label);
        llvm_emit_char(10);

        // Condition block
        llvm_emit_str("L");
        llvm_emit_int(cond_label);
        llvm_emit_line(":");
        llvm_emit_expr(cond);
        var cond_val *u8 = str_dup(llvm_expr_result);

        var cmp_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(" = icmp ne i64 ");
        llvm_emit_str(cond_val);
        llvm_emit_line(", 0");

        llvm_emit_str("    br i1 %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(", label %L");
        llvm_emit_int(body_label);
        llvm_emit_str(", label %L");
        llvm_emit_int(end_label);
        llvm_emit_char(10);

        // Body block
        llvm_emit_str("L");
        llvm_emit_int(body_label);
        llvm_emit_line(":");

        // Push loop for break/continue (with label if present)
        llvm_push_loop_labeled(loop_name, loop_name_len, end_label, cond_label);
        llvm_emit_block(body);
        llvm_pop_loop();

        // Only emit branch if no terminator (break/continue/return)
        if llvm_emitted_terminator == 0 {
            llvm_emit_str("    br label %L");
            llvm_emit_int(cond_label);
            llvm_emit_char(10);
        }
        llvm_emitted_terminator = 0;

        // End label
        llvm_emit_str("L");
        llvm_emit_int(end_label);
        llvm_emit_line(":");
        return;
    }

    if k == NODE_BREAK_STMT {
        var label *u8 = break_stmt_label(stmt);
        var label_len i64 = break_stmt_label_len(stmt);
        var entry *u8 = llvm_find_loop(label, label_len);
        if entry != nil {
            var target i64 = llvm_loop_break_label(entry);
            llvm_emit_str("    br label %L");
            llvm_emit_int(target);
            llvm_emit_char(10);
            llvm_emitted_terminator = 1;
        }
        return;
    }

    if k == NODE_CONTINUE_STMT {
        var label *u8 = continue_stmt_label(stmt);
        var label_len i64 = continue_stmt_label_len(stmt);
        var entry *u8 = llvm_find_loop(label, label_len);
        if entry != nil {
            var target i64 = llvm_loop_continue_label(entry);
            llvm_emit_str("    br label %L");
            llvm_emit_int(target);
            llvm_emit_char(10);
            llvm_emitted_terminator = 1;
        }
        return;
    }

    if k == NODE_VAR_DECL {
        var name *u8 = var_decl_name(stmt);
        var name_len i64 = var_decl_name_len(stmt);
        var init *u8 = var_decl_init(stmt);
        var var_type *u8 = var_decl_type(stmt);

        // Register as local (both LLVM and shared tracking for type info)
        llvm_add_local(name, name_len);
        add_local(name, name_len, 0, var_type);  // 0 offset, use var_type

        // Calculate allocation size - structs need more than 8 bytes
        var alloc_size i64 = 8;
        if var_type != nil {
            if type_kind(var_type) == TYPE_BASE {
                var type_name *u8 = base_type_name(var_type);
                var type_name_len i64 = base_type_name_len(var_type);
                var struct_decl *u8 = find_struct(type_name, type_name_len);
                if struct_decl != nil {
                    alloc_size = get_struct_size(struct_decl);
                }
            }
        }

        // Allocate stack slot with correct size
        llvm_emit_str("    %");
        llvm_emit_n(name, name_len);
        if alloc_size <= 8 {
            llvm_emit_line(" = alloca i64");
        } else {
            // Allocate as byte array for structs
            llvm_emit_str(" = alloca [");
            llvm_emit_int(alloc_size);
            llvm_emit_line(" x i8]");
        }

        // Initialize if there's an init expression
        if init != nil {
            llvm_emit_expr(init);
            llvm_emit_str("    store i64 ");
            llvm_emit_str(llvm_expr_result);
            llvm_emit_str(", i64* %");
            llvm_emit_n(name, name_len);
            llvm_emit_char(10);
        }
        return;
    }

    if k == NODE_EXPR_STMT {
        var expr *u8 = expr_stmt_expr(stmt);
        llvm_emit_expr(expr);
        return;
    }

    if k == NODE_ASSIGN_STMT {
        var target *u8 = assign_stmt_target(stmt);
        var value *u8 = assign_stmt_value(stmt);

        // Emit value
        llvm_emit_expr(value);
        var val *u8 = str_dup(llvm_expr_result);

        // Check for dereference assignment (*p = value)
        if node_kind(target) == NODE_UNARY_EXPR {
            var target_op i64 = unary_expr_op(target);
            if target_op == 27 {  // TOKEN_STAR (dereference)
                // Get the pointer value and type info
                var ptr_expr *u8 = unary_expr_expr(target);
                var ptr_type *u8 = get_expr_type(ptr_expr);
                var elem_type *u8 = get_pointed_type(ptr_type);
                var size i64 = 8;
                if elem_type != nil {
                    size = get_type_size(elem_type);
                }

                llvm_emit_expr(ptr_expr);
                var ptr_val *u8 = str_dup(llvm_expr_result);

                var ptr_temp i64 = llvm_next_temp();

                if size == 1 {
                    // Truncate value to i8 and store
                    var trunc_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(" = trunc i64 ");
                    llvm_emit_str(val);
                    llvm_emit_line(" to i8");
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i8*");
                    llvm_emit_str("    store i8 %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(", i8* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                } else if size == 2 {
                    // Truncate value to i16 and store
                    var trunc_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(" = trunc i64 ");
                    llvm_emit_str(val);
                    llvm_emit_line(" to i16");
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i16*");
                    llvm_emit_str("    store i16 %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(", i16* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                } else if size == 4 {
                    // Truncate value to i32 and store
                    var trunc_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(" = trunc i64 ");
                    llvm_emit_str(val);
                    llvm_emit_line(" to i32");
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i32*");
                    llvm_emit_str("    store i32 %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(", i32* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                } else {
                    // Default: store i64
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i64*");
                    llvm_emit_str("    store i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", i64* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                }
                return;
            }
        }

        // Check for field assignment (p.x = value)
        if node_kind(target) == NODE_FIELD_EXPR {
            var base_expr *u8 = field_expr_expr(target);
            var field_name *u8 = field_expr_field(target);
            var field_len i64 = field_expr_field_len(target);

            // Get type of base expression to find struct
            var base_type *u8 = get_expr_type(base_expr);
            if base_type != nil {
                var struct_name *u8 = nil;
                var struct_name_len i64 = 0;
                var is_pointer i64 = 0;

                // Check if base is a direct struct or pointer to struct
                if type_kind(base_type) == TYPE_BASE {
                    struct_name = base_type_name(base_type);
                    struct_name_len = base_type_name_len(base_type);
                } else if type_kind(base_type) == TYPE_PTR {
                    var pointed_type *u8 = ptr_type_elem(base_type);
                    if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                        struct_name = base_type_name(pointed_type);
                        struct_name_len = base_type_name_len(pointed_type);
                        is_pointer = 1;
                    }
                }

                if struct_name != nil {
                    var struct_decl *u8 = find_struct(struct_name, struct_name_len);
                    if struct_decl != nil {
                        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
                        if field_offset >= 0 {
                            // Get base address
                            if is_pointer != 0 {
                                // Pointer to struct - evaluate to get address
                                llvm_emit_expr(base_expr);
                                var ptr_val *u8 = str_dup(llvm_expr_result);

                                // Add offset if needed
                                var addr_val *u8 = ptr_val;
                                if field_offset > 0 {
                                    var offset_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(offset_temp);
                                    llvm_emit_str(" = add i64 ");
                                    llvm_emit_str(ptr_val);
                                    llvm_emit_str(", ");
                                    llvm_emit_int(field_offset);
                                    llvm_emit_char(10);
                                    var buf *u8 = alloc(32);
                                    *buf = 37; *(buf+1) = 116;  // "%t"
                                    itoa(offset_temp, buf + 2);
                                    addr_val = buf;
                                }

                                // Store value to field
                                var ptr_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(ptr_temp);
                                llvm_emit_str(" = inttoptr i64 ");
                                llvm_emit_str(addr_val);
                                llvm_emit_line(" to i64*");

                                llvm_emit_str("    store i64 ");
                                llvm_emit_str(val);
                                llvm_emit_str(", i64* %t");
                                llvm_emit_int(ptr_temp);
                                llvm_emit_char(10);
                            } else {
                                // Direct struct - base is the local variable
                                if node_kind(base_expr) == NODE_IDENT_EXPR {
                                    var name *u8 = ident_expr_name(base_expr);
                                    var name_len i64 = ident_expr_name_len(base_expr);

                                    // Get address of struct
                                    var addr_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(addr_temp);
                                    llvm_emit_str(" = ptrtoint [");
                                    var struct_size i64 = get_struct_size(struct_decl);
                                    llvm_emit_int(struct_size);
                                    llvm_emit_str(" x i8]* %");
                                    llvm_emit_n(name, name_len);
                                    llvm_emit_line(" to i64");

                                    // Add offset
                                    var addr_val *u8 = nil;
                                    if field_offset > 0 {
                                        var offset_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(offset_temp);
                                        llvm_emit_str(" = add i64 %t");
                                        llvm_emit_int(addr_temp);
                                        llvm_emit_str(", ");
                                        llvm_emit_int(field_offset);
                                        llvm_emit_char(10);
                                        var buf *u8 = alloc(32);
                                        *buf = 37; *(buf+1) = 116;  // "%t"
                                        itoa(offset_temp, buf + 2);
                                        addr_val = buf;
                                    } else {
                                        var buf *u8 = alloc(32);
                                        *buf = 37; *(buf+1) = 116;  // "%t"
                                        itoa(addr_temp, buf + 2);
                                        addr_val = buf;
                                    }

                                    // Store value to field
                                    var ptr_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(ptr_temp);
                                    llvm_emit_str(" = inttoptr i64 ");
                                    llvm_emit_str(addr_val);
                                    llvm_emit_line(" to i64*");

                                    llvm_emit_str("    store i64 ");
                                    llvm_emit_str(val);
                                    llvm_emit_str(", i64* %t");
                                    llvm_emit_int(ptr_temp);
                                    llvm_emit_char(10);
                                }
                            }
                            return;
                        }
                    }
                }
            }
        }

        // Store to target (identifier)
        if node_kind(target) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(target);
            var len i64 = ident_expr_name_len(target);
            llvm_emit_str("    store i64 ");
            llvm_emit_str(val);
            if llvm_is_local(name, len) {
                llvm_emit_str(", i64* %");
            } else if llvm_is_global(name, len) {
                llvm_emit_str(", i64* @");
            } else {
                // Assume local (parameter)
                llvm_emit_str(", i64* %");
            }
            llvm_emit_n(name, len);
            llvm_emit_char(10);
        }
        return;
    }

    // Unknown statement - skip
}

func llvm_emit_block(block *u8) void {
    if block == nil {
        return;
    }

    var stmts *u8 = block_stmt_stmts(block);
    var count i64 = block_stmt_count(block);

    var i i64 = 0;
    while i < count {
        var stmt_ptr *u8 = stmts + (i * 8);
        var stmt **u8 = stmt_ptr;
        llvm_emit_stmt(*stmt);
        // Stop emitting if we hit a terminator (return, break, continue)
        if llvm_emitted_terminator == 1 {
            return;
        }
        i = i + 1;
    }
}

// ============================================================
// Function emission
// ============================================================

func llvm_emit_func(func_node *u8) void {
    // Register this function for return type lookup
    var name *u8 = func_decl_name(func_node);
    var name_len i64 = func_decl_name_len(func_node);
    var ret_type *u8 = func_decl_ret_type(func_node);
    llvm_register_func(name, name_len, ret_type);

    // Skip extern functions - they're just declarations
    if func_decl_is_extern(func_node) {
        // Emit as external declaration (name, name_len already set above)
        llvm_emit_str("declare ");
        llvm_emit_type(ret_type);
        llvm_emit_str(" @");
        llvm_emit_n(name, name_len);
        llvm_emit_str("(");

        // Parameters
        var params *u8 = func_decl_params(func_node);
        var param_count i64 = func_decl_param_count(func_node);
        var i i64 = 0;
        while i < param_count {
            if i > 0 {
                llvm_emit_str(", ");
            }
            var p *u8 = params + (i * 24);
            llvm_emit_type(param_type(p));
            i = i + 1;
        }

        llvm_emit_line(")");
        llvm_emit_char(10);
        return;
    }

    // name, name_len, ret_type already set above

    // Reset counters for each function
    llvm_temp_counter = 0;
    llvm_label_counter = 0;
    llvm_reset_locals();
    cg_local_count = 0;  // Reset x86 backend's local tracking (for type info)
    llvm_current_ret_type = ret_type;

    // Function header
    llvm_emit_str("define ");
    llvm_emit_type(ret_type);
    llvm_emit_str(" @");
    llvm_emit_n(name, name_len);
    llvm_emit_str("(");

    // Parameters - use i64 for all types (simplification)
    // Name LLVM params with .arg suffix to allow shadowing
    var params *u8 = func_decl_params(func_node);
    var param_count i64 = func_decl_param_count(func_node);
    var i i64 = 0;
    while i < param_count {
        if i > 0 {
            llvm_emit_str(", ");
        }
        var p *u8 = params + (i * 24);
        llvm_emit_str("i64 %");
        llvm_emit_n(param_name(p), param_name_len(p));
        llvm_emit_str(".arg");
        i = i + 1;
    }

    llvm_emit_line(") {");

    // Entry block
    llvm_emit_line("L.entry:");

    // Shadow parameters with locals (so they can be assigned)
    i = 0;
    while i < param_count {
        var p *u8 = params + (i * 24);
        var pname *u8 = param_name(p);
        var pname_len i64 = param_name_len(p);
        var ptype *u8 = param_type(p);

        // Register as local (both LLVM and shared tracking for type info)
        llvm_add_local(pname, pname_len);
        add_local(pname, pname_len, 0, ptype);

        // Allocate local
        llvm_emit_str("    %");
        llvm_emit_n(pname, pname_len);
        llvm_emit_line(" = alloca i64");

        // Copy param.arg to local
        llvm_emit_str("    store i64 %");
        llvm_emit_n(pname, pname_len);
        llvm_emit_str(".arg, i64* %");
        llvm_emit_n(pname, pname_len);
        llvm_emit_char(10);

        i = i + 1;
    }

    // Reset terminator tracking
    llvm_emitted_terminator = 0;

    // Function body
    llvm_emit_block(func_decl_body(func_node));

    // For void functions, add implicit ret void if no explicit return
    var ret_type *u8 = func_decl_ret_type(func_node);
    if llvm_is_void_type(ret_type) {
        if llvm_emitted_terminator == 0 {
            llvm_emit_line("    ret void");
        }
    }

    llvm_emit_line("}");
    llvm_emit_char(10);
}

// ============================================================
// Program emission
// ============================================================

// Track which files have been included (to avoid duplicates)
var llvm_included_files *u8 = nil;

func llvm_emit_decl(decl *u8) void {
    if decl == nil {
        return;
    }

    var k i64 = node_kind(decl);

    if k == NODE_FUNC_DECL {
        llvm_emit_func(decl);
        return;
    }

    if k == NODE_INCLUDE_DECL {
        // Process included file
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);
        var path_str *u8 = str_dup_n(path, path_len);

        // Skip if already included
        if map_has(llvm_included_files, path_str) {
            return;
        }
        map_set(llvm_included_files, path_str, 1);

        // Read file
        var buf *u8 = alloc(1048576);  // 1MB max
        var n i64 = read_file_contents(path, path_len, buf, 1048576);
        if n < 0 {
            eprint("Error: cannot read include file: ");
            eprintln(path_str);
            return;
        }

        // Parse file
        var inc_prog *u8 = parse_program_from_string(buf);
        if inc_prog == nil {
            eprint("Error: cannot parse include file: ");
            eprintln(path_str);
            return;
        }

        // Emit declarations from included file
        var inc_decls *u8 = program_decls(inc_prog);
        var inc_count i64 = program_decl_count(inc_prog);
        var i i64 = 0;
        while i < inc_count {
            llvm_emit_decl(get_decl(inc_decls, i));
            i = i + 1;
        }
        return;
    }

    if k == NODE_VAR_DECL {
        // Global variable declaration
        var name *u8 = var_decl_name(decl);
        var name_len i64 = var_decl_name_len(decl);
        var init *u8 = var_decl_init(decl);

        // Register as global
        llvm_add_global(name, name_len);

        // Emit global definition: @name = global i64 <init_value>
        llvm_emit_str("@");
        llvm_emit_n(name, name_len);
        llvm_emit_str(" = global i64 ");

        // Get initial value
        if init != nil {
            if node_kind(init) == NODE_NUMBER_EXPR {
                var val *u8 = number_expr_value(init);
                var val_len i64 = number_expr_value_len(init);
                llvm_emit_n(val, val_len);
            } else if node_kind(init) == NODE_STRING_EXPR {
                // String literal: use constant expression for pointer
                // Note: string value includes quotes, so skip first and last char
                var str_val *u8 = string_expr_value(init) + 1;
                var str_len i64 = string_expr_value_len(init) - 2;
                var idx i64 = llvm_add_string(str_val, str_len);

                // ptrtoint (i8* getelementptr inbounds ([N x i8], [N x i8]* @.strI, i64 0, i64 0) to i64)
                llvm_emit_str("ptrtoint (i8* getelementptr inbounds ([");
                llvm_emit_int(str_len + 1);
                llvm_emit_str(" x i8], [");
                llvm_emit_int(str_len + 1);
                llvm_emit_str(" x i8]* @.str");
                llvm_emit_int(idx);
                llvm_emit_str(", i64 0, i64 0) to i64)");
            } else {
                // Non-constant initializer - use 0 for now
                llvm_emit_str("0");
            }
        } else {
            llvm_emit_str("0");
        }
        llvm_emit_char(10);
        return;
    }

    // TODO: other declaration types (structs, etc.)
}

// Map to track included files for first pass
var llvm_first_pass_included *u8 = nil;

// First pass helper: process a single declaration
func llvm_register_decl(decl *u8) void {
    if decl == nil {
        return;
    }
    var k i64 = node_kind(decl);
    if k == NODE_STRUCT_DECL {
        add_struct(decl);
    } else if k == NODE_FUNC_DECL {
        var name *u8 = func_decl_name(decl);
        var name_len i64 = func_decl_name_len(decl);
        var ret_type *u8 = func_decl_ret_type(decl);
        llvm_register_func(name, name_len, ret_type);
    } else if k == NODE_INCLUDE_DECL {
        // Recursively process included file
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Skip if already included
        var path_key *u8 = str_dup_n(path, path_len);
        if map_has(llvm_first_pass_included, path_key) {
            return;
        }
        map_set(llvm_first_pass_included, path_key, 1);

        // Build path string
        var path_str *u8 = str_dup_n(path, path_len);

        // Read and parse include file
        var buf *u8 = alloc(1024 * 1024);  // 1MB buffer
        var buf_cap i64 = 1024 * 1024;
        var fd i64 = file_open(path_str, 0);
        if fd < 0 {
            return;
        }
        var n i64 = file_read(fd, buf, buf_cap);
        file_close(fd);
        if n < 0 {
            return;
        }
        *(buf + n) = 0;

        // Parse file
        var inc_prog *u8 = parse_program_from_string(buf);
        if inc_prog == nil {
            return;
        }

        // Process declarations from included file
        var inc_decls *u8 = program_decls(inc_prog);
        var inc_count i64 = program_decl_count(inc_prog);
        var i i64 = 0;
        while i < inc_count {
            llvm_register_decl(get_decl(inc_decls, i));
            i = i + 1;
        }
    }
}

// First pass: register top-level declarations (structs and functions)
func llvm_register_all_decls(prog *u8) void {
    llvm_first_pass_included = map_new();
    var decls *u8 = program_decls(prog);
    var count i64 = program_decl_count(prog);
    var i i64 = 0;
    while i < count {
        llvm_register_decl(get_decl(decls, i));
        i = i + 1;
    }
}

func generate_llvm(prog *u8, output_file *u8) void {
    llvm_init_output(output_file);
    llvm_included_files = map_new();
    llvm_init_func_table();
    llvm_init_globals();
    llvm_init_loop_stack();
    llvm_init_strings();
    llvm_init_let_bindings();

    // Initialize x86 backend's shared tracking
    cg_locals = alloc(LIMIT_LOCALS * 32);
    cg_local_count = 0;
    cg_structs = alloc(LIMIT_STRUCTS * 24);
    cg_struct_count = 0;

    // First pass: register structs and functions
    llvm_register_all_decls(prog);

    // Module header
    llvm_emit_line("; LLVM IR generated by lang compiler");
    llvm_emit_line("target triple = \"x86_64-unknown-linux-gnu\"");
    llvm_emit_char(10);

    // Declare external syscall (variadic)
    llvm_emit_line("declare i64 @syscall(i64, ...)");
    llvm_emit_char(10);

    // Emit all declarations
    var decls *u8 = program_decls(prog);
    var count i64 = program_decl_count(prog);

    var i i64 = 0;
    while i < count {
        var decl *u8 = get_decl(decls, i);
        llvm_emit_decl(decl);
        i = i + 1;
    }

    // Emit string constants at end of module
    llvm_emit_all_strings();

    llvm_flush();
}
