// src/codegen_llvm.lang - LLVM IR backend
//
// Emits LLVM IR text format (.ll files) instead of x86 assembly.
// This enables:
// - Cross-platform compilation via clang
// - Access to LLVM optimizations
// - Future: stack maps for precise GC, custom calling conventions
//
// LLVM IR is just different text output. The kernel walks AST and emits strings.
// Pattern:
//   x86:  movq $42, %rax; ret
//   LLVM: ret i64 42

// ============================================================
// Output buffer
// ============================================================

var llvm_out_fd i64 = 0;
var llvm_buf *u8 = nil;
var llvm_len i64 = 0;
var llvm_buf_size i64 = 0;

// Architecture flag: 1 = ARM64 (macOS), 0 = x86-64
var llvm_is_arm64 i64 = 0;

func llvm_init_output(output_file *u8) void {
    llvm_buf_size = 8 * 1024 * 1024;  // 8MB buffer
    llvm_buf = alloc(llvm_buf_size);
    llvm_len = 0;

    llvm_out_fd = file_open(output_file, O_WRONLY_CREAT_TRUNC);
    if llvm_out_fd < 0 {
        eprint("Error: cannot open output file: ");
        eprintln(output_file);
        exit(1);
    }
}

func llvm_emit_char(c u8) void {
    if llvm_len >= llvm_buf_size {
        eprintln("Error: LLVM output buffer overflow");
        exit(1);
    }
    *(llvm_buf + llvm_len) = c;
    llvm_len = llvm_len + 1;
}

func llvm_emit_str(s *u8) void {
    var i i64 = 0;
    while *(s + i) != 0 {
        llvm_emit_char(*(s + i));
        i = i + 1;
    }
}

func llvm_emit_line(s *u8) void {
    llvm_emit_str(s);
    llvm_emit_char(10);  // newline
}

func llvm_emit_int(n i64) void {
    if n < 0 {
        llvm_emit_char(45);  // '-'
        n = 0 - n;
    }
    if n == 0 {
        llvm_emit_char(48);  // '0'
        return;
    }
    // Find highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }
    // Emit digits
    while divisor > 0 {
        var digit i64 = n / divisor;
        llvm_emit_char(48 + digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

func llvm_emit_n(s *u8, len i64) void {
    var i i64 = 0;
    while i < len {
        llvm_emit_char(*(s + i));
        i = i + 1;
    }
}

func llvm_flush() void {
    file_write(llvm_out_fd, llvm_buf, llvm_len);
    file_close(llvm_out_fd);
}

// ============================================================
// Type emission
// ============================================================

func llvm_emit_type(type_node *u8) void {
    if type_node == nil {
        llvm_emit_str("void");
        return;
    }

    var k i64 = type_kind(type_node);

    if k == TYPE_BASE {
        var name *u8 = base_type_name(type_node);
        var len i64 = base_type_name_len(type_node);

        // Map lang types to LLVM types
        if len == 3 && memcmp(name, "i64", 3) {
            llvm_emit_str("i64");
        } else if len == 3 && memcmp(name, "i32", 3) {
            llvm_emit_str("i32");
        } else if len == 3 && memcmp(name, "i16", 3) {
            llvm_emit_str("i16");
        } else if len == 2 && memcmp(name, "i8", 2) {
            llvm_emit_str("i8");
        } else if len == 3 && memcmp(name, "u64", 3) {
            llvm_emit_str("i64");  // LLVM doesn't distinguish signed/unsigned in types
        } else if len == 3 && memcmp(name, "u32", 3) {
            llvm_emit_str("i32");
        } else if len == 3 && memcmp(name, "u16", 3) {
            llvm_emit_str("i16");
        } else if len == 2 && memcmp(name, "u8", 2) {
            llvm_emit_str("i8");
        } else if len == 3 && memcmp(name, "f32", 3) {
            llvm_emit_str("float");
        } else if len == 3 && memcmp(name, "f64", 3) {
            llvm_emit_str("double");
        } else if len == 4 && memcmp(name, "i128", 4) {
            llvm_emit_str("i128");
        } else if len == 4 && memcmp(name, "u128", 4) {
            llvm_emit_str("i128");  // LLVM uses i128 for both signed/unsigned
        } else if len == 4 && memcmp(name, "bool", 4) {
            llvm_emit_str("i1");
        } else if len == 4 && memcmp(name, "void", 4) {
            llvm_emit_str("void");
        } else {
            llvm_emit_str("i64");  // Default
        }
        return;
    }

    if k == TYPE_PTR {
        llvm_emit_str("i8*");  // Use typed pointers for older LLVM
        return;
    }

    if k == TYPE_ARRAY {
        // LLVM array type: [N x T]
        llvm_emit_str("[");
        llvm_emit_int(array_type_size(type_node));
        llvm_emit_str(" x ");
        llvm_emit_type(array_type_elem(type_node));
        llvm_emit_str("]");
        return;
    }

    // Default fallback
    llvm_emit_str("i64");
}

func llvm_is_pointer_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    return type_kind(t) == TYPE_PTR;
}

// ============================================================
// Expression emission
// ============================================================

// Label counter for generating unique labels
var llvm_label_counter i64 = 0;

func llvm_next_label() i64 {
    var n i64 = llvm_label_counter;
    llvm_label_counter = llvm_label_counter + 1;
    return n;
}

// Temp register counter
var llvm_temp_counter i64 = 0;

func llvm_next_temp() i64 {
    var n i64 = llvm_temp_counter;
    llvm_temp_counter = llvm_temp_counter + 1;
    return n;
}

// Counter for anonymous locals (enums, etc.)
var llvm_anon_local_counter i64 = 0;

// Allocate an anonymous local with given size, returns LLVM variable name
func llvm_alloc_local_size(size i64) *u8 {
    var name *u8 = alloc(32);
    var p *u8 = name;
    *p = 91; p = p + 1;  // [
    itoa(size, p);
    var len i64 = strlen(p);
    p = p + len;
    *p = 32; p = p + 1;  // space
    *p = 120; p = p + 1;  // x
    *p = 32; p = p + 1;  // space
    *p = 105; p = p + 1;  // i
    *p = 56; p = p + 1;   // 8
    *p = 93; p = p + 1;   // ]
    *p = 0;

    // Emit alloca
    var local_name *u8 = alloc(32);
    *local_name = 37;  // %
    *(local_name + 1) = 95;  // _
    *(local_name + 2) = 97;  // a
    itoa(llvm_anon_local_counter, local_name + 3);
    llvm_anon_local_counter = llvm_anon_local_counter + 1;

    llvm_emit_str("    ");
    llvm_emit_str(local_name);
    llvm_emit_str(" = alloca ");
    llvm_emit_str(name);
    llvm_emit_char(10);

    return local_name;
}

// Track local variables (need load) vs parameters (use directly)
var llvm_locals *u8 = nil;

// Track if last emitted instruction was a terminator (ret, br)
var llvm_emitted_terminator i64 = 0;

// Current function's return type (for correct return statement emission)
var llvm_current_ret_type *u8 = nil;

func llvm_reset_locals() void {
    llvm_locals = map_new();
}

func llvm_add_local(name *u8, len i64) void {
    var key *u8 = str_dup_n(name, len);
    map_set(llvm_locals, key, 1);
}

func llvm_is_local(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    return map_has(llvm_locals, key);
}

// Let binding stack for name remapping (SSA unique names)
// Each entry: [orig_name:8][orig_len:8][unique_name:8][unique_len:8] = 32 bytes
var llvm_let_bindings *u8 = nil;
var llvm_let_depth i64 = 0;

func llvm_init_let_bindings() void {
    llvm_let_bindings = alloc(256 * 32);  // Max 256 nested let bindings
    llvm_let_depth = 0;
}

func llvm_push_let_binding(name *u8, name_len i64, unique *u8, unique_len i64) void {
    var entry *u8 = llvm_let_bindings + (llvm_let_depth * 32);
    var p_name **u8 = entry;
    *p_name = name;
    var p_name_len *i64 = entry + 8;
    *p_name_len = name_len;
    var p_unique **u8 = entry + 16;
    *p_unique = unique;
    var p_unique_len *i64 = entry + 24;
    *p_unique_len = unique_len;
    llvm_let_depth = llvm_let_depth + 1;
}

func llvm_pop_let_binding() void {
    if llvm_let_depth > 0 {
        llvm_let_depth = llvm_let_depth - 1;
    }
}

// Look up let binding and return unique name if found
// Returns nil if not found
func llvm_find_let_binding(name *u8, name_len i64) *u8 {
    var i i64 = llvm_let_depth - 1;
    while i >= 0 {
        var entry *u8 = llvm_let_bindings + (i * 32);
        var p_name **u8 = entry;
        var p_name_len *i64 = entry + 8;
        if *p_name_len == name_len {
            var j i64 = 0;
            var same i64 = 1;
            while j < name_len {
                if *(*p_name + j) != *(name + j) {
                    same = 0;
                }
                j = j + 1;
            }
            if same != 0 {
                return entry;  // Return entry pointer (unique name at offset 16)
            }
        }
        i = i - 1;
    }
    return nil;
}

func llvm_let_unique_name(entry *u8) *u8 {
    var p **u8 = entry + 16;
    return *p;
}

func llvm_let_unique_len(entry *u8) i64 {
    var p *i64 = entry + 24;
    return *p;
}

// Global variable table
var llvm_globals *u8 = nil;

func llvm_init_globals() void {
    llvm_globals = map_new();
}

func llvm_add_global(name *u8, len i64) void {
    var key *u8 = str_dup_n(name, len);
    map_set(llvm_globals, key, 1);
}

func llvm_is_global(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    return map_has(llvm_globals, key);
}

// String literal tracking
// Each entry: [ptr:8][len:8] = 16 bytes
var llvm_strings *u8 = nil;
var llvm_string_count i64 = 0;

// Lambda registry
// Each entry: [lambda_node:8][lambda_id:8][captures:8][capture_count:8] = 32 bytes
var llvm_lambdas *u8 = nil;
var llvm_lambda_count i64 = 0;

func llvm_init_lambdas() void {
    llvm_lambdas = alloc(500 * 32);  // Max 500 lambdas
    llvm_lambda_count = 0;
}

func llvm_init_strings() void {
    llvm_strings = alloc(3000 * 16);  // Max 3000 strings
    llvm_string_count = 0;
}

func llvm_add_string(ptr *u8, len i64) i64 {
    // Check if this string already exists (dedup)
    var i i64 = 0;
    while i < llvm_string_count {
        var entry *u8 = llvm_strings + (i * 16);
        var existing_ptr **u8 = entry;
        var existing_len *i64 = entry + 8;
        if *existing_len == len {
            var j i64 = 0;
            var same i64 = 1;
            while j < len {
                if *(*existing_ptr + j) != *(ptr + j) {
                    same = 0;
                }
                j = j + 1;
            }
            if same != 0 {
                return i;
            }
        }
        i = i + 1;
    }

    // Add new string
    var entry *u8 = llvm_strings + (llvm_string_count * 16);
    var entry_ptr **u8 = entry;
    var entry_len *i64 = entry + 8;
    *entry_ptr = ptr;
    *entry_len = len;
    var idx i64 = llvm_string_count;
    llvm_string_count = llvm_string_count + 1;
    return idx;
}

// Calculate processed length of string (handling escape sequences)
func llvm_string_processed_len(ptr *u8, len i64) i64 {
    var result i64 = 0;
    var j i64 = 0;
    while j < len {
        var c u8 = *(ptr + j);
        if c == 92 && j + 1 < len {  // backslash escape
            j = j + 1;  // Skip the next char (the escape code)
        }
        result = result + 1;
        j = j + 1;
    }
    return result;
}

func llvm_emit_all_strings() void {
    var i i64 = 0;
    while i < llvm_string_count {
        var entry *u8 = llvm_strings + (i * 16);
        var ptr **u8 = entry;
        var len *i64 = entry + 8;

        // String is raw content (escapes already processed)
        // @.str0 = private constant [6 x i8] c"hello\00"
        llvm_emit_str("@.str");
        llvm_emit_int(i);
        llvm_emit_str(" = private constant [");
        llvm_emit_int(*len + 1);  // +1 for null terminator
        llvm_emit_str(" x i8] c\"");

        // Emit raw string content - special chars need escapes for LLVM IR
        var j i64 = 0;
        while j < *len {
            var c u8 = *(*ptr + j);
            if c >= 32 && c < 127 && c != 34 && c != 92 {
                // Printable ASCII except quote and backslash
                llvm_emit_char(c);
            } else if c == 34 {
                // Quote: use hex escape
                llvm_emit_str("\\22");
            } else if c == 92 {
                // Backslash: use hex escape
                llvm_emit_str("\\5C");
            } else {
                // Non-printable character - emit hex escape
                llvm_emit_str("\\");
                var hi u8 = c / 16;
                var lo u8 = c % 16;
                if hi < 10 { llvm_emit_char(48 + hi); } else { llvm_emit_char(55 + hi); }
                if lo < 10 { llvm_emit_char(48 + lo); } else { llvm_emit_char(55 + lo); }
            }
            j = j + 1;
        }
        llvm_emit_line("\\00\"");

        i = i + 1;
    }
    if llvm_string_count > 0 {
        llvm_emit_char(10);
    }
}

// Loop stack for break/continue
// Each entry: [name_ptr:8][name_len:8][break_label:8][continue_label:8] = 32 bytes
var llvm_loop_stack *u8 = nil;
var llvm_loop_depth i64 = 0;

func llvm_init_loop_stack() void {
    llvm_loop_stack = alloc(256 * 32);  // Max 256 nested loops
    llvm_loop_depth = 0;
}

func llvm_push_loop_labeled(name *u8, name_len i64, break_label i64, continue_label i64) void {
    var entry *u8 = llvm_loop_stack + (llvm_loop_depth * 32);
    var p_name **u8 = entry;
    *p_name = name;
    var p_len *i64 = entry + 8;
    *p_len = name_len;
    var p_break *i64 = entry + 16;
    *p_break = break_label;
    var p_cont *i64 = entry + 24;
    *p_cont = continue_label;
    llvm_loop_depth = llvm_loop_depth + 1;
}

func llvm_push_loop(break_label i64, continue_label i64) void {
    llvm_push_loop_labeled(nil, 0, break_label, continue_label);
}

func llvm_pop_loop() void {
    llvm_loop_depth = llvm_loop_depth - 1;
}

func llvm_find_loop(name *u8, name_len i64) *u8 {
    // Search from top of stack (innermost loop first)
    var i i64 = llvm_loop_depth - 1;
    while i >= 0 {
        var entry *u8 = llvm_loop_stack + (i * 32);
        var p_name **u8 = entry;
        var entry_name *u8 = *p_name;
        var p_len *i64 = entry + 8;
        var entry_len i64 = *p_len;

        if name == nil {
            // No label specified, return innermost loop
            return entry;
        }
        if entry_name != nil && entry_len == name_len {
            // Compare names
            var is_match i64 = 1;
            var j i64 = 0;
            while j < name_len {
                if *(name + j) != *(entry_name + j) {
                    is_match = 0;
                }
                j = j + 1;
            }
            if is_match == 1 {
                return entry;
            }
        }
        i = i - 1;
    }
    return nil;
}

func llvm_loop_break_label(entry *u8) i64 {
    var p *i64 = entry + 16;
    return *p;
}

func llvm_loop_continue_label(entry *u8) i64 {
    var p *i64 = entry + 24;
    return *p;
}

// Effect registry: stores effect declarations for handler dispatch
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
var llvm_effects *u8 = nil;
var llvm_effect_count i64 = 0;

func llvm_init_effects() void {
    llvm_effects = alloc(100 * 24);  // Max 100 effects
    llvm_effect_count = 0;
}

func llvm_add_effect(decl *u8) void {
    var name *u8 = effect_decl_name(decl);
    var name_len i64 = effect_decl_name_len(decl);

    var entry *u8 = llvm_effects + (llvm_effect_count * 24);
    var np **u8 = entry;
    *np = name;
    var nl *i64 = entry + 8;
    *nl = name_len;
    var dp **u8 = entry + 16;
    *dp = decl;

    llvm_effect_count = llvm_effect_count + 1;
}

func llvm_find_effect(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < llvm_effect_count {
        var entry *u8 = llvm_effects + (i * 24);
        var np **u8 = entry;
        var ename *u8 = *np;
        var nl *i64 = entry + 8;
        var elen i64 = *nl;

        if elen == name_len {
            if memcmp(ename, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

// Function table: track return types (1=void, 0=non-void)
var llvm_func_ret_types *u8 = nil;

func llvm_is_void_type(t *u8) i64 {
    if t == nil {
        return 1;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 4 {
            if memcmp(name, "void", 4) {
                return 1;
            }
        }
    }
    return 0;
}

func llvm_init_func_table() void {
    llvm_func_ret_types = map_new();
}

func llvm_is_bool_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 4 {
            if memcmp(name, "bool", 4) {
                return 1;
            }
        }
    }
    return 0;
}

func llvm_is_u8_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 2 {
            if memcmp(name, "u8", 2) {
                return 1;
            }
        }
    }
    return 0;
}

func llvm_is_f32_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 3 {
            if memcmp(name, "f32", 3) {
                return 1;
            }
        }
    }
    return 0;
}

func llvm_is_f64_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 3 {
            if memcmp(name, "f64", 3) {
                return 1;
            }
        }
    }
    return 0;
}

func llvm_is_float_type(t *u8) i64 {
    return llvm_is_f32_type(t) || llvm_is_f64_type(t);
}

// Check if a value string contains a decimal point (is a float literal)
func llvm_is_float_literal(val *u8) i64 {
    if val == nil {
        return 0;
    }
    var i i64 = 0;
    while *(val + i) != 0 {
        if *(val + i) == 46 {  // '.'
            return 1;
        }
        i = i + 1;
    }
    return 0;
}

// Check if type is a signed integer (i8, i16, i32, i64, i128)
func llvm_is_signed_int(t *u8) i64 {
    if t == nil { return 0; }
    if type_kind(t) != TYPE_BASE { return 0; }
    var name *u8 = base_type_name(t);
    return *name == 'i';  // i8, i16, i32, i64, i128 start with 'i'
}

// Check if type is an unsigned integer (u8, u16, u32, u64, u128)
func llvm_is_unsigned_int(t *u8) i64 {
    if t == nil { return 0; }
    if type_kind(t) != TYPE_BASE { return 0; }
    var name *u8 = base_type_name(t);
    return *name == 'u';  // u8, u16, u32, u64, u128 start with 'u'
}

// Get type size in bits (for cast decisions)
func llvm_type_bits(t *u8) i64 {
    if t == nil { return 64; }
    if type_kind(t) != TYPE_BASE { return 64; }
    var name *u8 = base_type_name(t);
    var len i64 = base_type_name_len(t);

    if len == 2 && memcmp(name, "i8", 2) { return 8; }
    if len == 2 && memcmp(name, "u8", 2) { return 8; }
    if len == 3 && memcmp(name, "i16", 3) { return 16; }
    if len == 3 && memcmp(name, "u16", 3) { return 16; }
    if len == 3 && memcmp(name, "i32", 3) { return 32; }
    if len == 3 && memcmp(name, "u32", 3) { return 32; }
    if len == 3 && memcmp(name, "f32", 3) { return 32; }
    if len == 3 && memcmp(name, "i64", 3) { return 64; }
    if len == 3 && memcmp(name, "u64", 3) { return 64; }
    if len == 3 && memcmp(name, "f64", 3) { return 64; }
    if len == 4 && memcmp(name, "i128", 4) { return 128; }
    if len == 4 && memcmp(name, "u128", 4) { return 128; }
    if len == 4 && memcmp(name, "bool", 4) { return 1; }
    return 64;  // default
}

func llvm_register_func(name *u8, len i64, ret_type *u8) void {
    var key *u8 = str_dup_n(name, len);
    // Store: 0 = i64, 1 = void, 2 = pointer, 3 = bool, 4 = u8, 5 = f32, 6 = f64
    var ret_kind i64 = 0;
    if llvm_is_void_type(ret_type) {
        ret_kind = 1;
    } else if llvm_is_pointer_type(ret_type) {
        ret_kind = 2;
    } else if llvm_is_bool_type(ret_type) {
        ret_kind = 3;
    } else if llvm_is_u8_type(ret_type) {
        ret_kind = 4;
    } else if llvm_is_f32_type(ret_type) {
        ret_kind = 5;
    } else if llvm_is_f64_type(ret_type) {
        ret_kind = 6;
    }
    map_set(llvm_func_ret_types, key, ret_kind);
}

func llvm_func_returns_void(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 1;
    }
    return 0;  // Default: assume non-void
}

func llvm_func_returns_ptr(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 2;
    }
    return 0;  // Default: assume i64
}

func llvm_func_returns_bool(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 3;
    }
    return 0;  // Default: assume i64
}

func llvm_func_returns_u8(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 4;
    }
    return 0;  // Default: assume i64
}

func llvm_func_returns_f32(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 5;
    }
    return 0;
}

func llvm_func_returns_f64(name *u8, len i64) i64 {
    var key *u8 = str_dup_n(name, len);
    if map_has(llvm_func_ret_types, key) {
        return map_get(llvm_func_ret_types, key) == 6;
    }
    return 0;
}

// Set llvm_expr_result to "%t{n}"
// Use simple sprintf-like approach: build string from scratch
func llvm_set_result_temp(n i64) void {
    // Build "%tN" where N is the number
    var buf *u8 = llvm_expr_result;
    var idx i64 = 0;

    // Always starts with "%t"
    *(buf + idx) = 37;  // '%'
    idx = idx + 1;
    *(buf + idx) = 116; // 't'
    idx = idx + 1;

    if n == 0 {
        *(buf + idx) = 48;  // '0'
        idx = idx + 1;
        *(buf + idx) = 0;   // null
        return;
    }

    // For multi-digit numbers, we need to reverse
    // First, count digits and collect them
    var num_buf *u8 = alloc(32);
    var num_idx i64 = 0;
    var tmp i64 = n;
    while tmp > 0 {
        *(num_buf + num_idx) = 48 + (tmp % 10);
        tmp = tmp / 10;
        num_idx = num_idx + 1;
    }

    // Copy digits in reverse order
    var i i64 = num_idx - 1;
    while i >= 0 {
        *(buf + idx) = *(num_buf + i);
        idx = idx + 1;
        i = i - 1;
    }

    // Null terminator
    *(buf + idx) = 0;
}

// Set llvm_expr_result to an integer literal
func llvm_set_result_int(n i64) void {
    var buf *u8 = llvm_expr_result;
    itoa(n, buf);
}

func llvm_set_result_str(s *u8) void {
    var dst *u8 = llvm_expr_result;
    var i i64 = 0;
    while *(s + i) != 0 {
        *(dst + i) = *(s + i);
        i = i + 1;
    }
    *(dst + i) = 0;
}

// Get type of expression (mirrors get_expr_type from codegen.lang)
func llvm_get_expr_type(expr *u8) *u8 {
    if expr == nil {
        return nil;
    }

    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check locals first
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            return local_get_type(local_idx);
        }

        // Check globals
        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            return global_get_type(global_idx);
        }

        return nil;
    }

    if k == NODE_INDEX_EXPR {
        // IndexExpr: [kind:8][base:8][index:8]
        var base_p **u8 = expr + 8;
        var base_type *u8 = llvm_get_expr_type(*base_p);
        if base_type == nil {
            return nil;
        }
        // For both arrays and pointers, return the element type
        if type_kind(base_type) == TYPE_ARRAY {
            return array_type_elem(base_type);
        }
        if type_kind(base_type) == TYPE_PTR {
            return ptr_type_elem(base_type);
        }
        return nil;
    }

    if k == NODE_CAST_EXPR {
        return cast_expr_type(expr);
    }

    if k == NODE_BITCAST_EXPR {
        return bitcast_expr_type(expr);
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_STAR {
            var inner_type *u8 = llvm_get_expr_type(unary_expr_expr(expr));
            if inner_type != nil && type_kind(inner_type) == TYPE_PTR {
                return ptr_type_elem(inner_type);
            }
        }
        return llvm_get_expr_type(unary_expr_expr(expr));
    }

    if k == NODE_BINARY_EXPR {
        return llvm_get_expr_type(binary_expr_left(expr));
    }

    return nil;
}

// Get the address of an array variable (for array indexing)
// Emits code that puts address in result temp
func llvm_emit_array_addr(expr *u8) void {
    if expr == nil {
        return;
    }
    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check for let binding first (SSA unique names)
        var let_entry *u8 = llvm_find_let_binding(name, name_len);
        if let_entry != nil {
            var unique *u8 = llvm_let_unique_name(let_entry);
            var unique_len i64 = llvm_let_unique_len(let_entry);

            var local_idx i64 = find_local(name, name_len);
            var local_type *u8 = local_get_type(local_idx);

            // For arrays, bitcast [N x T]* to T*
            var bitcast_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(bitcast_temp);
            llvm_emit_str(" = bitcast ");
            llvm_emit_type(local_type);
            llvm_emit_str("* %");
            llvm_emit_n(unique, unique_len);
            llvm_emit_str(" to ");
            if type_kind(local_type) == TYPE_ARRAY {
                llvm_emit_type(array_type_elem(local_type));
            } else {
                llvm_emit_str("i64");
            }
            llvm_emit_line("*");

            llvm_set_result_temp(bitcast_temp);
            return;
        }

        // Check local (no let binding)
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            var local_type *u8 = local_get_type(local_idx);

            // For arrays, the alloca pointer IS the array address
            // We need to bitcast [N x T]* to T*
            var bitcast_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(bitcast_temp);
            llvm_emit_str(" = bitcast ");
            llvm_emit_type(local_type);
            llvm_emit_str("* %");
            llvm_emit_n(name, name_len);
            llvm_emit_str(" to ");
            if type_kind(local_type) == TYPE_ARRAY {
                llvm_emit_type(array_type_elem(local_type));
            } else {
                llvm_emit_str("i64");
            }
            llvm_emit_line("*");

            llvm_set_result_temp(bitcast_temp);
            return;
        }

        // Check global
        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            var global_type *u8 = global_get_type(global_idx);

            // For global arrays, get pointer to first element
            var gep_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(gep_temp);
            llvm_emit_str(" = getelementptr ");
            llvm_emit_type(global_type);
            llvm_emit_str(", ");
            llvm_emit_type(global_type);
            llvm_emit_str("* @");
            llvm_emit_n(name, name_len);
            llvm_emit_line(", i64 0, i64 0");

            llvm_set_result_temp(gep_temp);
            return;
        }
    }

    // Fallback: treat as expression
    llvm_emit_expr(expr);
}

// Emit expression, return the LLVM value reference (e.g., "%1" or "42")
// Result is written to a temp buffer that caller must use immediately
var llvm_expr_result *u8 = nil;
var llvm_expr_is_float i64 = 0;  // Track if last expression result is a float type

func llvm_emit_expr(expr *u8) void {
    if llvm_expr_result == nil {
        llvm_expr_result = alloc(256);
    }

    // Reset float tracking (will be set if we emit a float)
    llvm_expr_is_float = 0;

    if expr == nil {
        // Return void/undef
        var p *u8 = llvm_expr_result;
        *p = 48;  // "0"
        *(p + 1) = 0;
        return;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        // Emit literal number - value is stored as a string
        var ptr *u8 = number_expr_value(expr);
        // Check if it's a float literal (contains '.')
        if llvm_is_float_literal(ptr) {
            llvm_expr_is_float = 1;
        }
        var len i64 = number_expr_value_len(expr);
        var i i64 = 0;
        while i < len {
            *(llvm_expr_result + i) = *(ptr + i);
            i = i + 1;
        }
        *(llvm_expr_result + len) = 0;
        return;
    }

    if k == NODE_BOOL_EXPR {
        // Emit boolean: true=1, false=0
        var val i64 = bool_expr_value(expr);
        if val != 0 {
            *(llvm_expr_result) = 49;  // '1'
        } else {
            *(llvm_expr_result) = 48;  // '0'
        }
        *(llvm_expr_result + 1) = 0;
        return;
    }

    if k == NODE_STRING_EXPR {
        // Add string to table and get pointer
        // String value is raw content (no quotes, escapes already processed)
        var str_val *u8 = string_expr_value(expr);
        var str_len i64 = string_expr_value_len(expr);
        var idx i64 = llvm_add_string(str_val, str_len);

        // Length is just the raw length (escapes already processed)
        var processed_len i64 = str_len;

        // GEP to get pointer to first element
        // %t = ptrtoint i8* getelementptr inbounds ([N x i8], [N x i8]* @.strI, i64 0, i64 0) to i64
        var temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(temp);
        llvm_emit_str(" = ptrtoint i8* getelementptr inbounds ([");
        llvm_emit_int(processed_len + 1);
        llvm_emit_str(" x i8], [");
        llvm_emit_int(processed_len + 1);
        llvm_emit_str(" x i8]* @.str");
        llvm_emit_int(idx);
        llvm_emit_line(", i64 0, i64 0) to i64");
        llvm_set_result_temp(temp);
        return;
    }

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var len i64 = ident_expr_name_len(expr);

        // Check for let binding first (SSA unique names)
        var let_entry *u8 = llvm_find_let_binding(name, len);
        if let_entry != nil {
            // Let binding: use unique name
            var unique *u8 = llvm_let_unique_name(let_entry);
            var unique_len i64 = llvm_let_unique_len(let_entry);

            // Check if this is an aggregate type (struct or enum)
            var local_idx i64 = find_local(name, len);
            var local_type *u8 = nil;
            var is_aggregate i64 = 0;
            var aggregate_size i64 = 0;

            if local_idx >= 0 {
                local_type = local_get_type(local_idx);
                if local_type != nil && type_kind(local_type) == TYPE_BASE {
                    var type_name *u8 = base_type_name(local_type);
                    var type_name_len i64 = base_type_name_len(local_type);
                    var struct_decl *u8 = find_struct(type_name, type_name_len);
                    if struct_decl != nil {
                        is_aggregate = 1;
                        aggregate_size = get_struct_size(struct_decl);
                    } else {
                        var enum_decl *u8 = find_enum(type_name, type_name_len);
                        if enum_decl != nil {
                            is_aggregate = 1;
                            aggregate_size = get_enum_size(enum_decl);
                        }
                    }
                }
            }

            if is_aggregate != 0 {
                // Aggregate let binding: emit ptrtoint with unique name
                var temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = ptrtoint [");
                llvm_emit_int(aggregate_size);
                llvm_emit_str(" x i8]* %");
                llvm_emit_n(unique, unique_len);
                llvm_emit_line(" to i64");
                llvm_set_result_temp(temp);
            } else {
                // Primitive let binding: load from unique name with proper type
                var temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = load ");
                if local_type != nil && llvm_is_float_type(local_type) {
                    llvm_expr_is_float = 1;
                    llvm_emit_type(local_type);
                    llvm_emit_str(", ");
                    llvm_emit_type(local_type);
                    llvm_emit_str("* %");
                } else {
                    llvm_emit_str("i64, i64* %");
                }
                llvm_emit_n(unique, unique_len);
                llvm_emit_char(10);
                llvm_set_result_temp(temp);
            }
        } else if llvm_is_local(name, len) {
            // Local variable: check if it's an aggregate type (struct/enum)
            var local_idx i64 = find_local(name, len);
            var local_type *u8 = nil;
            var is_aggregate i64 = 0;
            var aggregate_size i64 = 0;

            if local_idx >= 0 {
                local_type = local_get_type(local_idx);
                if local_type != nil && type_kind(local_type) == TYPE_BASE {
                    var type_name *u8 = base_type_name(local_type);
                    var type_name_len i64 = base_type_name_len(local_type);
                    var struct_decl *u8 = find_struct(type_name, type_name_len);
                    if struct_decl != nil {
                        is_aggregate = 1;
                        aggregate_size = get_struct_size(struct_decl);
                    } else {
                        var enum_decl *u8 = find_enum(type_name, type_name_len);
                        if enum_decl != nil {
                            is_aggregate = 1;
                            aggregate_size = get_enum_size(enum_decl);
                        }
                    }
                }
            }

            if is_aggregate != 0 {
                // Aggregate type: return address (ptrtoint)
                var temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = ptrtoint [");
                llvm_emit_int(aggregate_size);
                llvm_emit_str(" x i8]* %");
                llvm_emit_n(name, len);
                llvm_emit_line(" to i64");
                llvm_set_result_temp(temp);
            } else {
                // Primitive type: emit load with proper type
                var temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = load ");
                if local_type != nil && llvm_is_float_type(local_type) {
                    llvm_expr_is_float = 1;
                    llvm_emit_type(local_type);
                    llvm_emit_str(", ");
                    llvm_emit_type(local_type);
                    llvm_emit_str("* %");
                } else {
                    llvm_emit_str("i64, i64* %");
                }
                llvm_emit_n(name, len);
                llvm_emit_char(10);
                llvm_set_result_temp(temp);
            }
        } else if llvm_is_global(name, len) {
            // Global variable: emit load from @name
            var global_idx i64 = find_global(name, len);
            var global_type *u8 = nil;
            if global_idx >= 0 {
                global_type = global_get_type(global_idx);
            }
            var temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = load ");
            if global_type != nil && llvm_is_float_type(global_type) {
                llvm_expr_is_float = 1;
                llvm_emit_type(global_type);
                llvm_emit_str(", ");
                llvm_emit_type(global_type);
                llvm_emit_str("* @");
            } else {
                llvm_emit_str("i64, i64* @");
            }
            llvm_emit_n(name, len);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        } else {
            // Parameter: use directly
            *(llvm_expr_result) = 37;  // '%'
            var i i64 = 0;
            while i < len {
                *(llvm_expr_result + 1 + i) = *(name + i);
                i = i + 1;
            }
            *(llvm_expr_result + 1 + len) = 0;
        }
        return;
    }

    if k == NODE_CALL_EXPR {
        // Function call: emit call instruction and store result in temp
        var func_expr *u8 = call_expr_func(expr);
        var args *u8 = call_expr_args(expr);
        var arg_count i64 = call_expr_arg_count(expr);

        // Check for enum variant construction: EnumName.Variant(payload)
        if node_kind(func_expr) == NODE_FIELD_EXPR {
            var field_base *u8 = field_expr_expr(func_expr);
            var field_name *u8 = field_expr_field(func_expr);
            var field_len i64 = field_expr_field_len(func_expr);

            // Check if base is an ident that matches an enum
            if node_kind(field_base) == NODE_IDENT_EXPR {
                var enum_name *u8 = ident_expr_name(field_base);
                var enum_name_len i64 = ident_expr_name_len(field_base);
                var enum_decl *u8 = find_enum(enum_name, enum_name_len);

                if enum_decl != nil {
                    // Find the variant
                    var variant *u8 = find_variant(enum_decl, field_name, field_len);
                    if variant == nil {
                        eprint("error: enum '");
                        eprint_buf(enum_name, enum_name_len);
                        eprint("' has no variant '");
                        eprint_buf(field_name, field_len);
                        eprintln("'");
                        return;
                    }

                    // Allocate space for enum on stack
                    var enum_size i64 = get_enum_size(enum_decl);
                    var enum_var *u8 = llvm_alloc_local_size(enum_size);

                    // Build the type string for ptrtoint (e.g., "[16 x i8]*")
                    var type_str *u8 = alloc(32);
                    var tp *u8 = type_str;
                    *tp = 91; tp = tp + 1;  // [
                    itoa(enum_size, tp);
                    tp = tp + strlen(tp);
                    *tp = 32; tp = tp + 1;  // space
                    *tp = 120; tp = tp + 1;  // x
                    *tp = 32; tp = tp + 1;  // space
                    *tp = 105; tp = tp + 1;  // i
                    *tp = 56; tp = tp + 1;   // 8
                    *tp = 93; tp = tp + 1;   // ]
                    *tp = 42; tp = tp + 1;   // *
                    *tp = 0;

                    // Set tag
                    var tag i64 = enum_variant_tag(variant);
                    var tag_ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(tag_ptr_temp);
                    llvm_emit_str(" = ptrtoint ");
                    llvm_emit_str(type_str);
                    llvm_emit_str(" ");
                    llvm_emit_str(enum_var);
                    llvm_emit_line(" to i64");

                    var tag_store_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(tag_store_temp);
                    llvm_emit_str(" = inttoptr i64 %t");
                    llvm_emit_int(tag_ptr_temp);
                    llvm_emit_line(" to i64*");

                    llvm_emit_str("    store i64 ");
                    llvm_emit_int(tag);
                    llvm_emit_str(", i64* %t");
                    llvm_emit_int(tag_store_temp);
                    llvm_emit_char(10);

                    // Set payload if present
                    if arg_count > 0 {
                        var p **u8 = args;
                        llvm_emit_expr(*p);
                        var payload_val *u8 = str_dup(llvm_expr_result);

                        var payload_type *u8 = enum_variant_type(variant);
                        var payload_size i64 = 8;
                        if payload_type != nil {
                            payload_size = get_type_size(payload_type);
                        }

                        // Get pointer to payload (offset 8 from enum base)
                        var payload_ptr_temp i64 = llvm_next_temp();
                        llvm_emit_str("    %t");
                        llvm_emit_int(payload_ptr_temp);
                        llvm_emit_str(" = add i64 %t");
                        llvm_emit_int(tag_ptr_temp);
                        llvm_emit_line(", 8");

                        if payload_size <= 8 {
                            // Simple store
                            var payload_store_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(payload_store_temp);
                            llvm_emit_str(" = inttoptr i64 %t");
                            llvm_emit_int(payload_ptr_temp);
                            llvm_emit_line(" to i64*");

                            llvm_emit_str("    store i64 ");
                            llvm_emit_str(payload_val);
                            llvm_emit_str(", i64* %t");
                            llvm_emit_int(payload_store_temp);
                            llvm_emit_char(10);
                        } else {
                            // Aggregate - payload_val is pointer, copy bytes
                            var copy_i i64 = 0;
                            while copy_i < payload_size {
                                // Load from source
                                var src_offset_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(src_offset_temp);
                                llvm_emit_str(" = add i64 ");
                                llvm_emit_str(payload_val);
                                llvm_emit_str(", ");
                                llvm_emit_int(copy_i);
                                llvm_emit_char(10);

                                var src_ptr_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(src_ptr_temp);
                                llvm_emit_str(" = inttoptr i64 %t");
                                llvm_emit_int(src_offset_temp);
                                llvm_emit_line(" to i64*");

                                var load_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(load_temp);
                                llvm_emit_str(" = load i64, i64* %t");
                                llvm_emit_int(src_ptr_temp);
                                llvm_emit_char(10);

                                // Store to dest
                                var dst_offset_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(dst_offset_temp);
                                llvm_emit_str(" = add i64 %t");
                                llvm_emit_int(payload_ptr_temp);
                                llvm_emit_str(", ");
                                llvm_emit_int(copy_i);
                                llvm_emit_char(10);

                                var dst_ptr_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(dst_ptr_temp);
                                llvm_emit_str(" = inttoptr i64 %t");
                                llvm_emit_int(dst_offset_temp);
                                llvm_emit_line(" to i64*");

                                llvm_emit_str("    store i64 %t");
                                llvm_emit_int(load_temp);
                                llvm_emit_str(", i64* %t");
                                llvm_emit_int(dst_ptr_temp);
                                llvm_emit_char(10);

                                copy_i = copy_i + 8;
                            }
                        }
                    }

                    // Return pointer to enum value
                    var result_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(result_temp);
                    llvm_emit_str(" = ptrtoint ");
                    llvm_emit_str(type_str);
                    llvm_emit_str(" ");
                    llvm_emit_str(enum_var);
                    llvm_emit_line(" to i64");

                    llvm_set_result_temp(result_temp);
                    return;
                }
            }
        }

        // Get function name from the function expression (usually an ident)
        var func_name *u8 = nil;
        var func_name_len i64 = 0;
        var is_indirect i64 = 0;
        var indirect_ptr_val *u8 = nil;
        var known_func *u8 = nil;  // Must be declared before if-else to avoid garbage in else branch
        if node_kind(func_expr) == NODE_IDENT_EXPR {
            func_name = ident_expr_name(func_expr);
            func_name_len = ident_expr_name_len(func_expr);

            // Check for macro call first
            var macro_def *u8 = find_macro(func_name, func_name_len);
            if macro_def != nil {
                // Expand and compile the macro
                var expanded *u8 = interp_call_macro(macro_def, args, arg_count);
                if expanded != nil {
                    llvm_emit_expr(expanded);
                }
                return;
            }

            // Check if it's a known function
            known_func = find_func(func_name, func_name_len);
            if known_func != nil {
                // Check visibility - can only call non-pub functions from same module
                check_func_visibility(func_name, func_name_len);
            }
            if known_func == nil {
                // Not a known function - might be a function pointer variable
                // Check if it's a local, parameter, or global
                if llvm_is_local(func_name, func_name_len) {
                    is_indirect = 1;
                } else if llvm_is_global(func_name, func_name_len) {
                    is_indirect = 2;  // 2 = global indirect
                }
            }
        } else {
            // Non-identifier function expression (e.g., struct.field, array[i])
            // Evaluate the expression to get the function pointer value
            is_indirect = 3;  // 3 = expression-based indirect call

            // Emit the function expression to get the pointer value
            llvm_emit_expr(func_expr);
            indirect_ptr_val = str_dup(llvm_expr_result);
        }

        // First, emit all argument expressions and collect their values
        var arg_vals **u8 = alloc(arg_count * 8);
        var i i64 = 0;
        while i < arg_count {
            var arg_ptr *u8 = args + (i * 8);
            var arg **u8 = arg_ptr;
            llvm_emit_expr(*arg);
            *(arg_vals + i) = str_dup(llvm_expr_result);
            i = i + 1;
        }

        // Check if this is a closure type call (needs special handling)
        var is_closure_call i64 = 0;
        if is_indirect == 1 || is_indirect == 2 {
            // Check the variable's type
            var var_type *u8 = nil;
            if is_indirect == 1 {
                var local_idx i64 = find_local(func_name, func_name_len);
                if local_idx >= 0 {
                    var_type = local_get_type(local_idx);
                }
            } else {
                var global_idx i64 = find_global(func_name, func_name_len);
                if global_idx >= 0 {
                    var_type = global_get_type(global_idx);
                }
            }
            if var_type != nil {
                if is_auto_closure_type(var_type) == 1 {
                    is_closure_call = 1;
                }
            }
        }

        // Handle closure calls specially
        if is_closure_call == 1 {
            // Load closure struct pointer
            var actual_fn_name *u8 = func_name;
            var actual_fn_len i64 = func_name_len;
            if is_indirect == 1 {
                var let_entry *u8 = llvm_find_let_binding(func_name, func_name_len);
                if let_entry != nil {
                    actual_fn_name = llvm_let_unique_name(let_entry);
                    actual_fn_len = llvm_let_unique_len(let_entry);
                }
            }

            var closure_ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(closure_ptr);
            if is_indirect == 2 {
                llvm_emit_str(" = load i64, i64* @");
                llvm_emit_n(func_name, func_name_len);
            } else {
                llvm_emit_str(" = load i64, i64* %");
                llvm_emit_n(actual_fn_name, actual_fn_len);
            }
            llvm_emit_char(10);

            // Convert to i8* for GEP
            var closure_i8ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(closure_i8ptr);
            llvm_emit_str(" = inttoptr i64 %t");
            llvm_emit_int(closure_ptr);
            llvm_emit_line(" to i8*");

            // Load tag from offset 0
            var tag_ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(tag_ptr);
            llvm_emit_str(" = bitcast i8* %t");
            llvm_emit_int(closure_i8ptr);
            llvm_emit_line(" to i64*");

            var tag_val i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(tag_val);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(tag_ptr);
            llvm_emit_char(10);

            // Load fn_ptr from offset 8
            var fn_ptr_gep i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fn_ptr_gep);
            llvm_emit_str(" = getelementptr i8, i8* %t");
            llvm_emit_int(closure_i8ptr);
            llvm_emit_line(", i64 8");

            var fn_ptr_slot i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fn_ptr_slot);
            llvm_emit_str(" = bitcast i8* %t");
            llvm_emit_int(fn_ptr_gep);
            llvm_emit_line(" to i64*");

            var fn_ptr_val i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fn_ptr_val);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(fn_ptr_slot);
            llvm_emit_char(10);

            // Check tag: if tag == 0, plain call; else closure call
            var tag_cmp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(tag_cmp);
            llvm_emit_str(" = icmp eq i64 %t");
            llvm_emit_int(tag_val);
            llvm_emit_line(", 0");

            var plain_label i64 = llvm_next_label();
            var closure_label i64 = llvm_next_label();
            var merge_label i64 = llvm_next_label();

            llvm_emit_str("    br i1 %t");
            llvm_emit_int(tag_cmp);
            llvm_emit_str(", label %L");
            llvm_emit_int(plain_label);
            llvm_emit_str(", label %L");
            llvm_emit_int(closure_label);
            llvm_emit_char(10);

            // Plain function call (tag == 0)
            llvm_emit_str("L");
            llvm_emit_int(plain_label);
            llvm_emit_line(":");

            // Cast to plain function pointer
            var plain_fn_ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(plain_fn_ptr);
            llvm_emit_str(" = inttoptr i64 %t");
            llvm_emit_int(fn_ptr_val);
            llvm_emit_str(" to i64 (");
            var j i64 = 0;
            while j < arg_count {
                if j > 0 { llvm_emit_str(", "); }
                llvm_emit_str("i64");
                j = j + 1;
            }
            llvm_emit_line(")*");

            // Call without closure arg
            var plain_result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(plain_result);
            llvm_emit_str(" = call i64 %t");
            llvm_emit_int(plain_fn_ptr);
            llvm_emit_str("(");
            j = 0;
            while j < arg_count {
                if j > 0 { llvm_emit_str(", "); }
                llvm_emit_str("i64 ");
                llvm_emit_str(*(arg_vals + j));
                j = j + 1;
            }
            llvm_emit_line(")");

            llvm_emit_str("    br label %L");
            llvm_emit_int(merge_label);
            llvm_emit_char(10);

            // Closure call (tag != 0)
            llvm_emit_str("L");
            llvm_emit_int(closure_label);
            llvm_emit_line(":");

            // Cast to closure function pointer (takes i8* as first arg)
            var clos_fn_ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(clos_fn_ptr);
            llvm_emit_str(" = inttoptr i64 %t");
            llvm_emit_int(fn_ptr_val);
            llvm_emit_str(" to i64 (i8*");
            j = 0;
            while j < arg_count {
                llvm_emit_str(", i64");
                j = j + 1;
            }
            llvm_emit_line(")*");

            // Call with closure as first arg
            var clos_result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(clos_result);
            llvm_emit_str(" = call i64 %t");
            llvm_emit_int(clos_fn_ptr);
            llvm_emit_str("(i8* %t");
            llvm_emit_int(closure_i8ptr);
            j = 0;
            while j < arg_count {
                llvm_emit_str(", i64 ");
                llvm_emit_str(*(arg_vals + j));
                j = j + 1;
            }
            llvm_emit_line(")");

            llvm_emit_str("    br label %L");
            llvm_emit_int(merge_label);
            llvm_emit_char(10);

            // Merge block with phi
            llvm_emit_str("L");
            llvm_emit_int(merge_label);
            llvm_emit_line(":");

            var phi_result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(phi_result);
            llvm_emit_str(" = phi i64 [ %t");
            llvm_emit_int(plain_result);
            llvm_emit_str(", %L");
            llvm_emit_int(plain_label);
            llvm_emit_str(" ], [ %t");
            llvm_emit_int(clos_result);
            llvm_emit_str(", %L");
            llvm_emit_int(closure_label);
            llvm_emit_line(" ]");

            llvm_set_result_temp(phi_result);
            return;
        }

        // If indirect call (non-closure), load and cast the function pointer now
        if is_indirect != 0 {
            var ptr_val_str *u8 = nil;

            if is_indirect == 3 {
                // Expression-based: already have the i64 value in indirect_ptr_val
                ptr_val_str = indirect_ptr_val;
            } else {
                // Variable-based: need to load from local or global
                // Check for let binding (unique name mapping)
                var actual_fn_name *u8 = func_name;
                var actual_fn_len i64 = func_name_len;
                if is_indirect != 2 {
                    var let_entry *u8 = llvm_find_let_binding(func_name, func_name_len);
                    if let_entry != nil {
                        actual_fn_name = llvm_let_unique_name(let_entry);
                        actual_fn_len = llvm_let_unique_len(let_entry);
                    }
                }

                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                if is_indirect == 2 {
                    // Global variable
                    llvm_emit_str(" = load i64, i64* @");
                    llvm_emit_n(func_name, func_name_len);
                } else {
                    // Local variable
                    llvm_emit_str(" = load i64, i64* %");
                    llvm_emit_n(actual_fn_name, actual_fn_len);
                }
                llvm_emit_char(10);

                var buf *u8 = alloc(32);
                *buf = 37; *(buf+1) = 116;  // "%t"
                itoa(load_temp, buf + 2);
                ptr_val_str = buf;
            }

            // Cast to function pointer
            var cast_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(cast_temp);
            llvm_emit_str(" = inttoptr i64 ");
            llvm_emit_str(ptr_val_str);
            // Build function type based on arg count
            llvm_emit_str(" to i64 (");
            var j i64 = 0;
            while j < arg_count {
                if j > 0 {
                    llvm_emit_str(", ");
                }
                llvm_emit_str("i64");
                j = j + 1;
            }
            llvm_emit_line(")*");

            var buf2 *u8 = alloc(32);
            *buf2 = 37; *(buf2+1) = 116;  // "%t"
            itoa(cast_temp, buf2 + 2);
            indirect_ptr_val = buf2;
        }

        // Check if function returns void, pointer, bool, u8, or float
        var is_void i64 = llvm_func_returns_void(func_name, func_name_len);
        var is_ptr i64 = llvm_func_returns_ptr(func_name, func_name_len);
        var is_bool i64 = llvm_func_returns_bool(func_name, func_name_len);
        var is_u8 i64 = llvm_func_returns_u8(func_name, func_name_len);
        var is_f32 i64 = llvm_func_returns_f32(func_name, func_name_len);
        var is_f64 i64 = llvm_func_returns_f64(func_name, func_name_len);

        // Check if this is syscall (variadic)
        var is_syscall i64 = 0;
        if func_name_len == 7 {
            if memcmp(func_name, "syscall", 7) {
                is_syscall = 1;
            }
        }

        // Check if this is open() (variadic - mode is optional)
        var is_open i64 = 0;
        if func_name_len == 4 {
            if memcmp(func_name, "open", 4) {
                is_open = 1;
            }
        }

        // Check if this is printf() (variadic)
        var is_printf i64 = 0;
        if func_name_len == 6 {
            if memcmp(func_name, "printf", 6) {
                is_printf = 1;
            }
        }

        // For printf, convert first arg (format string) from i64 to i8* BEFORE the call
        var printf_fmt_ptr *u8 = nil;
        if is_printf && arg_count > 0 {
            var fmt_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fmt_temp);
            llvm_emit_str(" = inttoptr i64 ");
            llvm_emit_str(*(arg_vals + 0));
            llvm_emit_line(" to i8*");
            // Store the converted value for later use
            var buf *u8 = alloc(32);
            *buf = 37; *(buf+1) = 116;  // "%t"
            itoa(fmt_temp, buf + 2);
            printf_fmt_ptr = buf;
        }

        // Now emit the call with pre-computed argument values
        var call_temp i64 = 0;
        if is_indirect != 0 {
            // Indirect call through function pointer
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 ");
            llvm_emit_str(indirect_ptr_val);
            llvm_emit_str("(");
        } else if is_void {
            // Void function: no result assignment
            llvm_emit_str("    call void @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else if is_syscall {
            // Syscall is variadic: call i64 (i64, ...) @syscall(...)
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 (i64, ...) @syscall(");
        } else if is_open {
            // open() is variadic: call i64 (i64, i64, ...) @open(...)
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 (i64, i64, ...) @open(");
        } else if is_printf {
            // printf() is variadic: call i64 (i8*, ...) @printf(...)
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 (i8*, ...) @printf(");
        } else if is_ptr {
            // Pointer-returning function: call i8*
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i8* @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else if is_bool {
            // Bool-returning function: call i1
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i1 @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else if is_u8 {
            // u8-returning function: call i8
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i8 @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else if is_f32 {
            // f32-returning function: call float
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call float @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else if is_f64 {
            // f64-returning function: call double
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call double @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        } else {
            // Non-void function returning i64: assign result to temp
            call_temp = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(call_temp);
            llvm_emit_str(" = call i64 @");
            llvm_emit_n(func_name, func_name_len);
            llvm_emit_str("(");
        }

        // Limit arg count to function's declared param count to handle main() with no params
        var emit_arg_count i64 = arg_count;
        if known_func != nil {
            var declared_param_count i64 = func_decl_param_count(known_func);
            if declared_param_count < emit_arg_count {
                emit_arg_count = declared_param_count;
            }
        }

        // Get function parameters for type information
        var func_params *u8 = nil;
        if known_func != nil {
            func_params = func_decl_params(known_func);
        }

        i = 0;
        while i < emit_arg_count {
            if i > 0 {
                llvm_emit_str(", ");
            }
            // Check parameter type for proper emission
            var param_is_float i64 = 0;
            var param_is_ptr i64 = 0;
            if func_params != nil {
                var p *u8 = func_params + (i * 24);
                var ptype *u8 = param_type(p);
                if ptype != nil && llvm_is_float_type(ptype) {
                    param_is_float = 1;
                    llvm_emit_type(ptype);
                    llvm_emit_str(" ");
                } else if is_printf && i == 0 {
                    // printf first arg is format string (i8*)
                    param_is_ptr = 1;
                    llvm_emit_str("i8* ");
                }
            }
            if param_is_float == 0 && param_is_ptr == 0 {
                llvm_emit_str("i64 ");
            }
            // Use converted pointer for printf format string
            if is_printf && i == 0 && printf_fmt_ptr != nil {
                llvm_emit_str(printf_fmt_ptr);
            } else {
                llvm_emit_str(*(arg_vals + i));
            }
            i = i + 1;
        }
        llvm_emit_line(")");

        // For pointer-returning functions, convert to i64 for internal use
        if is_ptr {
            var conv_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(conv_temp);
            llvm_emit_str(" = ptrtoint i8* %t");
            llvm_emit_int(call_temp);
            llvm_emit_line(" to i64");
            call_temp = conv_temp;
        }

        // For bool-returning functions, convert i1 to i64
        if is_bool {
            var conv_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(conv_temp);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(call_temp);
            llvm_emit_line(" to i64");
            call_temp = conv_temp;
        }

        // For u8-returning functions, convert i8 to i64
        if is_u8 {
            var conv_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(conv_temp);
            llvm_emit_str(" = zext i8 %t");
            llvm_emit_int(call_temp);
            llvm_emit_line(" to i64");
            call_temp = conv_temp;
        }

        // Set result to the temp (only meaningful for non-void)
        if is_void == 0 {
            llvm_set_result_temp(call_temp);
            // Track if result is a float type
            if is_f32 || is_f64 {
                llvm_expr_is_float = 1;
            }
        }
        return;
    }

    if k == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);
        var left *u8 = binary_expr_left(expr);
        var right *u8 = binary_expr_right(expr);

        // Check for assignment first (op == 32 is TOKEN_EQ)
        if op == 32 {
            // Assignment: store to left (must be ident)
            if node_kind(left) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(left);
                var len i64 = ident_expr_name_len(left);

                // Check for let binding (unique name mapping)
                var actual_name *u8 = name;
                var actual_len i64 = len;
                var let_entry *u8 = llvm_find_let_binding(name, len);
                if let_entry != nil {
                    actual_name = llvm_let_unique_name(let_entry);
                    actual_len = llvm_let_unique_len(let_entry);
                }

                // Emit right side
                llvm_emit_expr(right);
                var val *u8 = str_dup(llvm_expr_result);

                // Check if local or global
                if llvm_is_local(name, len) {
                    llvm_emit_str("    store i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", i64* %");
                    llvm_emit_n(actual_name, actual_len);
                    llvm_emit_char(10);
                } else if llvm_is_global(name, len) {
                    llvm_emit_str("    store i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", i64* @");
                    llvm_emit_n(name, len);
                    llvm_emit_char(10);
                }

                // Assignment result is the value
                var i i64 = 0;
                while *(val + i) != 0 {
                    *(llvm_expr_result + i) = *(val + i);
                    i = i + 1;
                }
                *(llvm_expr_result + i) = 0;
                return;
            }
        }

        // Handle short-circuit && with control flow
        if op == 39 {  // TOKEN_AMPAMP (&&)
            // a && b: if a is false, result is 0, don't evaluate b
            var right_label i64 = llvm_next_label();
            var end_label i64 = llvm_next_label();

            // Allocate result slot
            var result_slot i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result_slot);
            llvm_emit_line(" = alloca i64");
            llvm_emit_str("    store i64 0, i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            // Evaluate left
            llvm_emit_expr(left);
            var left_val *u8 = str_dup(llvm_expr_result);

            // Check left - if non-zero, evaluate right
            var l_bool i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(" = icmp ne i64 ");
            llvm_emit_str(left_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    br i1 %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(", label %L");
            llvm_emit_int(right_label);
            llvm_emit_str(", label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // Right label - evaluate right and store result
            llvm_emit_str("L");
            llvm_emit_int(right_label);
            llvm_emit_line(":");
            llvm_emit_expr(right);
            var right_val *u8 = str_dup(llvm_expr_result);
            var r_bool i64 = llvm_next_temp();
            var r_ext i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(r_bool);
            llvm_emit_str(" = icmp ne i64 ");
            llvm_emit_str(right_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(r_bool);
            llvm_emit_line(" to i64");
            llvm_emit_str("    store i64 %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(", i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);
            llvm_emit_str("    br label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // End label - load result
            llvm_emit_str("L");
            llvm_emit_int(end_label);
            llvm_emit_line(":");
            var result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            llvm_set_result_temp(result);
            return;
        }

        // Handle short-circuit || with control flow
        if op == 40 {  // TOKEN_PIPEPIPE (||)
            // a || b: if a is true, result is 1, don't evaluate b
            var right_label i64 = llvm_next_label();
            var end_label i64 = llvm_next_label();

            // Allocate result slot
            var result_slot i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result_slot);
            llvm_emit_line(" = alloca i64");
            llvm_emit_str("    store i64 1, i64* %t");  // Default to 1 (true)
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            // Evaluate left
            llvm_emit_expr(left);
            var left_val *u8 = str_dup(llvm_expr_result);

            // Check left - if zero, evaluate right
            var l_bool i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(" = icmp eq i64 ");  // eq 0 means false
            llvm_emit_str(left_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    br i1 %t");
            llvm_emit_int(l_bool);
            llvm_emit_str(", label %L");
            llvm_emit_int(right_label);
            llvm_emit_str(", label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // Right label - evaluate right and store result
            llvm_emit_str("L");
            llvm_emit_int(right_label);
            llvm_emit_line(":");
            llvm_emit_expr(right);
            var right_val *u8 = str_dup(llvm_expr_result);
            var r_bool i64 = llvm_next_temp();
            var r_ext i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(r_bool);
            llvm_emit_str(" = icmp ne i64 ");
            llvm_emit_str(right_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(r_bool);
            llvm_emit_line(" to i64");
            llvm_emit_str("    store i64 %t");
            llvm_emit_int(r_ext);
            llvm_emit_str(", i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);
            llvm_emit_str("    br label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);

            // End label - load result
            llvm_emit_str("L");
            llvm_emit_int(end_label);
            llvm_emit_line(":");
            var result i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(result);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(result_slot);
            llvm_emit_char(10);

            llvm_set_result_temp(result);
            return;
        }

        // For other operations, evaluate both operands
        llvm_emit_expr(left);
        var left_val *u8 = str_dup(llvm_expr_result);

        llvm_emit_expr(right);
        var right_val *u8 = str_dup(llvm_expr_result);

        // Check operand types for float (using get_expr_type, not global tracking)
        var left_type *u8 = get_expr_type(left);
        var right_type *u8 = get_expr_type(right);
        var left_is_float i64 = left_type != nil && llvm_is_float_type(left_type);
        var right_is_float i64 = right_type != nil && llvm_is_float_type(right_type);

        // Pointer arithmetic scaling: ptr + n -> ptr + (n * sizeof(*ptr))
        if op == 25 || op == 26 {  // TOKEN_PLUS or TOKEN_MINUS
            // left_type already computed above
            if left_type != nil && type_kind(left_type) == TYPE_PTR {
                var elem_type *u8 = ptr_type_elem(left_type);
                var elem_size i64 = 8;  // default
                if elem_type != nil {
                    elem_size = get_type_size(elem_type);
                }
                if elem_size > 1 {
                    // Multiply right operand by element size
                    var scale_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(scale_temp);
                    llvm_emit_str(" = mul i64 ");
                    llvm_emit_str(right_val);
                    llvm_emit_str(", ");
                    llvm_emit_int(elem_size);
                    llvm_emit_char(10);
                    // Replace right_val with scaled value
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(scale_temp, buf + 2);
                    right_val = buf;
                }
            }
        }

        // Check if it's a comparison
        var is_cmp i64 = 0;
        if op >= 33 && op <= 38 { is_cmp = 1; }

        // Check if either operand is a float (via literal check OR tracked type)
        var is_float i64 = left_is_float || right_is_float || llvm_is_float_literal(left_val) || llvm_is_float_literal(right_val);

        // Allocate temp for result
        var temp i64 = llvm_next_temp();

        if is_cmp == 1 {
            // Comparison: icmp/fcmp returns i1, extend to i64
            var cmp_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(cmp_temp);

            if is_float == 1 {
                // Float comparison: fcmp with ordered predicates
                llvm_emit_str(" = fcmp ");
                if op == 33 { llvm_emit_str("oeq"); }       // == (ordered equal)
                else if op == 34 { llvm_emit_str("one"); }  // != (ordered not equal)
                else if op == 35 { llvm_emit_str("olt"); }  // < (ordered less than)
                else if op == 36 { llvm_emit_str("ogt"); }  // > (ordered greater than)
                else if op == 37 { llvm_emit_str("ole"); }  // <= (ordered less or equal)
                else if op == 38 { llvm_emit_str("oge"); }  // >= (ordered greater or equal)
                llvm_emit_str(" double ");
            } else {
                // Integer comparison
                // Check if either operand is unsigned (or pointer - addresses are unsigned)
                var left_unsigned i64 = llvm_is_unsigned_int(left_type) || (left_type != nil && type_kind(left_type) == TYPE_PTR);
                var right_unsigned i64 = llvm_is_unsigned_int(right_type) || (right_type != nil && type_kind(right_type) == TYPE_PTR);
                var use_unsigned i64 = left_unsigned || right_unsigned;

                llvm_emit_str(" = icmp ");
                if op == 33 { llvm_emit_str("eq"); }       // == (same for signed/unsigned)
                else if op == 34 { llvm_emit_str("ne"); }  // != (same for signed/unsigned)
                else if op == 35 {
                    if use_unsigned { llvm_emit_str("ult"); } else { llvm_emit_str("slt"); }
                }
                else if op == 36 {
                    if use_unsigned { llvm_emit_str("ugt"); } else { llvm_emit_str("sgt"); }
                }
                else if op == 37 {
                    if use_unsigned { llvm_emit_str("ule"); } else { llvm_emit_str("sle"); }
                }
                else if op == 38 {
                    if use_unsigned { llvm_emit_str("uge"); } else { llvm_emit_str("sge"); }
                }
                llvm_emit_str(" i64 ");
            }

            llvm_emit_str(left_val);
            llvm_emit_str(", ");
            llvm_emit_str(right_val);
            llvm_emit_char(10);

            // Extend i1 to i64
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_line(" to i64");
        } else if is_float == 1 {
            // Float arithmetic
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = ");

            if op == 25 {  // TOKEN_PLUS
                llvm_emit_str("fadd");
            } else if op == 26 {  // TOKEN_MINUS
                llvm_emit_str("fsub");
            } else if op == 27 {  // TOKEN_STAR
                llvm_emit_str("fmul");
            } else if op == 28 {  // TOKEN_SLASH
                llvm_emit_str("fdiv");
            } else if op == 29 {  // TOKEN_PERCENT
                llvm_emit_str("frem");  // Float remainder
            } else {
                llvm_emit_str("fadd");  // Default
            }

            llvm_emit_str(" double ");
            llvm_emit_str(left_val);
            llvm_emit_str(", ");
            llvm_emit_str(right_val);
            llvm_emit_char(10);
        } else {
            // Integer arithmetic
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = ");

            if op == 25 {  // TOKEN_PLUS
                llvm_emit_str("add");
            } else if op == 26 {  // TOKEN_MINUS
                llvm_emit_str("sub");
            } else if op == 27 {  // TOKEN_STAR
                llvm_emit_str("mul");
            } else if op == 28 {  // TOKEN_SLASH
                llvm_emit_str("sdiv");
            } else if op == 29 {  // TOKEN_PERCENT
                llvm_emit_str("srem");
            } else if op == 62 {  // TOKEN_LTLT (<<)
                llvm_emit_str("shl");
            } else if op == 63 {  // TOKEN_GTGT (>>)
                llvm_emit_str("ashr");
            } else if op == 30 {  // TOKEN_AMP (&)
                llvm_emit_str("and");
            } else if op == 60 {  // TOKEN_PIPE (|)
                llvm_emit_str("or");
            } else if op == 61 {  // TOKEN_CARET (^)
                llvm_emit_str("xor");
            } else {
                llvm_emit_str("add");  // Default
            }

            llvm_emit_str(" i64 ");
            llvm_emit_str(left_val);
            llvm_emit_str(", ");
            llvm_emit_str(right_val);
            llvm_emit_char(10);
        }

        // Set result
        llvm_set_result_temp(temp);
        return;
    }

    if k == NODE_GROUP_EXPR {
        // Parenthesized expression - just emit the inner expression
        llvm_emit_expr(group_expr_expr(expr));
        return;
    }

    // Cast expression: (cast type expr)
    if k == NODE_CAST_EXPR {
        var target_type *u8 = cast_expr_type(expr);
        var src_expr *u8 = cast_expr_expr(expr);

        // Emit source expression
        llvm_emit_expr(src_expr);
        var src_val *u8 = str_dup(llvm_expr_result);
        var src_was_float i64 = llvm_expr_is_float;

        // Get type info
        var src_type *u8 = llvm_get_expr_type(src_expr);
        var src_bits i64 = llvm_type_bits(src_type);
        var dst_bits i64 = llvm_type_bits(target_type);
        var src_is_float i64 = llvm_is_float_type(src_type);
        var dst_is_float i64 = llvm_is_float_type(target_type);
        var src_is_signed i64 = llvm_is_signed_int(src_type);
        var dst_is_signed i64 = llvm_is_signed_int(target_type);

        var temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(temp);
        llvm_emit_str(" = ");

        // Determine the cast instruction
        if src_is_float && !dst_is_float {
            // Float to int
            if dst_is_signed {
                llvm_emit_str("fptosi ");
            } else {
                llvm_emit_str("fptoui ");
            }
            llvm_emit_type(src_type);
            llvm_emit_str(" ");
            llvm_emit_str(src_val);
            llvm_emit_str(" to ");
            llvm_emit_type(target_type);
        } else if !src_is_float && dst_is_float {
            // Int to float
            if src_is_signed {
                llvm_emit_str("sitofp ");
            } else {
                llvm_emit_str("uitofp ");
            }
            llvm_emit_type(src_type);
            llvm_emit_str(" ");
            llvm_emit_str(src_val);
            llvm_emit_str(" to ");
            llvm_emit_type(target_type);
        } else if src_is_float && dst_is_float {
            // Float to float
            if dst_bits > src_bits {
                llvm_emit_str("fpext ");
            } else {
                llvm_emit_str("fptrunc ");
            }
            llvm_emit_type(src_type);
            llvm_emit_str(" ");
            llvm_emit_str(src_val);
            llvm_emit_str(" to ");
            llvm_emit_type(target_type);
        } else {
            // Int to int
            if dst_bits > src_bits {
                // Widening
                if src_is_signed {
                    llvm_emit_str("sext ");
                } else {
                    llvm_emit_str("zext ");
                }
            } else if dst_bits < src_bits {
                // Truncation
                llvm_emit_str("trunc ");
            } else {
                // Same size - no conversion needed, just copy
                // But we still need valid LLVM IR, use add with 0
                llvm_emit_str("add ");
                llvm_emit_type(src_type);
                llvm_emit_str(" ");
                llvm_emit_str(src_val);
                llvm_emit_line(", 0");
                llvm_set_result_temp(temp);
                if dst_is_float {
                    llvm_expr_is_float = 1;
                }
                return;
            }
            llvm_emit_type(src_type);
            llvm_emit_str(" ");
            llvm_emit_str(src_val);
            llvm_emit_str(" to ");
            llvm_emit_type(target_type);
        }

        llvm_emit_char(10);
        llvm_set_result_temp(temp);
        if dst_is_float {
            llvm_expr_is_float = 1;
        }
        return;
    }

    // Bitcast expression: (bitcast type expr) - reinterpret bits
    if k == NODE_BITCAST_EXPR {
        var target_type *u8 = bitcast_expr_type(expr);
        var src_expr *u8 = bitcast_expr_expr(expr);

        // Emit source expression
        llvm_emit_expr(src_expr);
        var src_val *u8 = str_dup(llvm_expr_result);

        // Get source type
        var src_type *u8 = llvm_get_expr_type(src_expr);

        var temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(temp);
        llvm_emit_str(" = bitcast ");
        llvm_emit_type(src_type);
        llvm_emit_str(" ");
        llvm_emit_str(src_val);
        llvm_emit_str(" to ");
        llvm_emit_type(target_type);
        llvm_emit_char(10);

        llvm_set_result_temp(temp);
        if llvm_is_float_type(target_type) {
            llvm_expr_is_float = 1;
        }
        return;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        var inner *u8 = unary_expr_expr(expr);

        // Handle address-of specially - don't evaluate inner, just get its address
        if op == 30 {  // TOKEN_AMP (address-of &x)
            var temp i64 = llvm_next_temp();
            if node_kind(inner) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(inner);
                var len i64 = ident_expr_name_len(inner);

                // Check if it's a function name
                var func_decl *u8 = find_func(name, len);
                if func_decl != nil {
                    // Function address: ptrtoint func_type* @funcname to i64
                    // Get function parameter count for type signature
                    var param_count i64 = func_decl_param_count(func_decl);
                    var ret_type *u8 = func_decl_ret_type(func_decl);

                    llvm_emit_str("    %t");
                    llvm_emit_int(temp);
                    llvm_emit_str(" = ptrtoint ");
                    // Emit return type: void or i64
                    if llvm_is_void_type(ret_type) {
                        llvm_emit_str("void");
                    } else {
                        llvm_emit_str("i64");
                    }
                    llvm_emit_str(" (");
                    var j i64 = 0;
                    while j < param_count {
                        if j > 0 {
                            llvm_emit_str(", ");
                        }
                        llvm_emit_str("i64");
                        j = j + 1;
                    }
                    llvm_emit_str(")* @");
                    llvm_emit_n(name, len);
                    llvm_emit_line(" to i64");
                    llvm_set_result_temp(temp);
                } else {
                    // Check if inner is a struct or enum type (needs different LLVM type)
                    var inner_type *u8 = get_expr_type(inner);
                    var alloc_size i64 = 0;
                    if inner_type != nil && type_kind(inner_type) == TYPE_BASE {
                        var type_name *u8 = base_type_name(inner_type);
                        var type_name_len i64 = base_type_name_len(inner_type);
                        var struct_decl *u8 = find_struct(type_name, type_name_len);
                        if struct_decl != nil {
                            alloc_size = get_struct_size(struct_decl);
                        } else {
                            // Check if it's an enum type
                            var enum_decl *u8 = find_enum(type_name, type_name_len);
                            if enum_decl != nil {
                                alloc_size = get_enum_size(enum_decl);
                            }
                        }
                    }

                    // Check for let binding (unique name for aggregate vars)
                    var actual_name *u8 = name;
                    var actual_name_len i64 = len;
                    var let_entry *u8 = llvm_find_let_binding(name, len);
                    if let_entry != nil {
                        actual_name = llvm_let_unique_name(let_entry);
                        actual_name_len = llvm_let_unique_len(let_entry);
                    }

                    // ptrtoint converts pointer to integer
                    llvm_emit_str("    %t");
                    llvm_emit_int(temp);
                    if alloc_size > 8 {
                        llvm_emit_str(" = ptrtoint [");
                        llvm_emit_int(alloc_size);
                        llvm_emit_str(" x i8]* %");
                    } else {
                        llvm_emit_str(" = ptrtoint i64* %");
                    }
                    llvm_emit_n(actual_name, actual_name_len);
                    llvm_emit_line(" to i64");
                    llvm_set_result_temp(temp);
                }
            } else if node_kind(inner) == NODE_FIELD_EXPR {
                // &struct.field - need to compute address without loading value
                var base_expr *u8 = field_expr_expr(inner);
                var field_name *u8 = field_expr_field(inner);
                var field_len i64 = field_expr_field_len(inner);

                // Get type of base to find struct
                var base_type *u8 = get_expr_type(base_expr);
                var struct_name *u8 = nil;
                var struct_name_len i64 = 0;
                var is_pointer i64 = 0;

                if base_type != nil {
                    if type_kind(base_type) == TYPE_BASE {
                        struct_name = base_type_name(base_type);
                        struct_name_len = base_type_name_len(base_type);
                    } else if type_kind(base_type) == TYPE_PTR {
                        var pointed_type *u8 = ptr_type_elem(base_type);
                        if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                            struct_name = base_type_name(pointed_type);
                            struct_name_len = base_type_name_len(pointed_type);
                            is_pointer = 1;
                        }
                    }
                }

                if struct_name != nil {
                    var struct_decl *u8 = find_struct(struct_name, struct_name_len);
                    if struct_decl != nil {
                        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
                        var struct_size i64 = get_struct_size(struct_decl);

                        if is_pointer != 0 {
                            // Pointer to struct - evaluate to get pointer
                            llvm_emit_expr(base_expr);
                            var ptr_val *u8 = str_dup(llvm_expr_result);

                            // Add field offset
                            if field_offset > 0 {
                                var offset_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(offset_temp);
                                llvm_emit_str(" = add i64 ");
                                llvm_emit_str(ptr_val);
                                llvm_emit_str(", ");
                                llvm_emit_int(field_offset);
                                llvm_emit_char(10);
                                llvm_set_result_temp(offset_temp);
                            } else {
                                llvm_set_result_str(ptr_val);
                            }
                        } else {
                            // Direct struct - get address of local variable
                            if node_kind(base_expr) == NODE_IDENT_EXPR {
                                var name *u8 = ident_expr_name(base_expr);
                                var name_len i64 = ident_expr_name_len(base_expr);

                                var actual_name *u8 = name;
                                var actual_name_len i64 = name_len;
                                var let_entry *u8 = llvm_find_let_binding(name, name_len);
                                if let_entry != nil {
                                    actual_name = llvm_let_unique_name(let_entry);
                                    actual_name_len = llvm_let_unique_len(let_entry);
                                }

                                // ptrtoint the local variable address
                                var addr_temp i64 = llvm_next_temp();
                                llvm_emit_str("    %t");
                                llvm_emit_int(addr_temp);
                                llvm_emit_str(" = ptrtoint [");
                                llvm_emit_int(struct_size);
                                llvm_emit_str(" x i8]* %");
                                llvm_emit_n(actual_name, actual_name_len);
                                llvm_emit_line(" to i64");

                                // Add field offset
                                if field_offset > 0 {
                                    var offset_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(offset_temp);
                                    llvm_emit_str(" = add i64 %t");
                                    llvm_emit_int(addr_temp);
                                    llvm_emit_str(", ");
                                    llvm_emit_int(field_offset);
                                    llvm_emit_char(10);
                                    llvm_set_result_temp(offset_temp);
                                } else {
                                    llvm_set_result_temp(addr_temp);
                                }
                            }
                        }
                    }
                }
            } else {
                // For other cases (like &*ptr), evaluate inner
                llvm_emit_expr(inner);
            }
            return;
        }

        // For other unary ops, evaluate inner first
        llvm_emit_expr(inner);
        var inner_val *u8 = str_dup(llvm_expr_result);

        var temp i64 = llvm_next_temp();

        if op == 26 {  // TOKEN_MINUS (negation)
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = sub i64 0, ");
            llvm_emit_str(inner_val);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        } else if op == 31 {  // TOKEN_BANG (logical not)
            // Compare to 0, result is 1 if equal (was false), 0 otherwise
            var cmp_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_str(" = icmp eq i64 ");
            llvm_emit_str(inner_val);
            llvm_emit_line(", 0");
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = zext i1 %t");
            llvm_emit_int(cmp_temp);
            llvm_emit_line(" to i64");
            llvm_set_result_temp(temp);
        } else if op == 27 {  // TOKEN_STAR (dereference *p)
            // Get the type of what we're dereferencing
            var ptr_type *u8 = get_expr_type(inner);
            var elem_type *u8 = get_pointed_type(ptr_type);
            var size i64 = 8;
            if elem_type != nil {
                size = get_type_size(elem_type);
            }

            var ptr_temp i64 = llvm_next_temp();

            if size == 1 {
                // Load i8, then zext to i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i8*");
                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i8, i8* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = zext i8 %t");
                llvm_emit_int(load_temp);
                llvm_emit_line(" to i64");
            } else if size == 2 {
                // Load i16, then zext to i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i16*");
                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i16, i16* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = zext i16 %t");
                llvm_emit_int(load_temp);
                llvm_emit_line(" to i64");
            } else if size == 4 {
                // Load i32, then zext to i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i32*");
                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i32, i32* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = zext i32 %t");
                llvm_emit_int(load_temp);
                llvm_emit_line(" to i64");
            } else {
                // Default: load i64
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(inner_val);
                llvm_emit_line(" to i64*");
                llvm_emit_str("    %t");
                llvm_emit_int(temp);
                llvm_emit_str(" = load i64, i64* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);
            }
            llvm_set_result_temp(temp);
        } else {
            // Unknown unary op, just pass through
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = add i64 0, ");
            llvm_emit_str(inner_val);
            llvm_emit_char(10);
            llvm_set_result_temp(temp);
        }
        return;
    }

    if k == NODE_LET_EXPR {
        // Save local scope for restoration after body
        var saved_local_count i64 = cg_local_count;

        var name *u8 = let_expr_name(expr);
        var name_len i64 = let_expr_name_len(expr);
        var var_type *u8 = let_expr_type(expr);

        // Generate unique name for this let binding (SSA requires unique names)
        var let_id i64 = llvm_next_temp();
        var unique_name *u8 = alloc(64);
        var pos i64 = 0;
        var i i64 = 0;
        while i < name_len {
            *(unique_name + pos) = *(name + i);
            pos = pos + 1;
            i = i + 1;
        }
        *(unique_name + pos) = 46;  // '.'
        pos = pos + 1;
        // Append number
        var tmp *u8 = alloc(16);
        itoa(let_id, tmp);
        i = 0;
        while *(tmp + i) != 0 {
            *(unique_name + pos) = *(tmp + i);
            pos = pos + 1;
            i = i + 1;
        }
        *(unique_name + pos) = 0;
        var unique_len i64 = pos;

        // Register type info for get_expr_type
        add_local(name, name_len, 0, var_type);

        // Push let binding for name->unique_name mapping
        llvm_push_let_binding(name, name_len, unique_name, unique_len);

        // Allocate stack slot for let binding - use proper type for floats
        llvm_emit_str("    %");
        llvm_emit_n(unique_name, unique_len);
        llvm_emit_str(" = alloca ");
        if var_type != nil && llvm_is_float_type(var_type) {
            llvm_emit_type(var_type);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_char(10);

        // Generate init expression
        llvm_emit_expr(let_expr_init(expr));
        var init_val *u8 = str_dup(llvm_expr_result);

        // Store init value - use proper type for floats
        llvm_emit_str("    store ");
        if var_type != nil && llvm_is_float_type(var_type) {
            llvm_emit_type(var_type);
            llvm_emit_str(" ");
            llvm_emit_str(init_val);
            llvm_emit_str(", ");
            llvm_emit_type(var_type);
            llvm_emit_str("* %");
        } else {
            llvm_emit_str("i64 ");
            llvm_emit_str(init_val);
            llvm_emit_str(", i64* %");
        }
        llvm_emit_n(unique_name, unique_len);
        llvm_emit_char(10);

        // Generate body expression (result becomes the let expression's result)
        llvm_emit_expr(let_expr_body(expr));

        // Pop let binding and restore local scope
        llvm_pop_let_binding();
        cg_local_count = saved_local_count;
        return;
    }

    if k == NODE_INDEX_EXPR {
        // arr[i] - compute address and load value
        // IndexExpr: [kind:8][base:8][index:8]
        var base_p **u8 = expr + 8;
        var index_p **u8 = expr + 16;
        var base_expr *u8 = *base_p;
        var index_expr *u8 = *index_p;

        var base_type *u8 = llvm_get_expr_type(base_expr);

        // Get element type
        var elem_type *u8 = nil;
        var is_array i64 = 0;
        if base_type != nil {
            if type_kind(base_type) == TYPE_ARRAY {
                elem_type = array_type_elem(base_type);
                is_array = 1;
            } else if type_kind(base_type) == TYPE_PTR {
                elem_type = ptr_type_elem(base_type);
            }
        }

        // Emit index expression first
        llvm_emit_expr(index_expr);
        var index_val *u8 = str_dup(llvm_expr_result);

        // Get base address
        if is_array == 1 {
            // For arrays, get pointer to array
            llvm_emit_array_addr(base_expr);
        } else {
            // For pointers, get the pointer value
            llvm_emit_expr(base_expr);
        }
        var base_val *u8 = str_dup(llvm_expr_result);

        // Use getelementptr to compute address
        var gep_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(gep_temp);
        llvm_emit_str(" = getelementptr ");
        if elem_type != nil {
            llvm_emit_type(elem_type);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str(", ");
        if elem_type != nil {
            llvm_emit_type(elem_type);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str("* ");
        llvm_emit_str(base_val);
        llvm_emit_str(", i64 ");
        llvm_emit_str(index_val);
        llvm_emit_line("");

        // Load value from computed address
        var load_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(load_temp);
        llvm_emit_str(" = load ");
        if elem_type != nil {
            llvm_emit_type(elem_type);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str(", ");
        if elem_type != nil {
            llvm_emit_type(elem_type);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str("* %t");
        llvm_emit_int(gep_temp);
        llvm_emit_line("");

        // Convert result to i64 for uniform handling
        var elem_size i64 = 8;
        if elem_type != nil {
            elem_size = get_type_size(elem_type);
        }

        // If element is pointer type, convert to i64 with ptrtoint
        if elem_type != nil && type_kind(elem_type) == TYPE_PTR {
            var ptrtoint_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(ptrtoint_temp);
            llvm_emit_str(" = ptrtoint i8* %t");
            llvm_emit_int(load_temp);
            llvm_emit_line(" to i64");
            llvm_set_result_temp(ptrtoint_temp);
        } else if elem_size < 8 {
            // Zero-extend small types to i64
            var zext_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(zext_temp);
            llvm_emit_str(" = zext ");
            llvm_emit_type(elem_type);
            llvm_emit_str(" %t");
            llvm_emit_int(load_temp);
            llvm_emit_line(" to i64");
            llvm_set_result_temp(zext_temp);
        } else {
            llvm_set_result_temp(load_temp);
        }
        return;
    }

    if k == NODE_FIELD_EXPR {
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Check for enum unit variant construction: EnumName.Variant
        if node_kind(base_expr) == NODE_IDENT_EXPR {
            var enum_name *u8 = ident_expr_name(base_expr);
            var enum_name_len i64 = ident_expr_name_len(base_expr);
            var enum_decl *u8 = find_enum(enum_name, enum_name_len);

            if enum_decl != nil {
                // Find the variant
                var variant *u8 = find_variant(enum_decl, field_name, field_len);
                if variant == nil {
                    eprint("error: enum '");
                    eprint_buf(enum_name, enum_name_len);
                    eprint("' has no variant '");
                    eprint_buf(field_name, field_len);
                    eprintln("'");
                    return;
                }

                // Allocate space for enum on stack
                var enum_size i64 = get_enum_size(enum_decl);
                var enum_var *u8 = llvm_alloc_local_size(enum_size);

                // Build the type string for ptrtoint (e.g., "[16 x i8]*")
                var type_str *u8 = alloc(32);
                var tp *u8 = type_str;
                *tp = 91; tp = tp + 1;  // [
                itoa(enum_size, tp);
                tp = tp + strlen(tp);
                *tp = 32; tp = tp + 1;  // space
                *tp = 120; tp = tp + 1;  // x
                *tp = 32; tp = tp + 1;  // space
                *tp = 105; tp = tp + 1;  // i
                *tp = 56; tp = tp + 1;   // 8
                *tp = 93; tp = tp + 1;   // ]
                *tp = 42; tp = tp + 1;   // *
                *tp = 0;

                // Set tag
                var tag i64 = enum_variant_tag(variant);
                var tag_ptr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(tag_ptr_temp);
                llvm_emit_str(" = ptrtoint ");
                llvm_emit_str(type_str);
                llvm_emit_str(" ");
                llvm_emit_str(enum_var);
                llvm_emit_line(" to i64");

                var tag_store_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(tag_store_temp);
                llvm_emit_str(" = inttoptr i64 %t");
                llvm_emit_int(tag_ptr_temp);
                llvm_emit_line(" to i64*");

                llvm_emit_str("    store i64 ");
                llvm_emit_int(tag);
                llvm_emit_str(", i64* %t");
                llvm_emit_int(tag_store_temp);
                llvm_emit_char(10);

                // Zero out payload slot (for safety)
                var payload_ptr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(payload_ptr_temp);
                llvm_emit_str(" = add i64 %t");
                llvm_emit_int(tag_ptr_temp);
                llvm_emit_line(", 8");

                var payload_store_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(payload_store_temp);
                llvm_emit_str(" = inttoptr i64 %t");
                llvm_emit_int(payload_ptr_temp);
                llvm_emit_line(" to i64*");

                llvm_emit_str("    store i64 0, i64* %t");
                llvm_emit_int(payload_store_temp);
                llvm_emit_char(10);

                // Return pointer to enum value
                llvm_set_result_temp(tag_ptr_temp);
                return;
            }
        }

        // Get type of base expression to find struct
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            llvm_set_result_int(0);
            return;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;
        var is_pointer i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
                is_pointer = 1;
            }
        }

        if struct_name == nil {
            llvm_set_result_int(0);
            return;
        }

        // Find struct and get field offset
        var struct_decl *u8 = find_struct(struct_name, struct_name_len);
        if struct_decl == nil {
            llvm_set_result_int(0);
            return;
        }

        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
        if field_offset < 0 {
            llvm_set_result_int(0);
            return;
        }

        // Check if field type is itself a struct (not a pointer to struct)
        // If so, we return the address (for nested field access), not load a value
        var field_type *u8 = get_field_type(struct_decl, field_name, field_len);
        var field_is_struct i64 = 0;
        if field_type != nil && type_kind(field_type) == TYPE_BASE {
            var ft_name *u8 = base_type_name(field_type);
            var ft_name_len i64 = base_type_name_len(field_type);
            var ft_struct *u8 = find_struct(ft_name, ft_name_len);
            if ft_struct != nil {
                field_is_struct = 1;
            }
        }

        // Get base address
        if is_pointer != 0 {
            // Pointer to struct - evaluate to get address
            llvm_emit_expr(base_expr);
            var ptr_val *u8 = str_dup(llvm_expr_result);

            // Add offset if needed
            var addr_val *u8 = ptr_val;
            if field_offset > 0 {
                var offset_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(offset_temp);
                llvm_emit_str(" = add i64 ");
                llvm_emit_str(ptr_val);
                llvm_emit_str(", ");
                llvm_emit_int(field_offset);
                llvm_emit_char(10);
                var buf *u8 = alloc(32);
                *buf = 37; *(buf+1) = 116;  // "%t"
                itoa(offset_temp, buf + 2);
                addr_val = buf;
            }

            // If field is a struct, return address; otherwise load value
            if field_is_struct != 0 {
                // Return address for nested struct access
                llvm_set_result_str(addr_val);
            } else {
                // Load value from field
                var ptr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(addr_val);
                llvm_emit_line(" to i64*");

                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i64, i64* %t");
                llvm_emit_int(ptr_temp);
                llvm_emit_char(10);

                llvm_set_result_temp(load_temp);
            }
        } else {
            // Direct struct - base is the local variable, need its address
            if node_kind(base_expr) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(base_expr);
                var name_len i64 = ident_expr_name_len(base_expr);

                // Check for let binding (unique names for match bindings)
                var actual_name *u8 = name;
                var actual_name_len i64 = name_len;
                var let_entry *u8 = llvm_find_let_binding(name, name_len);
                if let_entry != nil {
                    actual_name = llvm_let_unique_name(let_entry);
                    actual_name_len = llvm_let_unique_len(let_entry);
                }

                // Get address of struct and add offset
                var addr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(addr_temp);
                llvm_emit_str(" = ptrtoint [");
                // Get struct size
                var struct_size i64 = get_struct_size(struct_decl);
                llvm_emit_int(struct_size);
                llvm_emit_str(" x i8]* %");
                llvm_emit_n(actual_name, actual_name_len);
                llvm_emit_line(" to i64");

                // Add offset
                var addr_val *u8 = nil;
                if field_offset > 0 {
                    var offset_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(offset_temp);
                    llvm_emit_str(" = add i64 %t");
                    llvm_emit_int(addr_temp);
                    llvm_emit_str(", ");
                    llvm_emit_int(field_offset);
                    llvm_emit_char(10);
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(offset_temp, buf + 2);
                    addr_val = buf;
                } else {
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(addr_temp, buf + 2);
                    addr_val = buf;
                }

                // If field is a struct, return address; otherwise load value
                if field_is_struct != 0 {
                    // Return address for nested struct access
                    llvm_set_result_str(addr_val);
                } else {
                    // Load value from field
                    var ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(addr_val);
                    llvm_emit_line(" to i64*");

                    var load_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(load_temp);
                    llvm_emit_str(" = load i64, i64* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);

                    llvm_set_result_temp(load_temp);
                }
            } else {
                // Nested field access - evaluate base, load field
                llvm_emit_expr(base_expr);
                var base_val *u8 = str_dup(llvm_expr_result);

                // Add offset
                var addr_val *u8 = base_val;
                if field_offset > 0 {
                    var offset_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(offset_temp);
                    llvm_emit_str(" = add i64 ");
                    llvm_emit_str(base_val);
                    llvm_emit_str(", ");
                    llvm_emit_int(field_offset);
                    llvm_emit_char(10);
                    var buf *u8 = alloc(32);
                    *buf = 37; *(buf+1) = 116;  // "%t"
                    itoa(offset_temp, buf + 2);
                    addr_val = buf;
                }

                // If field is a struct, return address; otherwise load value
                if field_is_struct != 0 {
                    // Return address for nested struct access
                    llvm_set_result_str(addr_val);
                } else {
                    // Load value from field
                    var ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(addr_val);
                    llvm_emit_line(" to i64*");

                    var load_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(load_temp);
                    llvm_emit_str(" = load i64, i64* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);

                    llvm_set_result_temp(load_temp);
                }
            }
        }
        return;
    }

    if k == NODE_READER_EXPR {
        // Reader macro invocation
        var name *u8 = reader_expr_name(expr);
        var name_len i64 = reader_expr_name_len(expr);
        var content *u8 = reader_expr_content(expr);
        var content_len i64 = reader_expr_content_len(expr);

        // First check for embedded reader function (composed compilers)
        var reader_func *u8 = find_embedded_reader_func(name, name_len);
        if reader_func != nil {
            // Call embedded reader function directly
            var output *u8 = reader_func(content, content_len);
            if output != nil {
                var expanded *u8 = parse_ast_expression_from_string(output);
                if expanded != nil {
                    llvm_emit_expr(expanded);
                }
            }
            return;
        }

        // Fall back to external executable
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            eprint("error: reader macro '");
            eprint_buf(name, name_len);
            eprintln("' not found");
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = build_reader_cache_path(name, name_len);

        // Execute reader with content as input
        var output *u8 = alloc(65536);
        var n i64 = exec_capture(exe_path, content, content_len, output, 65536);

        if n <= 0 {
            eprint("error: reader '");
            eprint_buf(name, name_len);
            eprintln("' returned no output");
            return;
        }

        // Parse the output as S-expr AST expression (readers MUST output AST)
        var expanded *u8 = parse_ast_expression_from_string(output);
        if expanded != nil {
            llvm_emit_expr(expanded);
        }
        return;
    }

    if k == NODE_LAMBDA_EXPR {
        // Register lambda for later emission
        var lambda_id i64 = llvm_lambda_count;
        var param_count i64 = lambda_expr_param_count(expr);

        // Analyze captures using functions from codegen.lang
        var capture_count i64 = analyze_lambda_captures(expr, param_count);

        // Copy captures array for this lambda (so it persists)
        var captures_copy *u8 = nil;
        if capture_count > 0 {
            captures_copy = alloc(capture_count * 32);
            var i i64 = 0;
            while i < capture_count {
                var src *u8 = cg_current_captures + (i * 32);
                var dst *u8 = captures_copy + (i * 32);
                // Copy 32 bytes (4 x i64 fields)
                var j i64 = 0;
                while j < 32 {
                    *(dst + j) = *(src + j);
                    j = j + 1;
                }
                i = i + 1;
            }
        }

        // Store lambda info
        var entry *u8 = llvm_lambdas + (llvm_lambda_count * 32);
        var p_node **u8 = entry;
        *p_node = expr;
        var p_id *i64 = entry + 8;
        *p_id = lambda_id;
        var p_captures **u8 = entry + 16;
        *p_captures = captures_copy;
        var p_cap_count *i64 = entry + 24;
        *p_cap_count = capture_count;
        llvm_lambda_count = llvm_lambda_count + 1;

        if capture_count == 0 {
            // No captures - just return function pointer
            var temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(temp);
            llvm_emit_str(" = ptrtoint i64 (");
            var j i64 = 0;
            while j < param_count {
                if j > 0 {
                    llvm_emit_str(", ");
                }
                llvm_emit_str("i64");
                j = j + 1;
            }
            llvm_emit_str(")* @__lambda_");
            llvm_emit_int(lambda_id);
            llvm_emit_line(" to i64");
            llvm_set_result_temp(temp);
        } else {
            // Has captures - allocate closure struct
            // Layout: [tag:8][fn_ptr:8][capture0:8][capture1:8]...
            var closure_size i64 = 16 + (capture_count * 8);

            // Call alloc to get closure memory (returns i8*)
            var alloc_ptr_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(alloc_ptr_temp);
            llvm_emit_str(" = call i8* @alloc(i64 ");
            llvm_emit_int(closure_size);
            llvm_emit_line(")");

            // Convert pointer to i64
            var alloc_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(alloc_temp);
            llvm_emit_str(" = ptrtoint i8* %t");
            llvm_emit_int(alloc_ptr_temp);
            llvm_emit_line(" to i64");

            // Store tag = 1 at offset 0 (cast i8* to i64*)
            var tag_ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(tag_ptr);
            llvm_emit_str(" = bitcast i8* %t");
            llvm_emit_int(alloc_ptr_temp);
            llvm_emit_line(" to i64*");
            llvm_emit_str("    store i64 1, i64* %t");
            llvm_emit_int(tag_ptr);
            llvm_emit_char(10);

            // Store function pointer at offset 8
            var fn_ptr_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fn_ptr_temp);
            llvm_emit_str(" = ptrtoint i64 (i8*");
            var j i64 = 0;
            while j < param_count {
                llvm_emit_str(", i64");
                j = j + 1;
            }
            llvm_emit_str(")* @__lambda_");
            llvm_emit_int(lambda_id);
            llvm_emit_line(" to i64");

            var fn_slot_addr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fn_slot_addr);
            llvm_emit_str(" = add i64 %t");
            llvm_emit_int(alloc_temp);
            llvm_emit_line(", 8");
            var fn_slot_ptr i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(fn_slot_ptr);
            llvm_emit_str(" = inttoptr i64 %t");
            llvm_emit_int(fn_slot_addr);
            llvm_emit_line(" to i64*");
            llvm_emit_str("    store i64 %t");
            llvm_emit_int(fn_ptr_temp);
            llvm_emit_str(", i64* %t");
            llvm_emit_int(fn_slot_ptr);
            llvm_emit_char(10);

            // Copy captured values into closure
            var i i64 = 0;
            while i < capture_count {
                var cap_entry *u8 = captures_copy + (i * 32);
                var p_name **u8 = cap_entry;
                var cap_name *u8 = *p_name;
                var p_len *i64 = cap_entry + 8;
                var cap_len i64 = *p_len;
                var p_offset *i64 = cap_entry + 16;
                var outer_offset i64 = *p_offset;

                var cap_offset i64 = 16 + (i * 8);

                // Load captured value from outer scope
                // First check let bindings for unique name
                var actual_name *u8 = cap_name;
                var actual_len i64 = cap_len;
                var let_entry *u8 = llvm_find_let_binding(cap_name, cap_len);
                if let_entry != nil {
                    actual_name = llvm_let_unique_name(let_entry);
                    actual_len = llvm_let_unique_len(let_entry);
                }

                var load_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(" = load i64, i64* %");
                llvm_emit_n(actual_name, actual_len);
                llvm_emit_char(10);

                // Store into closure at offset
                var cap_addr i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(cap_addr);
                llvm_emit_str(" = add i64 %t");
                llvm_emit_int(alloc_temp);
                llvm_emit_str(", ");
                llvm_emit_int(cap_offset);
                llvm_emit_char(10);
                var cap_ptr i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(cap_ptr);
                llvm_emit_str(" = inttoptr i64 %t");
                llvm_emit_int(cap_addr);
                llvm_emit_line(" to i64*");
                llvm_emit_str("    store i64 %t");
                llvm_emit_int(load_temp);
                llvm_emit_str(", i64* %t");
                llvm_emit_int(cap_ptr);
                llvm_emit_char(10);

                i = i + 1;
            }

            // Return closure pointer
            llvm_set_result_temp(alloc_temp);
        }
        return;
    }

    if k == NODE_BLOCK_EXPR {
        // Block expression: { stmts; tail_expr }
        // Evaluates to the tail expression's value
        var stmts *u8 = block_expr_stmts(expr);
        var count i64 = block_expr_count(expr);
        var tail *u8 = block_expr_tail(expr);

        // Generate all statements
        var i i64 = 0;
        while i < count {
            var p **u8 = stmts + (i * 8);
            llvm_emit_stmt(*p);
            i = i + 1;
        }

        // Generate tail expression (leaves value in result)
        if tail != nil {
            llvm_emit_expr(tail);
        }
        return;
    }

    if k == NODE_MATCH_EXPR {
        // Generate match expression: compile to if/else chain
        var scrutinee *u8 = match_expr_scrutinee(expr);
        var arms *u8 = match_expr_arms(expr);
        var arm_count i64 = match_expr_arm_count(expr);

        // Evaluate scrutinee (returns pointer to enum)
        llvm_emit_expr(scrutinee);
        var scrutinee_val *u8 = str_dup(llvm_expr_result);

        // Load tag from scrutinee
        var tag_ptr_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(tag_ptr_temp);
        llvm_emit_str(" = inttoptr i64 ");
        llvm_emit_str(scrutinee_val);
        llvm_emit_line(" to i64*");

        var tag_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(tag_temp);
        llvm_emit_str(" = load i64, i64* %t");
        llvm_emit_int(tag_ptr_temp);
        llvm_emit_char(10);

        // Allocate result variable
        var result_var *u8 = alloc(16);
        *result_var = 37;  // %
        *(result_var + 1) = 95;  // _
        *(result_var + 2) = 109;  // m
        itoa(llvm_anon_local_counter, result_var + 3);
        llvm_anon_local_counter = llvm_anon_local_counter + 1;

        llvm_emit_str("    ");
        llvm_emit_str(result_var);
        llvm_emit_line(" = alloca i64");

        var end_label i64 = llvm_next_label();

        var i i64 = 0;
        while i < arm_count {
            var arm *u8 = get_match_arm(arms, i);
            var pattern *u8 = match_arm_pattern(arm);
            var body *u8 = match_arm_body(arm);
            var pk i64 = node_kind(pattern);

            if pk == NODE_PATTERN_WILDCARD {
                // Wildcard matches anything - just emit body
                llvm_emit_expr(body);
                var body_val *u8 = str_dup(llvm_expr_result);
                llvm_emit_str("    store i64 ");
                llvm_emit_str(body_val);
                llvm_emit_str(", i64* ");
                llvm_emit_str(result_var);
                llvm_emit_char(10);

                llvm_emit_str("    br label %L");
                llvm_emit_int(end_label);
                llvm_emit_char(10);
            } else if pk == NODE_PATTERN_VARIANT {
                // Get variant info from pattern
                var enum_name *u8 = pattern_variant_enum_name(pattern);
                var enum_len i64 = pattern_variant_enum_len(pattern);
                var var_name *u8 = pattern_variant_name(pattern);
                var var_len i64 = pattern_variant_name_len(pattern);
                var binding *u8 = pattern_variant_binding(pattern);
                var binding_len i64 = pattern_variant_binding_len(pattern);

                // Look up enum and variant to get tag
                var enum_decl *u8 = find_enum(enum_name, enum_len);
                if enum_decl == nil {
                    eprint("error: unknown enum '");
                    eprint_buf(enum_name, enum_len);
                    eprintln("' in match pattern");
                    return;
                }
                var variant *u8 = find_variant(enum_decl, var_name, var_len);
                if variant == nil {
                    eprint("error: unknown variant '");
                    eprint_buf(var_name, var_len);
                    eprintln("' in match pattern");
                    return;
                }
                var expected_tag i64 = enum_variant_tag(variant);

                // Compare tag
                var cmp_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(cmp_temp);
                llvm_emit_str(" = icmp eq i64 %t");
                llvm_emit_int(tag_temp);
                llvm_emit_str(", ");
                llvm_emit_int(expected_tag);
                llvm_emit_char(10);

                var then_label i64 = llvm_next_label();
                var next_label i64 = llvm_next_label();

                llvm_emit_str("    br i1 %t");
                llvm_emit_int(cmp_temp);
                llvm_emit_str(", label %L");
                llvm_emit_int(then_label);
                llvm_emit_str(", label %L");
                llvm_emit_int(next_label);
                llvm_emit_char(10);

                // Then block
                llvm_emit_str("L");
                llvm_emit_int(then_label);
                llvm_emit_line(":");

                // If we have a binding, bind the payload
                if binding != nil {
                    var payload_type *u8 = enum_variant_type(variant);
                    var payload_size i64 = 8;
                    if payload_type != nil {
                        payload_size = get_type_size(payload_type);
                    }

                    // Create local for binding with unique suffix to avoid collisions
                    var bind_var *u8 = alloc(64);
                    *bind_var = 37;  // %
                    var bp *u8 = bind_var + 1;
                    var bj i64 = 0;
                    while bj < binding_len {
                        *(bp + bj) = *(binding + bj);
                        bj = bj + 1;
                    }
                    // Add unique suffix: name.N
                    *(bp + binding_len) = 46;  // '.'
                    itoa(llvm_anon_local_counter, bp + binding_len + 1);
                    llvm_anon_local_counter = llvm_anon_local_counter + 1;

                    // Get pointer to payload (scrutinee + 8)
                    var payload_ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(payload_ptr_temp);
                    llvm_emit_str(" = add i64 ");
                    llvm_emit_str(scrutinee_val);
                    llvm_emit_line(", 8");

                    if payload_size <= 8 {
                        // Primitive payload: allocate as i64 and do simple load/store
                        llvm_emit_str("    ");
                        llvm_emit_str(bind_var);
                        llvm_emit_line(" = alloca i64");

                        // Load value from payload
                        var src_ptr_temp i64 = llvm_next_temp();
                        llvm_emit_str("    %t");
                        llvm_emit_int(src_ptr_temp);
                        llvm_emit_str(" = inttoptr i64 %t");
                        llvm_emit_int(payload_ptr_temp);
                        llvm_emit_line(" to i64*");

                        var load_temp i64 = llvm_next_temp();
                        llvm_emit_str("    %t");
                        llvm_emit_int(load_temp);
                        llvm_emit_str(" = load i64, i64* %t");
                        llvm_emit_int(src_ptr_temp);
                        llvm_emit_char(10);

                        // Store to binding
                        llvm_emit_str("    store i64 %t");
                        llvm_emit_int(load_temp);
                        llvm_emit_str(", i64* ");
                        llvm_emit_str(bind_var);
                        llvm_emit_char(10);
                    } else {
                        // Aggregate payload: allocate as byte array and copy
                        llvm_emit_str("    ");
                        llvm_emit_str(bind_var);
                        llvm_emit_str(" = alloca [");
                        llvm_emit_int(payload_size);
                        llvm_emit_line(" x i8]");

                        // Copy payload to binding
                        var copy_i i64 = 0;
                        while copy_i < payload_size {
                            // Load from payload
                            var src_ptr_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(src_ptr_temp);
                            llvm_emit_str(" = add i64 %t");
                            llvm_emit_int(payload_ptr_temp);
                            llvm_emit_str(", ");
                            llvm_emit_int(copy_i);
                            llvm_emit_char(10);

                            var src_iptr_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(src_iptr_temp);
                            llvm_emit_str(" = inttoptr i64 %t");
                            llvm_emit_int(src_ptr_temp);
                            llvm_emit_line(" to i64*");

                            var load_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(load_temp);
                            llvm_emit_str(" = load i64, i64* %t");
                            llvm_emit_int(src_iptr_temp);
                            llvm_emit_char(10);

                            // Store to binding
                            var bind_ptr_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(bind_ptr_temp);
                            llvm_emit_str(" = ptrtoint [");
                            llvm_emit_int(payload_size);
                            llvm_emit_str(" x i8]* ");
                            llvm_emit_str(bind_var);
                            llvm_emit_line(" to i64");

                            var dst_ptr_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(dst_ptr_temp);
                            llvm_emit_str(" = add i64 %t");
                            llvm_emit_int(bind_ptr_temp);
                            llvm_emit_str(", ");
                            llvm_emit_int(copy_i);
                            llvm_emit_char(10);

                            var dst_iptr_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(dst_iptr_temp);
                            llvm_emit_str(" = inttoptr i64 %t");
                            llvm_emit_int(dst_ptr_temp);
                            llvm_emit_line(" to i64*");

                            llvm_emit_str("    store i64 %t");
                            llvm_emit_int(load_temp);
                            llvm_emit_str(", i64* %t");
                            llvm_emit_int(dst_iptr_temp);
                            llvm_emit_char(10);

                            copy_i = copy_i + 8;
                        }
                    }

                    // Add binding to locals with type info for get_expr_type
                    var unique_name *u8 = bind_var + 1;
                    var unique_len i64 = strlen(unique_name);
                    // Use add_local which registers the type for get_expr_type
                    add_local(binding, binding_len, 0, payload_type);
                    llvm_add_local(binding, binding_len);
                    llvm_push_let_binding(binding, binding_len, unique_name, unique_len);
                }

                // Generate body
                llvm_emit_expr(body);
                var body_val *u8 = str_dup(llvm_expr_result);
                llvm_emit_str("    store i64 ");
                llvm_emit_str(body_val);
                llvm_emit_str(", i64* ");
                llvm_emit_str(result_var);
                llvm_emit_char(10);

                // Pop binding if we pushed one
                if binding != nil {
                    llvm_pop_let_binding();
                }

                llvm_emit_str("    br label %L");
                llvm_emit_int(end_label);
                llvm_emit_char(10);

                // Next block
                llvm_emit_str("L");
                llvm_emit_int(next_label);
                llvm_emit_line(":");
            }

            i = i + 1;
        }

        // Fallback branch to end (shouldn't be reached if patterns are exhaustive)
        llvm_emit_str("    br label %L");
        llvm_emit_int(end_label);
        llvm_emit_char(10);

        // End label
        llvm_emit_str("L");
        llvm_emit_int(end_label);
        llvm_emit_line(":");

        // Load and return result
        var final_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(final_temp);
        llvm_emit_str(" = load i64, i64* ");
        llvm_emit_str(result_var);
        llvm_emit_char(10);

        llvm_set_result_temp(final_temp);
        return;
    }

    // Handle expression: handle { body } with { return(v) => ..., Effect(e, k) => ... }
    if k == NODE_HANDLE_EXPR {
        var body *u8 = handle_expr_body(expr);
        var cases *u8 = handle_expr_cases(expr);
        var case_count i64 = handle_expr_case_count(expr);
        var ret_bind *u8 = handle_expr_ret_bind(expr);
        var ret_bind_len i64 = handle_expr_ret_bind_len(expr);
        var ret_body *u8 = handle_expr_ret_body(expr);

        // Generate labels
        var handler_label i64 = llvm_next_label();
        var done_label i64 = llvm_next_label();

        // Save current frame pointer/stack pointer using inline asm
        var rbp_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(rbp_temp);
        if llvm_is_arm64 {
            llvm_emit_line(" = call i64 asm \"mov $0, x29\", \"=r\"()");
        } else {
            llvm_emit_line(" = call i64 asm \"movq %rbp, $0\", \"=r\"()");
        }

        llvm_emit_str("    store i64 %t");
        llvm_emit_int(rbp_temp);
        llvm_emit_line(", i64* @__handler_rbp");

        var rsp_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(rsp_temp);
        if llvm_is_arm64 {
            llvm_emit_line(" = call i64 asm \"mov $0, sp\", \"=r\"()");
        } else {
            llvm_emit_line(" = call i64 asm \"movq %rsp, $0\", \"=r\"()");
        }

        llvm_emit_str("    store i64 %t");
        llvm_emit_int(rsp_temp);
        llvm_emit_line(", i64* @__handler_rsp");

        // Get handler block address using inline asm - compute label address
        var addr_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(addr_temp);
        if llvm_is_arm64 {
            llvm_emit_str(" = call i64 asm \"adrp $0, .Lhandler");
            llvm_emit_int(handler_label);
            llvm_emit_str("@PAGE\\0Aadd $0, $0, .Lhandler");
            llvm_emit_int(handler_label);
            llvm_emit_line("@PAGEOFF\", \"=r\"()");
        } else {
            llvm_emit_str(" = call i64 asm \"leaq .Lhandler");
            llvm_emit_int(handler_label);
            llvm_emit_line("(%rip), $0\", \"=r\"()");
        }

        llvm_emit_str("    store i64 %t");
        llvm_emit_int(addr_temp);
        llvm_emit_line(", i64* @__handler_addr");

        llvm_emit_line("    store i64 1, i64* @__handler_set");

        // Allocate result storage as i64
        var result_var *u8 = alloc(32);
        *result_var = 37;  // %
        *(result_var + 1) = 95;  // _
        *(result_var + 2) = 104;  // h
        *(result_var + 3) = 114;  // r
        itoa(handler_label, result_var + 4);
        llvm_emit_str("    ");
        llvm_emit_str(result_var);
        llvm_emit_line(" = alloca i64");

        // Generate body
        if node_kind(body) == NODE_BLOCK_STMT {
            llvm_emit_block(body);
        } else {
            llvm_emit_expr(body);
        }
        // Store body result for return case - llvm_expr_result has last expression value
        llvm_emit_str("    store i64 ");
        llvm_emit_str(llvm_expr_result);
        llvm_emit_str(", i64* ");
        llvm_emit_str(result_var);
        llvm_emit_char(10);

        // Normal completion - use conditional branch to keep handler block alive
        // The volatile load prevents LLVM from optimizing this away
        var dummy_flag i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(dummy_flag);
        llvm_emit_line(" = load volatile i64, i64* @__handler_set");
        var dummy_test i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(dummy_test);
        llvm_emit_str(" = icmp eq i64 %t");
        llvm_emit_int(dummy_flag);
        llvm_emit_line(", 12345");
        llvm_emit_str("    br i1 %t");
        llvm_emit_int(dummy_test);
        llvm_emit_str(", label %Lhandler");
        llvm_emit_int(handler_label);
        llvm_emit_str(", label %Ldone");
        llvm_emit_int(done_label);
        llvm_emit_char(10);

        // Handler entry point - proper LLVM basic block + asm label alias
        llvm_emit_str("Lhandler");
        llvm_emit_int(handler_label);
        llvm_emit_line(":");
        // Emit asm label at same location for perform's jmpq to target
        llvm_emit_str("    call void asm sideeffect \".Lhandler");
        llvm_emit_int(handler_label);
        llvm_emit_line(":\", \"\"()");

        // Effect value is in @__effect_value, continuation in @__continuation_ptr
        // Effect name is in @__effect_name_ptr/@__effect_name_len

        // Generate dispatch code for each effect case
        var case_i i64 = 0;
        while case_i < case_count {
            var entry *u8 = cases + (case_i * 56);
            var eff_name *u8 = effect_case_name(entry);
            var eff_name_len i64 = effect_case_name_len(entry);
            var bind_ptr *u8 = effect_case_binding(entry);
            var bind_len i64 = effect_case_binding_len(entry);
            var k_ptr *u8 = effect_case_k(entry);
            var k_len i64 = effect_case_k_len(entry);
            var case_body *u8 = effect_case_body(entry);

            // Look up effect declaration to check arity
            var eff_decl *u8 = llvm_find_effect(eff_name, eff_name_len);
            var eff_param_count i64 = 0;
            if eff_decl != nil {
                eff_param_count = effect_decl_param_type_count(eff_decl);
            }

            // For zero-arg effects, the syntax is Effect(k) where k is continuation
            if eff_param_count == 0 && k_len == 0 && bind_len > 0 {
                k_ptr = bind_ptr;
                k_len = bind_len;
                bind_ptr = nil;
                bind_len = 0;
            }

            var case_label i64 = llvm_next_label();
            var next_case_label i64 = llvm_next_label();

            // Compare effect name length
            var name_len_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(name_len_temp);
            llvm_emit_line(" = load i64, i64* @__effect_name_len");

            var len_cmp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(len_cmp);
            llvm_emit_str(" = icmp eq i64 %t");
            llvm_emit_int(name_len_temp);
            llvm_emit_str(", ");
            llvm_emit_int(eff_name_len);
            llvm_emit_char(10);

            llvm_emit_str("    br i1 %t");
            llvm_emit_int(len_cmp);
            llvm_emit_str(", label %Lcase");
            llvm_emit_int(case_label);
            llvm_emit_str(", label %Lnext");
            llvm_emit_int(next_case_label);
            llvm_emit_char(10);

            llvm_emit_str("Lcase");
            llvm_emit_int(case_label);
            llvm_emit_line(":");

            // TODO: Actually compare effect name strings
            // For now, assume single effect type matches

            var saved_local_count i64 = cg_local_count;

            // Create local for effect value binding (e) - allocate, store, push let binding
            var bind_pushed i64 = 0;
            if bind_len > 0 {
                // Build unique name like "e.eff5"
                var bind_id i64 = case_label;
                var bind_unique *u8 = alloc(32);
                var bpos i64 = 0;
                var bi i64 = 0;
                while bi < bind_len {
                    *(bind_unique + bpos) = *(bind_ptr + bi);
                    bpos = bpos + 1;
                    bi = bi + 1;
                }
                *(bind_unique + bpos) = 46;  // '.'
                bpos = bpos + 1;
                var btmp *u8 = alloc(16);
                itoa(bind_id, btmp);
                bi = 0;
                while *(btmp + bi) != 0 {
                    *(bind_unique + bpos) = *(btmp + bi);
                    bpos = bpos + 1;
                    bi = bi + 1;
                }
                *(bind_unique + bpos) = 0;
                var bind_unique_len i64 = bpos;

                // Allocate local
                llvm_emit_str("    %");
                llvm_emit_n(bind_unique, bind_unique_len);
                llvm_emit_line(" = alloca i64");

                // Load effect value
                var val_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(val_temp);
                llvm_emit_line(" = load i64, i64* @__effect_value");

                // Store to local
                llvm_emit_str("    store i64 %t");
                llvm_emit_int(val_temp);
                llvm_emit_str(", i64* %");
                llvm_emit_n(bind_unique, bind_unique_len);
                llvm_emit_char(10);

                // Push let binding
                llvm_push_let_binding(bind_ptr, bind_len, bind_unique, bind_unique_len);
                bind_pushed = 1;
            }

            // Create local for continuation binding (k) - allocate, store, push let binding
            var k_pushed i64 = 0;
            if k_len > 0 {
                // Build unique name like "k.eff5"
                var k_id i64 = case_label;
                var k_unique *u8 = alloc(32);
                var kpos i64 = 0;
                var ki i64 = 0;
                while ki < k_len {
                    *(k_unique + kpos) = *(k_ptr + ki);
                    kpos = kpos + 1;
                    ki = ki + 1;
                }
                *(k_unique + kpos) = 46;  // '.'
                kpos = kpos + 1;
                var ktmp *u8 = alloc(16);
                itoa(k_id, ktmp);
                ki = 0;
                while *(ktmp + ki) != 0 {
                    *(k_unique + kpos) = *(ktmp + ki);
                    kpos = kpos + 1;
                    ki = ki + 1;
                }
                *(k_unique + kpos) = 0;
                var k_unique_len i64 = kpos;

                // Allocate local (store pointer as i64)
                llvm_emit_str("    %");
                llvm_emit_n(k_unique, k_unique_len);
                llvm_emit_line(" = alloca i64");

                // Load continuation
                var cont_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(cont_temp);
                llvm_emit_line(" = load i8*, i8** @__continuation_ptr");

                // ptrtoint to i64
                var int_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(int_temp);
                llvm_emit_str(" = ptrtoint i8* %t");
                llvm_emit_int(cont_temp);
                llvm_emit_line(" to i64");

                // Store to local
                llvm_emit_str("    store i64 %t");
                llvm_emit_int(int_temp);
                llvm_emit_str(", i64* %");
                llvm_emit_n(k_unique, k_unique_len);
                llvm_emit_char(10);

                // Push let binding
                llvm_push_let_binding(k_ptr, k_len, k_unique, k_unique_len);
                k_pushed = 1;
            }

            // Generate case body
            if node_kind(case_body) == NODE_BLOCK_STMT {
                llvm_emit_block(case_body);
            } else {
                llvm_emit_expr(case_body);
                // Store result
                llvm_emit_str("    store i64 ");
                llvm_emit_str(llvm_expr_result);
                llvm_emit_str(", i64* ");
                llvm_emit_str(result_var);
                llvm_emit_char(10);
            }

            cg_local_count = saved_local_count;

            // Pop let bindings
            if k_pushed != 0 {
                llvm_pop_let_binding();
            }
            if bind_pushed != 0 {
                llvm_pop_let_binding();
            }

            // Jump to done
            llvm_emit_str("    br label %Ldone");
            llvm_emit_int(done_label);
            llvm_emit_char(10);

            llvm_emit_str("Lnext");
            llvm_emit_int(next_case_label);
            llvm_emit_line(":");

            case_i = case_i + 1;
        }

        // Fallthrough after all cases - just go to done
        llvm_emit_str("    br label %Ldone");
        llvm_emit_int(done_label);
        llvm_emit_char(10);

        // Done label
        llvm_emit_str("Ldone");
        llvm_emit_int(done_label);
        llvm_emit_line(":");

        // Clear handler
        llvm_emit_line("    store i64 0, i64* @__handler_set");

        // Load final result
        var final_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(final_temp);
        llvm_emit_str(" = load i64, i64* ");
        llvm_emit_str(result_var);
        llvm_emit_char(10);

        llvm_set_result_temp(final_temp);
        return;
    }

    // Perform expression: perform Effect(args)
    if k == NODE_PERFORM_EXPR {
        var args *u8 = perform_expr_args(expr);
        var arg_count i64 = perform_expr_arg_count(expr);
        var eff_name *u8 = perform_expr_name(expr);
        var eff_name_len i64 = perform_expr_name_len(expr);

        // Generate resume label
        var resume_label i64 = llvm_next_label();

        // Allocate continuation struct: [rbp:8][rsp:8][return_addr:8] = 24 bytes
        var cont_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(cont_temp);
        llvm_emit_line(" = call i8* @alloc(i64 24)");

        // Store frame pointer at offset 0 using inline asm
        if llvm_is_arm64 {
            llvm_emit_str("    call void asm sideeffect \"str x29, [$0]\", \"r\"(i8* %t");
        } else {
            llvm_emit_str("    call void asm sideeffect \"movq %rbp, ($0)\", \"r\"(i8* %t");
        }
        llvm_emit_int(cont_temp);
        llvm_emit_line(")");

        // Store stack pointer at offset 8
        var rsp_ptr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(rsp_ptr);
        llvm_emit_str(" = getelementptr i8, i8* %t");
        llvm_emit_int(cont_temp);
        llvm_emit_line(", i64 8");

        if llvm_is_arm64 {
            llvm_emit_str("    call void asm sideeffect \"mov x0, sp\\0Astr x0, [$0]\", \"r,~{x0},~{memory}\"(i8* %t");
        } else {
            llvm_emit_str("    call void asm sideeffect \"movq %rsp, %rax\\0Amovq %rax, ($0)\", \"r,~{rax},~{memory}\"(i8* %t");
        }
        llvm_emit_int(rsp_ptr);
        llvm_emit_line(")");

        // Store return address at offset 16
        var ret_ptr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(ret_ptr);
        llvm_emit_str(" = getelementptr i8, i8* %t");
        llvm_emit_int(cont_temp);
        llvm_emit_line(", i64 16");

        if llvm_is_arm64 {
            llvm_emit_str("    call void asm sideeffect \"adrp x0, .Lresume");
            llvm_emit_int(resume_label);
            llvm_emit_str("@PAGE\\0Aadd x0, x0, .Lresume");
            llvm_emit_int(resume_label);
            llvm_emit_str("@PAGEOFF\\0Astr x0, [$0]\", \"r,~{x0},~{memory}\"(i8* %t");
        } else {
            llvm_emit_str("    call void asm sideeffect \"leaq .Lresume");
            llvm_emit_int(resume_label);
            llvm_emit_str("(%rip), %rax\\0Amovq %rax, ($0)\", \"r,~{rax},~{memory}\"(i8* %t");
        }
        llvm_emit_int(ret_ptr);
        llvm_emit_line(")");

        // Store continuation pointer in global
        llvm_emit_str("    store i8* %t");
        llvm_emit_int(cont_temp);
        llvm_emit_line(", i8** @__continuation_ptr");

        // Store effect name (note: effect names don't have escapes, but use processed_len for consistency)
        var eff_str_idx i64 = llvm_add_string(eff_name, eff_name_len);
        var eff_processed_len i64 = llvm_string_processed_len(eff_name, eff_name_len);
        var name_ptr_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(name_ptr_temp);
        llvm_emit_str(" = getelementptr [");
        llvm_emit_int(eff_processed_len + 1);
        llvm_emit_str(" x i8], [");
        llvm_emit_int(eff_processed_len + 1);
        llvm_emit_str(" x i8]* @.str");
        llvm_emit_int(eff_str_idx);
        llvm_emit_line(", i64 0, i64 0");

        llvm_emit_str("    store i8* %t");
        llvm_emit_int(name_ptr_temp);
        llvm_emit_line(", i8** @__effect_name_ptr");

        llvm_emit_str("    store i64 ");
        llvm_emit_int(eff_name_len);
        llvm_emit_line(", i64* @__effect_name_len");

        // Evaluate first arg (if any) and store in __effect_value
        if arg_count > 0 {
            var first_arg_ptr **u8 = args;
            llvm_emit_expr(*first_arg_ptr);
            llvm_emit_str("    store i64 ");
            llvm_emit_str(llvm_expr_result);
            llvm_emit_line(", i64* @__effect_value");
        }

        // Restore handler's rbp and jump to handler using inline asm
        var h_rbp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(h_rbp);
        llvm_emit_line(" = load i64, i64* @__handler_rbp");

        var h_addr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(h_addr);
        llvm_emit_line(" = load i64, i64* @__handler_addr");

        // Jump to handler - use a branch that LLVM can't optimize away
        // We pretend we might fall through, then the "resume" block is kept
        var dummy_cond i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(dummy_cond);
        llvm_emit_line(" = load volatile i64, i64* @__handler_set");
        var dummy_cmp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(dummy_cmp);
        llvm_emit_str(" = icmp eq i64 %t");
        llvm_emit_int(dummy_cond);
        llvm_emit_line(", 0");
        if llvm_is_arm64 {
            llvm_emit_str("    call void asm sideeffect \"mov x29, $0\\0Abr $1\", \"r,r\"(i64 %t");
        } else {
            llvm_emit_str("    call void asm sideeffect \"movq $0, %rbp\\0Ajmpq *$1\", \"r,r\"(i64 %t");
        }
        llvm_emit_int(h_rbp);
        llvm_emit_str(", i64 %t");
        llvm_emit_int(h_addr);
        llvm_emit_line(")");
        // Branch to resume point (this keeps the block alive)
        llvm_emit_str("    br label %Lresume");
        llvm_emit_int(resume_label);
        llvm_emit_char(10);

        // Resume point - proper LLVM basic block + asm label
        llvm_emit_str("Lresume");
        llvm_emit_int(resume_label);
        llvm_emit_line(":");
        llvm_emit_str("    call void asm sideeffect \".Lresume");
        llvm_emit_int(resume_label);
        llvm_emit_line(":\", \"\"()");

        // Result is in @__resume_value global (stored by resume before jumping)
        var result_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(result_temp);
        llvm_emit_line(" = load i64, i64* @__resume_value");

        llvm_set_result_temp(result_temp);
        return;
    }

    // Resume expression: resume k(value)
    if k == NODE_RESUME_EXPR {
        var k_expr *u8 = resume_expr_k(expr);
        var value *u8 = resume_expr_value(expr);

        // Evaluate continuation expression
        llvm_emit_expr(k_expr);
        var cont_i64 *u8 = str_dup(llvm_expr_result);

        // Convert i64 to i8* for pointer operations
        var cont_ptr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(cont_ptr);
        llvm_emit_str(" = inttoptr i64 ");
        llvm_emit_str(cont_i64);
        llvm_emit_line(" to i8*");

        var cont_val *u8 = alloc(16);
        *cont_val = 37;  // %
        *(cont_val + 1) = 116;  // t
        itoa(cont_ptr, cont_val + 2);

        // Load rbp, rsp, return_addr from continuation
        // Continuation: [rbp:8][rsp:8][return_addr:8]

        // Get rbp
        var rbp_ptr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(rbp_ptr);
        llvm_emit_str(" = bitcast i8* ");
        llvm_emit_str(cont_val);
        llvm_emit_line(" to i64*");

        var saved_rbp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(saved_rbp);
        llvm_emit_str(" = load i64, i64* %t");
        llvm_emit_int(rbp_ptr);
        llvm_emit_char(10);

        // Get rsp
        var rsp_off i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(rsp_off);
        llvm_emit_str(" = getelementptr i8, i8* ");
        llvm_emit_str(cont_val);
        llvm_emit_line(", i64 8");

        var rsp_ptr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(rsp_ptr);
        llvm_emit_str(" = bitcast i8* %t");
        llvm_emit_int(rsp_off);
        llvm_emit_line(" to i64*");

        var saved_rsp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(saved_rsp);
        llvm_emit_str(" = load i64, i64* %t");
        llvm_emit_int(rsp_ptr);
        llvm_emit_char(10);

        // Get return addr
        var ret_off i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(ret_off);
        llvm_emit_str(" = getelementptr i8, i8* ");
        llvm_emit_str(cont_val);
        llvm_emit_line(", i64 16");

        var ret_ptr i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(ret_ptr);
        llvm_emit_str(" = bitcast i8* %t");
        llvm_emit_int(ret_off);
        llvm_emit_line(" to i64*");

        var saved_ret i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(saved_ret);
        llvm_emit_str(" = load i64, i64* %t");
        llvm_emit_int(ret_ptr);
        llvm_emit_char(10);

        // Evaluate value to resume with
        var resume_val *u8 = "0";
        if value != nil {
            llvm_emit_expr(value);
            resume_val = str_dup(llvm_expr_result);
        }

        // Store resume value to global variable (not rax - LLVM can't track it across jump)
        llvm_emit_str("    store i64 ");
        llvm_emit_str(resume_val);
        llvm_emit_line(", i64* @__resume_value");

        // Restore frame pointer, stack pointer and jump using inline asm
        if llvm_is_arm64 {
            llvm_emit_str("    call void asm sideeffect \"mov x29, $0\\0Amov sp, $1\\0Abr $2\", \"r,r,r\"(i64 %t");
        } else {
            llvm_emit_str("    call void asm sideeffect \"movq $0, %rbp\\0Amovq $1, %rsp\\0Ajmpq *$2\", \"r,r,r\"(i64 %t");
        }
        llvm_emit_int(saved_rbp);
        llvm_emit_str(", i64 %t");
        llvm_emit_int(saved_rsp);
        llvm_emit_str(", i64 %t");
        llvm_emit_int(saved_ret);
        llvm_emit_line(")");
        llvm_emit_line("    unreachable");

        // This point is never reached (resume jumps away)
        // Return dummy value
        var p *u8 = llvm_expr_result;
        *p = 48;
        *(p + 1) = 0;
        return;
    }

    // For now, unsupported expressions return 0
    var p *u8 = llvm_expr_result;
    *p = 48;  // "0"
    *(p + 1) = 0;
}

// ============================================================
// Statement emission
// ============================================================

func llvm_emit_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }

    var k i64 = node_kind(stmt);

    if k == NODE_RETURN_STMT {
        var ret_expr *u8 = return_stmt_value(stmt);
        if ret_expr == nil {
            llvm_emit_line("    ret void");
        } else {
            llvm_emit_expr(ret_expr);
            var val *u8 = str_dup(llvm_expr_result);

            // If returning pointer type but value is i64, convert with inttoptr
            if llvm_is_pointer_type(llvm_current_ret_type) {
                var conv_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(conv_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(val);
                llvm_emit_str(" to ");
                llvm_emit_type(llvm_current_ret_type);
                llvm_emit_char(10);

                llvm_emit_str("    ret ");
                llvm_emit_type(llvm_current_ret_type);
                llvm_emit_str(" %t");
                llvm_emit_int(conv_temp);
                llvm_emit_char(10);
            } else if llvm_is_bool_type(llvm_current_ret_type) {
                // Bool return: truncate i64 to i1
                var conv_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(conv_temp);
                llvm_emit_str(" = trunc i64 ");
                llvm_emit_str(val);
                llvm_emit_line(" to i1");

                llvm_emit_str("    ret i1 %t");
                llvm_emit_int(conv_temp);
                llvm_emit_char(10);
            } else if llvm_is_u8_type(llvm_current_ret_type) {
                // u8 return: truncate i64 to i8
                var conv_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(conv_temp);
                llvm_emit_str(" = trunc i64 ");
                llvm_emit_str(val);
                llvm_emit_line(" to i8");

                llvm_emit_str("    ret i8 %t");
                llvm_emit_int(conv_temp);
                llvm_emit_char(10);
            } else {
                llvm_emit_str("    ret ");
                llvm_emit_type(llvm_current_ret_type);
                llvm_emit_str(" ");
                llvm_emit_str(val);
                llvm_emit_char(10);
            }
        }
        llvm_emitted_terminator = 1;
        return;
    }

    if k == NODE_IF_STMT {
        var cond *u8 = if_stmt_cond(stmt);
        var then_block *u8 = if_stmt_then(stmt);
        var else_block *u8 = if_stmt_else(stmt);

        // Generate labels
        var then_label i64 = llvm_next_label();
        var else_label i64 = llvm_next_label();
        var end_label i64 = llvm_next_label();

        // Emit condition
        llvm_emit_expr(cond);
        var cond_val *u8 = str_dup(llvm_expr_result);

        // Convert to i1 (LLVM bool)
        var cmp_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(" = icmp ne i64 ");
        llvm_emit_str(cond_val);
        llvm_emit_line(", 0");

        // Branch
        llvm_emit_str("    br i1 %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(", label %L");
        llvm_emit_int(then_label);
        llvm_emit_str(", label %L");
        if else_block != nil {
            llvm_emit_int(else_label);
        } else {
            llvm_emit_int(end_label);
        }
        llvm_emit_char(10);

        // Then block
        llvm_emit_str("L");
        llvm_emit_int(then_label);
        llvm_emit_line(":");
        llvm_emitted_terminator = 0;
        llvm_emit_block(then_block);
        var then_ended i64 = llvm_emitted_terminator;
        if then_ended == 0 {
            llvm_emit_str("    br label %L");
            llvm_emit_int(end_label);
            llvm_emit_char(10);
        }

        // Else block
        var else_ended i64 = 0;
        if else_block != nil {
            llvm_emit_str("L");
            llvm_emit_int(else_label);
            llvm_emit_line(":");
            llvm_emitted_terminator = 0;
            // Check if else_block is a block or a statement (for else-if)
            if node_kind(else_block) == NODE_BLOCK_STMT {
                llvm_emit_block(else_block);
            } else {
                // else-if: else_block is an IF_STMT
                llvm_emit_stmt(else_block);
            }
            else_ended = llvm_emitted_terminator;
            if else_ended == 0 {
                llvm_emit_str("    br label %L");
                llvm_emit_int(end_label);
                llvm_emit_char(10);
            }
        }

        // End label - only needed if at least one branch falls through
        if then_ended == 0 || else_ended == 0 || else_block == nil {
            llvm_emit_str("L");
            llvm_emit_int(end_label);
            llvm_emit_line(":");
            llvm_emitted_terminator = 0;
        } else {
            // Both branches terminate - this if terminates
            llvm_emitted_terminator = 1;
        }
        return;
    }

    if k == NODE_WHILE_STMT {
        var cond *u8 = while_stmt_cond(stmt);
        var body *u8 = while_stmt_body(stmt);
        var loop_name *u8 = while_stmt_label(stmt);
        var loop_name_len i64 = while_stmt_label_len(stmt);

        var cond_label i64 = llvm_next_label();
        var body_label i64 = llvm_next_label();
        var end_label i64 = llvm_next_label();

        // Jump to condition
        llvm_emit_str("    br label %L");
        llvm_emit_int(cond_label);
        llvm_emit_char(10);

        // Condition block
        llvm_emit_str("L");
        llvm_emit_int(cond_label);
        llvm_emit_line(":");
        llvm_emit_expr(cond);
        var cond_val *u8 = str_dup(llvm_expr_result);

        var cmp_temp i64 = llvm_next_temp();
        llvm_emit_str("    %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(" = icmp ne i64 ");
        llvm_emit_str(cond_val);
        llvm_emit_line(", 0");

        llvm_emit_str("    br i1 %t");
        llvm_emit_int(cmp_temp);
        llvm_emit_str(", label %L");
        llvm_emit_int(body_label);
        llvm_emit_str(", label %L");
        llvm_emit_int(end_label);
        llvm_emit_char(10);

        // Body block
        llvm_emit_str("L");
        llvm_emit_int(body_label);
        llvm_emit_line(":");

        // Push loop for break/continue (with label if present)
        llvm_push_loop_labeled(loop_name, loop_name_len, end_label, cond_label);
        llvm_emit_block(body);
        llvm_pop_loop();

        // Only emit branch if no terminator (break/continue/return)
        if llvm_emitted_terminator == 0 {
            llvm_emit_str("    br label %L");
            llvm_emit_int(cond_label);
            llvm_emit_char(10);
        }
        llvm_emitted_terminator = 0;

        // End label
        llvm_emit_str("L");
        llvm_emit_int(end_label);
        llvm_emit_line(":");
        return;
    }

    if k == NODE_BREAK_STMT {
        var label *u8 = break_stmt_label(stmt);
        var label_len i64 = break_stmt_label_len(stmt);
        var entry *u8 = llvm_find_loop(label, label_len);
        if entry != nil {
            var target i64 = llvm_loop_break_label(entry);
            llvm_emit_str("    br label %L");
            llvm_emit_int(target);
            llvm_emit_char(10);
            llvm_emitted_terminator = 1;
        }
        return;
    }

    if k == NODE_CONTINUE_STMT {
        var label *u8 = continue_stmt_label(stmt);
        var label_len i64 = continue_stmt_label_len(stmt);
        var entry *u8 = llvm_find_loop(label, label_len);
        if entry != nil {
            var target i64 = llvm_loop_continue_label(entry);
            llvm_emit_str("    br label %L");
            llvm_emit_int(target);
            llvm_emit_char(10);
            llvm_emitted_terminator = 1;
        }
        return;
    }

    if k == NODE_VAR_DECL {
        var name *u8 = var_decl_name(stmt);
        var name_len i64 = var_decl_name_len(stmt);
        var init *u8 = var_decl_init(stmt);
        var var_type *u8 = var_decl_type(stmt);

        // Register as local (both LLVM and shared tracking for type info)
        llvm_add_local(name, name_len);
        add_local(name, name_len, 0, var_type);  // 0 offset, use var_type

        // Calculate allocation size - structs, enums, and arrays need more than 8 bytes
        var alloc_size i64 = 8;
        var is_aggregate i64 = 0;
        var is_array i64 = 0;
        if var_type != nil {
            if type_kind(var_type) == TYPE_ARRAY {
                // Array type - allocate full array size
                alloc_size = get_type_size(var_type);
                is_array = 1;
            } else if type_kind(var_type) == TYPE_BASE {
                var type_name *u8 = base_type_name(var_type);
                var type_name_len i64 = base_type_name_len(var_type);
                var struct_decl *u8 = find_struct(type_name, type_name_len);
                if struct_decl != nil {
                    alloc_size = get_struct_size(struct_decl);
                    is_aggregate = 1;
                } else {
                    // Check if it's an enum type
                    var enum_decl *u8 = find_enum(type_name, type_name_len);
                    if enum_decl != nil {
                        alloc_size = get_enum_size(enum_decl);
                        is_aggregate = 1;
                    }
                }
            }
        }

        // ALWAYS use unique names to avoid SSA conflicts in branches/loops
        var unique_name *u8 = alloc(64);
        var up *u8 = unique_name;
        var ui i64 = 0;
        while ui < name_len {
            *(up + ui) = *(name + ui);
            ui = ui + 1;
        }
        *(up + name_len) = 46;  // '.'
        itoa(llvm_anon_local_counter, up + name_len + 1);
        llvm_anon_local_counter = llvm_anon_local_counter + 1;
        var actual_name *u8 = unique_name;
        var actual_name_len i64 = strlen(unique_name);
        // Register let binding: name -> unique_name
        llvm_push_let_binding(name, name_len, unique_name, actual_name_len);

        // Allocate stack slot with correct size
        llvm_emit_str("    %");
        llvm_emit_n(actual_name, actual_name_len);
        if is_array == 1 {
            // Allocate array type: [N x T]
            llvm_emit_str(" = alloca ");
            llvm_emit_type(var_type);
            llvm_emit_char(10);
        } else if is_aggregate == 1 {
            // Allocate as byte array for structs/enums (even if size <= 8)
            // This ensures type consistency with field access code
            llvm_emit_str(" = alloca [");
            llvm_emit_int(alloc_size);
            llvm_emit_line(" x i8]");
        } else if var_type != nil && llvm_is_float_type(var_type) {
            // Float type: alloca with proper type
            llvm_emit_str(" = alloca ");
            llvm_emit_type(var_type);
            llvm_emit_char(10);
        } else if alloc_size <= 8 {
            llvm_emit_line(" = alloca i64");
        } else {
            // Non-aggregate larger than 8 bytes (shouldn't happen but handle it)
            llvm_emit_str(" = alloca [");
            llvm_emit_int(alloc_size);
            llvm_emit_line(" x i8]");
        }

        // Initialize if there's an init expression
        if init != nil {
            llvm_emit_expr(init);
            var init_val *u8 = str_dup(llvm_expr_result);

            // Check if assigning non-capturing lambda to closure type
            // Wrap it in a closure struct with tag=0
            if var_type != nil {
                if type_kind(var_type) == TYPE_CLOSURE {
                    if node_kind(init) == NODE_LAMBDA_EXPR {
                        if lambda_has_captures(init) == 0 {
                            // init_val has function pointer, wrap in closure struct
                            // Allocate struct: [tag:8][fn_ptr:8] = 16 bytes
                            var alloc_ptr_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(alloc_ptr_temp);
                            llvm_emit_line(" = call i8* @alloc(i64 16)");

                            // Store tag = 0 at offset 0
                            var tag_ptr i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(tag_ptr);
                            llvm_emit_str(" = bitcast i8* %t");
                            llvm_emit_int(alloc_ptr_temp);
                            llvm_emit_line(" to i64*");
                            llvm_emit_str("    store i64 0, i64* %t");
                            llvm_emit_int(tag_ptr);
                            llvm_emit_char(10);

                            // Store fn_ptr at offset 8
                            var fn_slot_temp i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(fn_slot_temp);
                            llvm_emit_str(" = getelementptr i8, i8* %t");
                            llvm_emit_int(alloc_ptr_temp);
                            llvm_emit_line(", i64 8");
                            var fn_ptr_slot i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(fn_ptr_slot);
                            llvm_emit_str(" = bitcast i8* %t");
                            llvm_emit_int(fn_slot_temp);
                            llvm_emit_line(" to i64*");
                            llvm_emit_str("    store i64 ");
                            llvm_emit_str(init_val);
                            llvm_emit_str(", i64* %t");
                            llvm_emit_int(fn_ptr_slot);
                            llvm_emit_char(10);

                            // Update init_val to point to closure struct
                            var closure_addr i64 = llvm_next_temp();
                            llvm_emit_str("    %t");
                            llvm_emit_int(closure_addr);
                            llvm_emit_str(" = ptrtoint i8* %t");
                            llvm_emit_int(alloc_ptr_temp);
                            llvm_emit_line(" to i64");
                            init_val = alloc(16);
                            *init_val = 37;  // '%'
                            *(init_val + 1) = 116;  // 't'
                            itoa(closure_addr, init_val + 2);
                        }
                    }
                }
            }

            if is_aggregate == 0 {
                // Simple store for primitives - use proper type for floats
                llvm_emit_str("    store ");
                if var_type != nil && llvm_is_float_type(var_type) {
                    llvm_emit_type(var_type);
                    llvm_emit_str(" ");
                    llvm_emit_str(init_val);
                    llvm_emit_str(", ");
                    llvm_emit_type(var_type);
                    llvm_emit_str("* %");
                } else {
                    llvm_emit_str("i64 ");
                    llvm_emit_str(init_val);
                    llvm_emit_str(", i64* %");
                }
                llvm_emit_n(actual_name, actual_name_len);
                llvm_emit_char(10);
            } else {
                // For structs/enums, init_val is a pointer to the source
                // Copy all bytes from source to destination
                var dest_addr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(dest_addr_temp);
                llvm_emit_str(" = ptrtoint [");
                llvm_emit_int(alloc_size);
                llvm_emit_str(" x i8]* %");
                llvm_emit_n(actual_name, actual_name_len);
                llvm_emit_line(" to i64");

                var copy_i i64 = 0;
                while copy_i < alloc_size {
                    // Load from source
                    var src_ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(src_ptr_temp);
                    llvm_emit_str(" = add i64 ");
                    llvm_emit_str(init_val);
                    llvm_emit_str(", ");
                    llvm_emit_int(copy_i);
                    llvm_emit_char(10);

                    var src_iptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(src_iptr_temp);
                    llvm_emit_str(" = inttoptr i64 %t");
                    llvm_emit_int(src_ptr_temp);
                    llvm_emit_line(" to i64*");

                    var load_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(load_temp);
                    llvm_emit_str(" = load i64, i64* %t");
                    llvm_emit_int(src_iptr_temp);
                    llvm_emit_char(10);

                    // Store to destination
                    var dst_ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(dst_ptr_temp);
                    llvm_emit_str(" = add i64 %t");
                    llvm_emit_int(dest_addr_temp);
                    llvm_emit_str(", ");
                    llvm_emit_int(copy_i);
                    llvm_emit_char(10);

                    var dst_iptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(dst_iptr_temp);
                    llvm_emit_str(" = inttoptr i64 %t");
                    llvm_emit_int(dst_ptr_temp);
                    llvm_emit_line(" to i64*");

                    llvm_emit_str("    store i64 %t");
                    llvm_emit_int(load_temp);
                    llvm_emit_str(", i64* %t");
                    llvm_emit_int(dst_iptr_temp);
                    llvm_emit_char(10);

                    copy_i = copy_i + 8;
                }
            }
        }
        return;
    }

    if k == NODE_EXPR_STMT {
        var expr *u8 = expr_stmt_expr(stmt);
        llvm_emit_expr(expr);
        return;
    }

    if k == NODE_ASSIGN_STMT {
        var target *u8 = assign_stmt_target(stmt);
        var value *u8 = assign_stmt_value(stmt);

        // Emit value
        llvm_emit_expr(value);
        var val *u8 = str_dup(llvm_expr_result);

        // Check for dereference assignment (*p = value)
        if node_kind(target) == NODE_UNARY_EXPR {
            var target_op i64 = unary_expr_op(target);
            if target_op == 27 {  // TOKEN_STAR (dereference)
                // Get the pointer value and type info
                var ptr_expr *u8 = unary_expr_expr(target);
                var ptr_type *u8 = get_expr_type(ptr_expr);
                var elem_type *u8 = get_pointed_type(ptr_type);
                var size i64 = 8;
                if elem_type != nil {
                    size = get_type_size(elem_type);
                }

                llvm_emit_expr(ptr_expr);
                var ptr_val *u8 = str_dup(llvm_expr_result);

                var ptr_temp i64 = llvm_next_temp();

                if size == 1 {
                    // Truncate value to i8 and store
                    var trunc_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(" = trunc i64 ");
                    llvm_emit_str(val);
                    llvm_emit_line(" to i8");
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i8*");
                    llvm_emit_str("    store i8 %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(", i8* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                } else if size == 2 {
                    // Truncate value to i16 and store
                    var trunc_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(" = trunc i64 ");
                    llvm_emit_str(val);
                    llvm_emit_line(" to i16");
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i16*");
                    llvm_emit_str("    store i16 %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(", i16* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                } else if size == 4 {
                    // Truncate value to i32 and store
                    var trunc_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(" = trunc i64 ");
                    llvm_emit_str(val);
                    llvm_emit_line(" to i32");
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i32*");
                    llvm_emit_str("    store i32 %t");
                    llvm_emit_int(trunc_temp);
                    llvm_emit_str(", i32* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                } else {
                    // Default: store i64
                    llvm_emit_str("    %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_str(" = inttoptr i64 ");
                    llvm_emit_str(ptr_val);
                    llvm_emit_line(" to i64*");
                    llvm_emit_str("    store i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", i64* %t");
                    llvm_emit_int(ptr_temp);
                    llvm_emit_char(10);
                }
                return;
            }
        }

        // Check for array index assignment (arr[i] = value)
        if node_kind(target) == NODE_INDEX_EXPR {
            var base_p **u8 = target + 8;
            var index_p **u8 = target + 16;
            var base_expr *u8 = *base_p;
            var index_expr *u8 = *index_p;

            var base_type *u8 = llvm_get_expr_type(base_expr);

            // Get element type
            var elem_type *u8 = nil;
            var is_array i64 = 0;
            if base_type != nil {
                if type_kind(base_type) == TYPE_ARRAY {
                    elem_type = array_type_elem(base_type);
                    is_array = 1;
                } else if type_kind(base_type) == TYPE_PTR {
                    elem_type = ptr_type_elem(base_type);
                }
            }

            // Emit index expression
            llvm_emit_expr(index_expr);
            var index_val *u8 = str_dup(llvm_expr_result);

            // Get base address
            if is_array == 1 {
                llvm_emit_array_addr(base_expr);
            } else {
                llvm_emit_expr(base_expr);
            }
            var base_val *u8 = str_dup(llvm_expr_result);

            // Use getelementptr to compute address
            var gep_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(gep_temp);
            llvm_emit_str(" = getelementptr ");
            if elem_type != nil {
                llvm_emit_type(elem_type);
            } else {
                llvm_emit_str("i64");
            }
            llvm_emit_str(", ");
            if elem_type != nil {
                llvm_emit_type(elem_type);
            } else {
                llvm_emit_str("i64");
            }
            llvm_emit_str("* ");
            llvm_emit_str(base_val);
            llvm_emit_str(", i64 ");
            llvm_emit_str(index_val);
            llvm_emit_line("");

            // Store value - convert i64 to pointer if needed
            if elem_type != nil && type_kind(elem_type) == TYPE_PTR {
                // Convert i64 to pointer with inttoptr, then store
                var inttoptr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(inttoptr_temp);
                llvm_emit_str(" = inttoptr i64 ");
                llvm_emit_str(val);
                llvm_emit_line(" to i8*");
                llvm_emit_str("    store i8* %t");
                llvm_emit_int(inttoptr_temp);
                llvm_emit_str(", i8** %t");
                llvm_emit_int(gep_temp);
                llvm_emit_line("");
            } else {
                llvm_emit_str("    store ");
                if elem_type != nil {
                    llvm_emit_type(elem_type);
                } else {
                    llvm_emit_str("i64");
                }
                llvm_emit_str(" ");
                llvm_emit_str(val);
                llvm_emit_str(", ");
                if elem_type != nil {
                    llvm_emit_type(elem_type);
                } else {
                    llvm_emit_str("i64");
                }
                llvm_emit_str("* %t");
                llvm_emit_int(gep_temp);
                llvm_emit_line("");
            }

            return;
        }

        // Check for field assignment (p.x = value)
        if node_kind(target) == NODE_FIELD_EXPR {
            var base_expr *u8 = field_expr_expr(target);
            var field_name *u8 = field_expr_field(target);
            var field_len i64 = field_expr_field_len(target);

            // Get type of base expression to find struct
            var base_type *u8 = get_expr_type(base_expr);
            if base_type != nil {
                var struct_name *u8 = nil;
                var struct_name_len i64 = 0;
                var is_pointer i64 = 0;

                // Check if base is a direct struct or pointer to struct
                if type_kind(base_type) == TYPE_BASE {
                    struct_name = base_type_name(base_type);
                    struct_name_len = base_type_name_len(base_type);
                } else if type_kind(base_type) == TYPE_PTR {
                    var pointed_type *u8 = ptr_type_elem(base_type);
                    if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                        struct_name = base_type_name(pointed_type);
                        struct_name_len = base_type_name_len(pointed_type);
                        is_pointer = 1;
                    }
                }

                if struct_name != nil {
                    var struct_decl *u8 = find_struct(struct_name, struct_name_len);
                    if struct_decl != nil {
                        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
                        if field_offset >= 0 {
                            // Get base address
                            if is_pointer != 0 {
                                // Pointer to struct - evaluate to get address
                                llvm_emit_expr(base_expr);
                                var ptr_val *u8 = str_dup(llvm_expr_result);

                                // Add offset if needed
                                var addr_val *u8 = ptr_val;
                                if field_offset > 0 {
                                    var offset_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(offset_temp);
                                    llvm_emit_str(" = add i64 ");
                                    llvm_emit_str(ptr_val);
                                    llvm_emit_str(", ");
                                    llvm_emit_int(field_offset);
                                    llvm_emit_char(10);
                                    var buf *u8 = alloc(32);
                                    *buf = 37; *(buf+1) = 116;  // "%t"
                                    itoa(offset_temp, buf + 2);
                                    addr_val = buf;
                                }

                                // Check if field is an aggregate type (struct/enum)
                                var field_type *u8 = get_field_type(struct_decl, field_name, field_len);
                                var field_is_aggregate i64 = 0;
                                var field_agg_size i64 = 0;
                                if field_type != nil && type_kind(field_type) == TYPE_BASE {
                                    var ft_name *u8 = base_type_name(field_type);
                                    var ft_name_len i64 = base_type_name_len(field_type);
                                    var ft_struct *u8 = find_struct(ft_name, ft_name_len);
                                    if ft_struct != nil {
                                        field_is_aggregate = 1;
                                        field_agg_size = get_struct_size(ft_struct);
                                    } else {
                                        var ft_enum *u8 = find_enum(ft_name, ft_name_len);
                                        if ft_enum != nil {
                                            field_is_aggregate = 1;
                                            field_agg_size = get_enum_size(ft_enum);
                                        }
                                    }
                                }

                                if field_is_aggregate != 0 {
                                    // Copy aggregate bytes from source to field
                                    var copy_i i64 = 0;
                                    while copy_i < field_agg_size {
                                        // Source ptr
                                        var src_off_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(src_off_temp);
                                        llvm_emit_str(" = add i64 ");
                                        llvm_emit_str(val);
                                        llvm_emit_str(", ");
                                        llvm_emit_int(copy_i);
                                        llvm_emit_char(10);

                                        var src_ptr_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(src_ptr_temp);
                                        llvm_emit_str(" = inttoptr i64 %t");
                                        llvm_emit_int(src_off_temp);
                                        llvm_emit_line(" to i64*");

                                        var load_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(load_temp);
                                        llvm_emit_str(" = load i64, i64* %t");
                                        llvm_emit_int(src_ptr_temp);
                                        llvm_emit_char(10);

                                        // Dst ptr
                                        var dst_off_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(dst_off_temp);
                                        llvm_emit_str(" = add i64 ");
                                        llvm_emit_str(addr_val);
                                        llvm_emit_str(", ");
                                        llvm_emit_int(copy_i);
                                        llvm_emit_char(10);

                                        var dst_ptr_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(dst_ptr_temp);
                                        llvm_emit_str(" = inttoptr i64 %t");
                                        llvm_emit_int(dst_off_temp);
                                        llvm_emit_line(" to i64*");

                                        llvm_emit_str("    store i64 %t");
                                        llvm_emit_int(load_temp);
                                        llvm_emit_str(", i64* %t");
                                        llvm_emit_int(dst_ptr_temp);
                                        llvm_emit_char(10);

                                        copy_i = copy_i + 8;
                                    }
                                } else {
                                    // Store value to field
                                    var ptr_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(ptr_temp);
                                    llvm_emit_str(" = inttoptr i64 ");
                                    llvm_emit_str(addr_val);
                                    llvm_emit_line(" to i64*");

                                    llvm_emit_str("    store i64 ");
                                    llvm_emit_str(val);
                                    llvm_emit_str(", i64* %t");
                                    llvm_emit_int(ptr_temp);
                                    llvm_emit_char(10);
                                }
                            } else {
                                // Direct struct - base is the local variable
                                if node_kind(base_expr) == NODE_IDENT_EXPR {
                                    var name *u8 = ident_expr_name(base_expr);
                                    var name_len i64 = ident_expr_name_len(base_expr);

                                    // Check for let binding (unique name for aggregate vars)
                                    var actual_name *u8 = name;
                                    var actual_name_len i64 = name_len;
                                    var let_entry *u8 = llvm_find_let_binding(name, name_len);
                                    if let_entry != nil {
                                        actual_name = llvm_let_unique_name(let_entry);
                                        actual_name_len = llvm_let_unique_len(let_entry);
                                    }

                                    // Get address of struct
                                    var addr_temp i64 = llvm_next_temp();
                                    llvm_emit_str("    %t");
                                    llvm_emit_int(addr_temp);
                                    llvm_emit_str(" = ptrtoint [");
                                    var struct_size i64 = get_struct_size(struct_decl);
                                    llvm_emit_int(struct_size);
                                    llvm_emit_str(" x i8]* %");
                                    llvm_emit_n(actual_name, actual_name_len);
                                    llvm_emit_line(" to i64");

                                    // Add offset
                                    var addr_val *u8 = nil;
                                    if field_offset > 0 {
                                        var offset_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(offset_temp);
                                        llvm_emit_str(" = add i64 %t");
                                        llvm_emit_int(addr_temp);
                                        llvm_emit_str(", ");
                                        llvm_emit_int(field_offset);
                                        llvm_emit_char(10);
                                        var buf *u8 = alloc(32);
                                        *buf = 37; *(buf+1) = 116;  // "%t"
                                        itoa(offset_temp, buf + 2);
                                        addr_val = buf;
                                    } else {
                                        var buf *u8 = alloc(32);
                                        *buf = 37; *(buf+1) = 116;  // "%t"
                                        itoa(addr_temp, buf + 2);
                                        addr_val = buf;
                                    }

                                    // Check if field is an aggregate type (struct/enum)
                                    var field_type2 *u8 = get_field_type(struct_decl, field_name, field_len);
                                    var field_is_agg2 i64 = 0;
                                    var field_agg_size2 i64 = 0;
                                    if field_type2 != nil && type_kind(field_type2) == TYPE_BASE {
                                        var ft_name2 *u8 = base_type_name(field_type2);
                                        var ft_name_len2 i64 = base_type_name_len(field_type2);
                                        var ft_struct2 *u8 = find_struct(ft_name2, ft_name_len2);
                                        if ft_struct2 != nil {
                                            field_is_agg2 = 1;
                                            field_agg_size2 = get_struct_size(ft_struct2);
                                        } else {
                                            var ft_enum2 *u8 = find_enum(ft_name2, ft_name_len2);
                                            if ft_enum2 != nil {
                                                field_is_agg2 = 1;
                                                field_agg_size2 = get_enum_size(ft_enum2);
                                            }
                                        }
                                    }

                                    if field_is_agg2 != 0 {
                                        // Copy aggregate bytes from source to field
                                        var copy_j i64 = 0;
                                        while copy_j < field_agg_size2 {
                                            // Source ptr
                                            var soff_temp i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(soff_temp);
                                            llvm_emit_str(" = add i64 ");
                                            llvm_emit_str(val);
                                            llvm_emit_str(", ");
                                            llvm_emit_int(copy_j);
                                            llvm_emit_char(10);

                                            var sptr_temp i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(sptr_temp);
                                            llvm_emit_str(" = inttoptr i64 %t");
                                            llvm_emit_int(soff_temp);
                                            llvm_emit_line(" to i64*");

                                            var ld_temp i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(ld_temp);
                                            llvm_emit_str(" = load i64, i64* %t");
                                            llvm_emit_int(sptr_temp);
                                            llvm_emit_char(10);

                                            // Dst ptr
                                            var doff_temp i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(doff_temp);
                                            llvm_emit_str(" = add i64 ");
                                            llvm_emit_str(addr_val);
                                            llvm_emit_str(", ");
                                            llvm_emit_int(copy_j);
                                            llvm_emit_char(10);

                                            var dptr_temp i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(dptr_temp);
                                            llvm_emit_str(" = inttoptr i64 %t");
                                            llvm_emit_int(doff_temp);
                                            llvm_emit_line(" to i64*");

                                            llvm_emit_str("    store i64 %t");
                                            llvm_emit_int(ld_temp);
                                            llvm_emit_str(", i64* %t");
                                            llvm_emit_int(dptr_temp);
                                            llvm_emit_char(10);

                                            copy_j = copy_j + 8;
                                        }
                                    } else {
                                        // Store value to field
                                        var ptr_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(ptr_temp);
                                        llvm_emit_str(" = inttoptr i64 ");
                                        llvm_emit_str(addr_val);
                                        llvm_emit_line(" to i64*");

                                        llvm_emit_str("    store i64 ");
                                        llvm_emit_str(val);
                                        llvm_emit_str(", i64* %t");
                                        llvm_emit_int(ptr_temp);
                                        llvm_emit_char(10);
                                    }
                                } else {
                                    // Nested field access (e.g., r.origin.x = 10)
                                    // base_expr returns the address of the intermediate struct
                                    llvm_emit_expr(base_expr);
                                    var base_val *u8 = str_dup(llvm_expr_result);

                                    // Add field offset
                                    var addr_val *u8 = base_val;
                                    if field_offset > 0 {
                                        var offset_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(offset_temp);
                                        llvm_emit_str(" = add i64 ");
                                        llvm_emit_str(base_val);
                                        llvm_emit_str(", ");
                                        llvm_emit_int(field_offset);
                                        llvm_emit_char(10);
                                        var buf *u8 = alloc(32);
                                        *buf = 37; *(buf+1) = 116;  // "%t"
                                        itoa(offset_temp, buf + 2);
                                        addr_val = buf;
                                    }

                                    // Check if field is an aggregate type (struct/enum)
                                    var field_type3 *u8 = get_field_type(struct_decl, field_name, field_len);
                                    var field_is_agg3 i64 = 0;
                                    var field_agg_size3 i64 = 0;
                                    if field_type3 != nil && type_kind(field_type3) == TYPE_BASE {
                                        var ft_name3 *u8 = base_type_name(field_type3);
                                        var ft_name_len3 i64 = base_type_name_len(field_type3);
                                        var ft_struct3 *u8 = find_struct(ft_name3, ft_name_len3);
                                        if ft_struct3 != nil {
                                            field_is_agg3 = 1;
                                            field_agg_size3 = get_struct_size(ft_struct3);
                                        } else {
                                            var ft_enum3 *u8 = find_enum(ft_name3, ft_name_len3);
                                            if ft_enum3 != nil {
                                                field_is_agg3 = 1;
                                                field_agg_size3 = get_enum_size(ft_enum3);
                                            }
                                        }
                                    }

                                    if field_is_agg3 != 0 {
                                        // Copy aggregate bytes from source to field
                                        var copy_k i64 = 0;
                                        while copy_k < field_agg_size3 {
                                            // Source ptr
                                            var s3off i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(s3off);
                                            llvm_emit_str(" = add i64 ");
                                            llvm_emit_str(val);
                                            llvm_emit_str(", ");
                                            llvm_emit_int(copy_k);
                                            llvm_emit_char(10);

                                            var s3ptr i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(s3ptr);
                                            llvm_emit_str(" = inttoptr i64 %t");
                                            llvm_emit_int(s3off);
                                            llvm_emit_line(" to i64*");

                                            var l3tmp i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(l3tmp);
                                            llvm_emit_str(" = load i64, i64* %t");
                                            llvm_emit_int(s3ptr);
                                            llvm_emit_char(10);

                                            // Dst ptr
                                            var d3off i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(d3off);
                                            llvm_emit_str(" = add i64 ");
                                            llvm_emit_str(addr_val);
                                            llvm_emit_str(", ");
                                            llvm_emit_int(copy_k);
                                            llvm_emit_char(10);

                                            var d3ptr i64 = llvm_next_temp();
                                            llvm_emit_str("    %t");
                                            llvm_emit_int(d3ptr);
                                            llvm_emit_str(" = inttoptr i64 %t");
                                            llvm_emit_int(d3off);
                                            llvm_emit_line(" to i64*");

                                            llvm_emit_str("    store i64 %t");
                                            llvm_emit_int(l3tmp);
                                            llvm_emit_str(", i64* %t");
                                            llvm_emit_int(d3ptr);
                                            llvm_emit_char(10);

                                            copy_k = copy_k + 8;
                                        }
                                    } else {
                                        // Store value to field
                                        var ptr_temp i64 = llvm_next_temp();
                                        llvm_emit_str("    %t");
                                        llvm_emit_int(ptr_temp);
                                        llvm_emit_str(" = inttoptr i64 ");
                                        llvm_emit_str(addr_val);
                                        llvm_emit_line(" to i64*");

                                        llvm_emit_str("    store i64 ");
                                        llvm_emit_str(val);
                                        llvm_emit_str(", i64* %t");
                                        llvm_emit_int(ptr_temp);
                                        llvm_emit_char(10);
                                    }
                                }
                            }
                            return;
                        }
                    }
                }
            }
        }

        // Store to target (identifier)
        if node_kind(target) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(target);
            var len i64 = ident_expr_name_len(target);

            // Check for let binding (unique name mapping)
            var actual_name *u8 = name;
            var actual_name_len i64 = len;
            var let_entry *u8 = llvm_find_let_binding(name, len);
            if let_entry != nil {
                actual_name = llvm_let_unique_name(let_entry);
                actual_name_len = llvm_let_unique_len(let_entry);
            }

            // Check if target is an aggregate type (enum/struct)
            var local_idx i64 = find_local(name, len);
            var is_aggregate i64 = 0;
            var aggregate_size i64 = 0;
            if local_idx >= 0 {
                var local_type *u8 = local_get_type(local_idx);
                if local_type != nil && type_kind(local_type) == TYPE_BASE {
                    var type_name *u8 = base_type_name(local_type);
                    var type_name_len i64 = base_type_name_len(local_type);
                    var struct_decl *u8 = find_struct(type_name, type_name_len);
                    if struct_decl != nil {
                        is_aggregate = 1;
                        aggregate_size = get_struct_size(struct_decl);
                    } else {
                        var enum_decl *u8 = find_enum(type_name, type_name_len);
                        if enum_decl != nil {
                            is_aggregate = 1;
                            aggregate_size = get_enum_size(enum_decl);
                        }
                    }
                }
            }

            if is_aggregate != 0 {
                // Aggregate assignment: copy bytes from source to target
                // Note: actual_name/actual_len already set above from let binding lookup
                // val contains the address of the source data
                var dst_addr_temp i64 = llvm_next_temp();
                llvm_emit_str("    %t");
                llvm_emit_int(dst_addr_temp);
                llvm_emit_str(" = ptrtoint [");
                llvm_emit_int(aggregate_size);
                llvm_emit_str(" x i8]* %");
                llvm_emit_n(actual_name, actual_name_len);
                llvm_emit_line(" to i64");

                // Copy each 8-byte chunk
                var copy_i i64 = 0;
                while copy_i < aggregate_size {
                    // Load from source
                    var src_ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(src_ptr_temp);
                    llvm_emit_str(" = add i64 ");
                    llvm_emit_str(val);
                    llvm_emit_str(", ");
                    llvm_emit_int(copy_i);
                    llvm_emit_char(10);

                    var src_iptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(src_iptr_temp);
                    llvm_emit_str(" = inttoptr i64 %t");
                    llvm_emit_int(src_ptr_temp);
                    llvm_emit_line(" to i64*");

                    var load_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(load_temp);
                    llvm_emit_str(" = load i64, i64* %t");
                    llvm_emit_int(src_iptr_temp);
                    llvm_emit_char(10);

                    // Store to destination
                    var dst_ptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(dst_ptr_temp);
                    llvm_emit_str(" = add i64 %t");
                    llvm_emit_int(dst_addr_temp);
                    llvm_emit_str(", ");
                    llvm_emit_int(copy_i);
                    llvm_emit_char(10);

                    var dst_iptr_temp i64 = llvm_next_temp();
                    llvm_emit_str("    %t");
                    llvm_emit_int(dst_iptr_temp);
                    llvm_emit_str(" = inttoptr i64 %t");
                    llvm_emit_int(dst_ptr_temp);
                    llvm_emit_line(" to i64*");

                    llvm_emit_str("    store i64 %t");
                    llvm_emit_int(load_temp);
                    llvm_emit_str(", i64* %t");
                    llvm_emit_int(dst_iptr_temp);
                    llvm_emit_char(10);

                    copy_i = copy_i + 8;
                }
            } else {
                // Primitive assignment
                llvm_emit_str("    store i64 ");
                llvm_emit_str(val);
                if llvm_is_local(name, len) {
                    llvm_emit_str(", i64* %");
                    llvm_emit_n(actual_name, actual_name_len);
                } else if llvm_is_global(name, len) {
                    llvm_emit_str(", i64* @");
                    llvm_emit_n(name, len);  // Globals don't use let bindings
                } else {
                    // Assume local (parameter)
                    llvm_emit_str(", i64* %");
                    llvm_emit_n(actual_name, actual_name_len);
                }
                llvm_emit_char(10);
            }
        }
        return;
    }

    // Unknown statement - skip
}

func llvm_emit_block(block *u8) void {
    if block == nil {
        return;
    }

    var stmts *u8 = block_stmt_stmts(block);
    var count i64 = block_stmt_count(block);

    var i i64 = 0;
    while i < count {
        var stmt_ptr *u8 = stmts + (i * 8);
        var stmt **u8 = stmt_ptr;
        llvm_emit_stmt(*stmt);
        // Stop emitting if we hit a terminator (return, break, continue)
        if llvm_emitted_terminator == 1 {
            return;
        }
        i = i + 1;
    }
}

// ============================================================
// Function emission
// ============================================================

func llvm_emit_func(func_node *u8) void {
    // Register this function for return type lookup
    var name *u8 = func_decl_name(func_node);
    var name_len i64 = func_decl_name_len(func_node);
    var ret_type *u8 = func_decl_ret_type(func_node);
    llvm_register_func(name, name_len, ret_type);

    // Skip extern functions - they're just declarations
    if func_decl_is_extern(func_node) {
        // Emit as external declaration (name, name_len already set above)
        llvm_emit_str("declare ");
        llvm_emit_type(ret_type);
        llvm_emit_str(" @");
        llvm_emit_n(name, name_len);
        llvm_emit_str("(");

        // Check if this is open() - it's variadic in C (mode is optional)
        var is_open_extern i64 = 0;
        if name_len == 4 {
            if memcmp(name, "open", 4) {
                is_open_extern = 1;
            }
        }

        // Check if this is printf() - it's variadic
        var is_printf_extern i64 = 0;
        if name_len == 6 {
            if memcmp(name, "printf", 6) {
                is_printf_extern = 1;
            }
        }

        // Parameters - use i64 for all types for consistency with call sites
        var params *u8 = func_decl_params(func_node);
        var param_count i64 = func_decl_param_count(func_node);
        var i i64 = 0;
        while i < param_count {
            if i > 0 {
                llvm_emit_str(", ");
            }
            // For open(), emit first 2 params then ...
            if is_open_extern && i == 2 {
                llvm_emit_str("...");
                i = param_count;  // Skip remaining params
            } else if is_printf_extern {
                // printf: first param is i8*, then ...
                if i == 0 {
                    llvm_emit_str("i8*, ...");
                    i = param_count;  // Skip remaining params
                }
            } else {
                llvm_emit_str("i64");
                i = i + 1;
            }
        }

        llvm_emit_line(")");
        llvm_emit_char(10);
        return;
    }

    // name, name_len, ret_type already set above

    // Reset counters for each function
    llvm_temp_counter = 0;
    llvm_label_counter = 0;
    llvm_reset_locals();
    llvm_let_depth = 0;  // Reset let binding depth
    llvm_anon_local_counter = 0;  // Reset unique name counter
    cg_local_count = 0;  // Reset x86 backend's local tracking (for type info)
    llvm_current_ret_type = ret_type;

    // Set current emit module for visibility checking
    var func_idx i64 = find_func_index(name, name_len);
    if func_idx >= 0 {
        var mod_ptr *i64 = cg_func_module + (func_idx * 8);
        cg_emit_module = *mod_ptr;
    }

    // Function header
    llvm_emit_str("define ");
    llvm_emit_type(ret_type);
    llvm_emit_str(" @");
    llvm_emit_n(name, name_len);
    llvm_emit_str("(");

    // Parameters - emit proper types for each parameter
    // Name LLVM params with .arg suffix to allow shadowing
    var params *u8 = func_decl_params(func_node);
    var param_count i64 = func_decl_param_count(func_node);
    var i i64 = 0;
    while i < param_count {
        if i > 0 {
            llvm_emit_str(", ");
        }
        var p *u8 = params + (i * 24);
        var ptype *u8 = param_type(p);
        // Use actual type for floats, i64 for everything else
        if ptype != nil && llvm_is_float_type(ptype) {
            llvm_emit_type(ptype);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str(" %");
        llvm_emit_n(param_name(p), param_name_len(p));
        llvm_emit_str(".arg");
        i = i + 1;
    }

    // For main(), always emit full C signature: (argc, argv, envp)
    // The C runtime will pass these even if user's main() has no params
    var is_main i64 = 0;
    if name_len == 4 && *name == 'm' && *(name+1) == 'a' && *(name+2) == 'i' && *(name+3) == 'n' {
        is_main = 1;
        // Override params with standard C main signature
        // We need argc and argv to be in the right positions even if unused
        if param_count == 0 {
            llvm_emit_str("i64 %argc.hidden, i8** %argv.hidden, i8** %envp.hidden");
        } else if param_count == 1 {
            // User has 1 param (argc) - emit it plus hidden argv and envp
            llvm_emit_str(", i8** %argv.hidden, i8** %envp.hidden");
        } else if param_count == 2 {
            // User has 2 params (argc, argv) - emit them plus hidden envp
            llvm_emit_str(", i8** %envp.hidden");
        } else {
            // User has 3+ params - assume they have envp, just rename for consistency
            // Don't add anything extra
        }
    }

    llvm_emit_line(") {");

    // Entry block
    llvm_emit_line("L.entry:");

    // For main(), store envp to global for getenv lazy init
    // Cast pointer to i64 since that's how our codegen types globals
    if is_main == 1 {
        if param_count < 3 {
            // Used hidden envp param
            llvm_emit_line("    %___envp.cast = ptrtoint i8** %envp.hidden to i64");
        } else {
            // User has 3+ params, 3rd param is envp (typed as i64 in our codegen)
            var p *u8 = params + (2 * 24);
            llvm_emit_str("    %___envp.cast = add i64 0, %");
            llvm_emit_n(param_name(p), param_name_len(p));
            llvm_emit_line(".arg");
        }
        llvm_emit_line("    store i64 %___envp.cast, i64* @___envp");
    }

    // Shadow parameters with locals (so they can be assigned)
    i = 0;
    while i < param_count {
        var p *u8 = params + (i * 24);
        var pname *u8 = param_name(p);
        var pname_len i64 = param_name_len(p);
        var ptype *u8 = param_type(p);

        // Register as local (both LLVM and shared tracking for type info)
        llvm_add_local(pname, pname_len);
        add_local(pname, pname_len, 0, ptype);

        // Create unique name for SSA
        var unique_name *u8 = alloc(64);
        var up *u8 = unique_name;
        var ui i64 = 0;
        while ui < pname_len {
            *(up + ui) = *(pname + ui);
            ui = ui + 1;
        }
        *(up + pname_len) = 46;  // '.'
        itoa(llvm_anon_local_counter, up + pname_len + 1);
        llvm_anon_local_counter = llvm_anon_local_counter + 1;
        var actual_name_len i64 = strlen(unique_name);

        // Register let binding: pname -> unique_name
        llvm_push_let_binding(pname, pname_len, unique_name, actual_name_len);

        // Allocate local with unique name - use proper type for floats, i64 otherwise
        var is_float_param i64 = ptype != nil && llvm_is_float_type(ptype);
        llvm_emit_str("    %");
        llvm_emit_n(unique_name, actual_name_len);
        llvm_emit_str(" = alloca ");
        if is_float_param {
            llvm_emit_type(ptype);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_char(10);

        // Copy param.arg to local - use proper type for floats, i64 otherwise
        llvm_emit_str("    store ");
        if is_float_param {
            llvm_emit_type(ptype);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str(" %");
        llvm_emit_n(pname, pname_len);
        llvm_emit_str(".arg, ");
        if is_float_param {
            llvm_emit_type(ptype);
        } else {
            llvm_emit_str("i64");
        }
        llvm_emit_str("* %");
        llvm_emit_n(unique_name, actual_name_len);
        llvm_emit_char(10);

        i = i + 1;
    }

    // Reset terminator tracking
    llvm_emitted_terminator = 0;

    // Function body
    llvm_emit_block(func_decl_body(func_node));

    // For void functions, add implicit ret void if no explicit return
    var ret_type *u8 = func_decl_ret_type(func_node);
    if llvm_is_void_type(ret_type) {
        if llvm_emitted_terminator == 0 {
            llvm_emit_line("    ret void");
        }
    }

    llvm_emit_line("}");
    llvm_emit_char(10);
}

// ============================================================
// Program emission
// ============================================================

// Track which files have been included (to avoid duplicates)
var llvm_included_files *u8 = nil;

// Emit a reader as a callable LLVM function (for standalone compilers)
func llvm_emit_reader(reader_node *u8) void {
    var name *u8 = reader_decl_name(reader_node);
    var name_len i64 = reader_decl_name_len(reader_node);
    var pname *u8 = reader_decl_param_name(reader_node);
    var param_len i64 = reader_decl_param_len(reader_node);

    // Reset counters for this function
    llvm_temp_counter = 0;
    llvm_label_counter = 0;
    llvm_reset_locals();
    llvm_let_depth = 0;
    llvm_anon_local_counter = 0;
    cg_local_count = 0;

    // Build i64 type for return (we use i64 for all values including pointers)
    // Also build *u8 type for parameter type tracking
    var u8_type *u8 = base_type_alloc();
    base_type_set_name(u8_type, "u8");
    base_type_set_name_len(u8_type, 2);
    var ptr_u8_type *u8 = ptr_type_alloc();
    ptr_type_set_elem(ptr_u8_type, u8_type);

    // Create i64 type for return (consistent with function signature)
    var i64_type *u8 = base_type_alloc();
    base_type_set_name(i64_type, "i64");
    base_type_set_name_len(i64_type, 3);
    llvm_current_ret_type = i64_type;

    // Function header: define i64 @readername(i64 %param.arg) {
    llvm_emit_str("define i64 @");
    llvm_emit_n(name, name_len);
    llvm_emit_str("(i64 %");
    llvm_emit_n(pname, param_len);
    llvm_emit_line(".arg) {");

    // Entry block
    llvm_emit_line("L.entry:");

    // Register and shadow the parameter
    llvm_add_local(pname, param_len);
    add_local(pname, param_len, 0, ptr_u8_type);

    // Create unique name for SSA
    var unique_name *u8 = alloc(64);
    var up *u8 = unique_name;
    var ui i64 = 0;
    while ui < param_len {
        *(up + ui) = *(pname + ui);
        ui = ui + 1;
    }
    *(up + param_len) = 46;  // '.'
    itoa(llvm_anon_local_counter, up + param_len + 1);
    llvm_anon_local_counter = llvm_anon_local_counter + 1;
    var actual_name_len i64 = strlen(unique_name);

    // Register let binding
    llvm_push_let_binding(pname, param_len, unique_name, actual_name_len);

    // Allocate local with unique name
    llvm_emit_str("    %");
    llvm_emit_n(unique_name, actual_name_len);
    llvm_emit_line(" = alloca i64");

    // Copy param.arg to local
    llvm_emit_str("    store i64 %");
    llvm_emit_n(pname, param_len);
    llvm_emit_str(".arg, i64* %");
    llvm_emit_n(unique_name, actual_name_len);
    llvm_emit_char(10);

    // Reset terminator tracking
    llvm_emitted_terminator = 0;

    // Function body
    llvm_emit_block(reader_decl_body(reader_node));

    llvm_emit_line("}");
    llvm_emit_char(10);
}

// Helper: emit an array element value for global array initializers
// For pointer elements, emit the pointer directly (not ptrtoint)
// For non-pointer elements, emit the value directly
func llvm_emit_global_array_elem(init *u8, is_ptr i64) void {
    if init == nil {
        if is_ptr {
            llvm_emit_str("null");
        } else {
            llvm_emit_str("0");
        }
        return;
    }

    var kind i64 = node_kind(init);

    if kind == NODE_NUMBER_EXPR {
        var val *u8 = number_expr_value(init);
        var val_len i64 = number_expr_value_len(init);
        llvm_emit_n(val, val_len);
        return;
    }

    if kind == NODE_STRING_EXPR {
        // String literal - emit pointer to string
        var str_val *u8 = string_expr_value(init);
        var str_len i64 = string_expr_value_len(init);
        var idx i64 = llvm_add_string(str_val, str_len);

        // getelementptr inbounds ([N x i8], [N x i8]* @.strI, i64 0, i64 0)
        llvm_emit_str("getelementptr inbounds ([");
        llvm_emit_int(str_len + 1);
        llvm_emit_str(" x i8], [");
        llvm_emit_int(str_len + 1);
        llvm_emit_str(" x i8]* @.str");
        llvm_emit_int(idx);
        llvm_emit_str(", i64 0, i64 0)");
        return;
    }

    if kind == NODE_IDENT_EXPR {
        // Identifier - function pointer
        var ident_name *u8 = ident_expr_name(init);
        var ident_len i64 = ident_expr_name_len(init);
        llvm_emit_str("@");
        llvm_emit_n(ident_name, ident_len);
        return;
    }

    if kind == NODE_NIL_EXPR {
        if is_ptr {
            llvm_emit_str("null");
        } else {
            llvm_emit_str("0");
        }
        return;
    }

    // Unsupported - emit null/0
    if is_ptr {
        llvm_emit_str("null");
    } else {
        llvm_emit_str("0");
    }
}

// Helper: emit a constant expression value for global initializers
func llvm_emit_global_init_value(init *u8) void {
    if init == nil {
        llvm_emit_str("0");
        return;
    }

    var kind i64 = node_kind(init);

    if kind == NODE_NUMBER_EXPR {
        var val *u8 = number_expr_value(init);
        var val_len i64 = number_expr_value_len(init);
        llvm_emit_n(val, val_len);
        return;
    }

    if kind == NODE_STRING_EXPR {
        // String literal: use constant expression for pointer
        var str_val *u8 = string_expr_value(init);
        var str_len i64 = string_expr_value_len(init);
        var idx i64 = llvm_add_string(str_val, str_len);

        // ptrtoint (i8* getelementptr inbounds ([N x i8], [N x i8]* @.strI, i64 0, i64 0) to i64)
        llvm_emit_str("ptrtoint (i8* getelementptr inbounds ([");
        llvm_emit_int(str_len + 1);
        llvm_emit_str(" x i8], [");
        llvm_emit_int(str_len + 1);
        llvm_emit_str(" x i8]* @.str");
        llvm_emit_int(idx);
        llvm_emit_str(", i64 0, i64 0) to i64)");
        return;
    }

    if kind == NODE_IDENT_EXPR {
        // Identifier - could be a function pointer
        var ident_name *u8 = ident_expr_name(init);
        var ident_len i64 = ident_expr_name_len(init);
        // Emit: ptrtoint (i8* @funcname to i64)
        llvm_emit_str("ptrtoint (i8* @");
        llvm_emit_n(ident_name, ident_len);
        llvm_emit_str(" to i64)");
        return;
    }

    if kind == NODE_NIL_EXPR {
        llvm_emit_str("0");
        return;
    }

    // Unsupported initializer type - use 0
    llvm_emit_str("0");
}

func llvm_emit_decl(decl *u8) void {
    if decl == nil {
        return;
    }

    var k i64 = node_kind(decl);

    if k == NODE_FUNC_DECL {
        llvm_emit_func(decl);
        return;
    }

    if k == NODE_READER_DECL {
        // Generate reader as callable function (for standalone compilers)
        llvm_emit_reader(decl);
        return;
    }

    if k == NODE_INCLUDE_DECL {
        // Process included file
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);
        var path_str *u8 = str_dup_n(path, path_len);

        // Skip if already included
        if map_has(llvm_included_files, path_str) {
            return;
        }
        map_set(llvm_included_files, path_str, 1);

        // Read file
        var buf *u8 = alloc(1048576);  // 1MB max
        var n i64 = read_file_contents(path, path_len, buf, 1048576);
        if n < 0 {
            eprint("Error: cannot read include file: ");
            eprintln(path_str);
            return;
        }

        // Parse file
        var inc_prog *u8 = parse_program_from_string(buf);
        if inc_prog == nil {
            eprint("Error: cannot parse include file: ");
            eprintln(path_str);
            return;
        }

        // Emit declarations from included file
        var inc_decls *u8 = program_decls(inc_prog);
        var inc_count i64 = program_decl_count(inc_prog);
        var i i64 = 0;
        while i < inc_count {
            llvm_emit_decl(get_decl(inc_decls, i));
            i = i + 1;
        }
        return;
    }

    if k == NODE_REQUIRE_DECL {
        // Require resolution algorithm:
        // 1. Look for local source (./x/y.lang) - use if exists
        // 2. Check kernel built-ins - for distribution fallback
        //    -r mode: skip (links against kernel)
        //    normal mode: include AST
        var path *u8 = require_decl_module(decl);
        var path_len i64 = require_decl_module_len(decl);

        // Build full path for tracking (matches include tracking format)
        var full_path *u8 = alloc(path_len + 6);
        memcpy(full_path, path, path_len);
        memcpy(full_path + path_len, ".lang", 5);
        *(full_path + path_len + 5) = 0;
        var full_len i64 = path_len + 5;
        var path_str *u8 = str_dup_n(full_path, full_len);

        // Skip if already required
        if map_has(llvm_included_files, path_str) {
            return;
        }
        map_set(llvm_included_files, path_str, 1);

        // Check if local file exists (file_mtime returns 0 if not found)
        var local_exists i64 = file_mtime(full_path);

        if local_exists != 0 {
            // Local file found - read and parse it
            var buf *u8 = alloc(1048576);  // 1MB max
            var n i64 = read_file_contents(full_path, full_len, buf, 1048576);
            if n < 0 {
                eprint("Error: cannot read require file: ");
                eprintln(full_path);
                return;
            }

            var req_prog *u8 = parse_program_from_string(buf);
            if req_prog == nil {
                eprint("Error: cannot parse require file: ");
                eprintln(full_path);
                return;
            }

            // Emit declarations from local file
            var req_decls *u8 = program_decls(req_prog);
            var req_count i64 = program_decl_count(req_prog);
            var i i64 = 0;
            while i < req_count {
                llvm_emit_decl(get_decl(req_decls, i));
                i = i + 1;
            }
            return;
        }

        // Step 2: Check kernel built-ins (distribution fallback)
        var builtin_ast *u8 = find_kernel_builtin(path, path_len);
        if builtin_ast != nil {
            // -r mode: skip (module links against kernel's existing functions)
            if add_reader_mode != 0 {
                return;
            }

            // Normal mode: parse and emit the built-in AST
            var builtin_prog *u8 = parse_ast_from_string(builtin_ast);
            if builtin_prog == nil {
                eprint("Error: cannot parse kernel builtin: ");
                eprintln(path_str);
                return;
            }

            var req_decls *u8 = program_decls(builtin_prog);
            var req_count i64 = program_decl_count(builtin_prog);
            var i i64 = 0;
            while i < req_count {
                llvm_emit_decl(get_decl(req_decls, i));
                i = i + 1;
            }
            return;
        }

        // Step 3: Module not found
        eprint("Error: module not found: ");
        eprintln(path_str);
        return;
    }

    // NODE_MODULES_DECL is metadata - no code generation needed
    if k == NODE_MODULES_DECL {
        return;
    }

    if k == NODE_VAR_DECL {
        // Global variable declaration
        var name *u8 = var_decl_name(decl);
        var name_len i64 = var_decl_name_len(decl);
        var init *u8 = var_decl_init(decl);
        var is_extern i64 = var_decl_is_extern(decl);
        var var_type *u8 = var_decl_type(decl);

        // Register as global
        llvm_add_global(name, name_len);

        // Skip extern vars - they reference codegen-defined globals like ___envp
        if is_extern {
            return;
        }

        // Emit global
        llvm_emit_str("@");
        llvm_emit_n(name, name_len);
        llvm_emit_str(" = global ");

        // Check if this is an array type
        if var_type != nil && type_kind(var_type) == TYPE_ARRAY {
            var arr_size i64 = array_type_size(var_type);
            var elem_type *u8 = array_type_elem(var_type);
            var is_ptr_elem i64 = 0;
            if elem_type != nil && type_kind(elem_type) == TYPE_PTR {
                is_ptr_elem = 1;
            }

            // Emit array type: [N x T]
            llvm_emit_type(var_type);
            llvm_emit_str(" ");

            // Check if we have an array_literal initializer
            if init != nil && node_kind(init) == NODE_ARRAY_LITERAL {
                var elems *u8 = array_literal_elems(init);
                var count i64 = array_literal_count(init);

                // Emit [T val1, T val2, ..., T 0/null, ...]
                llvm_emit_str("[");
                var i i64 = 0;
                while i < arr_size {
                    if i > 0 {
                        llvm_emit_str(", ");
                    }
                    if i < count {
                        // Get element at index i
                        var elem_ptr **u8 = elems + (i * 8);
                        var elem *u8 = *elem_ptr;
                        llvm_emit_type(elem_type);
                        llvm_emit_str(" ");
                        llvm_emit_global_array_elem(elem, is_ptr_elem);
                    } else {
                        // Emit zero/null for remaining elements
                        llvm_emit_type(elem_type);
                        if is_ptr_elem {
                            llvm_emit_str(" null");
                        } else {
                            llvm_emit_str(" 0");
                        }
                    }
                    i = i + 1;
                }
                llvm_emit_str("]");
            } else {
                // No initializer or empty - use zeroinitializer
                llvm_emit_str("zeroinitializer");
            }
            llvm_emit_char(10);
            return;
        }

        // Non-array: emit i64 as before
        llvm_emit_str("i64 ");

        // Get initial value
        if init != nil {
            llvm_emit_global_init_value(init);
        } else {
            llvm_emit_str("0");
        }
        llvm_emit_char(10);
        return;
    }

    if k == NODE_READER_EXPR {
        // Reader macro at declaration level - expand and emit declarations
        var name *u8 = reader_expr_name(decl);
        var name_len i64 = reader_expr_name_len(decl);
        var content *u8 = reader_expr_content(decl);
        var content_len i64 = reader_expr_content_len(decl);

        // First check for embedded reader function (composed compilers)
        var embedded_func *u8 = find_embedded_reader_func(name, name_len);
        if embedded_func != nil {
            // Call embedded reader function directly (signature: fn(*u8) *u8)
            var reader_fn fn(*u8) *u8 = embedded_func;
            var output *u8 = reader_fn(content);
            if output != nil {
                // Parse output as S-expr AST (readers MUST output AST)
                var prog *u8 = parse_ast_from_string(output);
                if prog != nil {
                    var inc_decls *u8 = program_decls(prog);
                    var inc_count i64 = program_decl_count(prog);
                    var i i64 = 0;
                    while i < inc_count {
                        llvm_emit_decl(get_decl(inc_decls, i));
                        i = i + 1;
                    }
                }
            }
            return;
        }

        // Fall back to external executable
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            return;  // Error already reported
        }

        // Build path to reader executable
        var exe_path *u8 = build_reader_cache_path(name, name_len);

        // Execute reader with content as input
        var output *u8 = alloc(131072);  // 128KB
        var n i64 = exec_capture(exe_path, content, content_len, output, 131072);

        if n <= 0 {
            return;
        }

        // Parse output as S-expr AST (readers MUST output AST)
        var prog *u8 = parse_ast_from_string(output);
        if prog != nil {
            var inc_decls *u8 = program_decls(prog);
            var inc_count i64 = program_decl_count(prog);
            var i i64 = 0;
            while i < inc_count {
                llvm_emit_decl(get_decl(inc_decls, i));
                i = i + 1;
            }
        }
        return;
    }

    // TODO: other declaration types (structs, etc.)
}

// Map to track included files for first pass
var llvm_first_pass_included *u8 = nil;

// First pass helper: process a single declaration
func llvm_register_decl(decl *u8) void {
    if decl == nil {
        return;
    }
    var k i64 = node_kind(decl);
    if k == NODE_STRUCT_DECL {
        add_struct(decl);
    } else if k == NODE_ENUM_DECL {
        add_enum(decl);
    } else if k == NODE_MACRO_DECL {
        add_macro(decl);
    } else if k == NODE_READER_DECL {
        add_reader(decl);
    } else if k == NODE_FUNC_DECL {
        var name *u8 = func_decl_name(decl);
        var name_len i64 = func_decl_name_len(decl);
        var ret_type *u8 = func_decl_ret_type(decl);
        llvm_register_func(name, name_len, ret_type);
        // Also add to shared registry for find_func
        add_func(decl);
    } else if k == NODE_VAR_DECL {
        // Global variable - register so llvm_is_global works AND get_expr_type works
        var name *u8 = var_decl_name(decl);
        var name_len i64 = var_decl_name_len(decl);
        var var_type *u8 = var_decl_type(decl);
        var var_init *u8 = var_decl_init(decl);
        var is_extern i64 = var_decl_is_extern(decl);
        var is_pub i64 = var_decl_is_pub(decl);
        llvm_add_global(name, name_len);
        add_global(name, name_len, var_type, var_init, is_extern, is_pub);  // Register type for get_expr_type
    } else if k == NODE_INCLUDE_DECL {
        // Recursively process included file
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Skip if already included
        var path_key *u8 = str_dup_n(path, path_len);
        if map_has(llvm_first_pass_included, path_key) {
            return;
        }
        map_set(llvm_first_pass_included, path_key, 1);

        // Build path string
        var path_str *u8 = str_dup_n(path, path_len);

        // Read and parse include file
        var buf *u8 = alloc(1024 * 1024);  // 1MB buffer
        var buf_cap i64 = 1024 * 1024;
        var fd i64 = file_open(path_str, 0);
        if fd < 0 {
            return;
        }
        var n i64 = file_read(fd, buf, buf_cap);
        file_close(fd);
        if n < 0 {
            return;
        }
        *(buf + n) = 0;

        // Parse file
        var inc_prog *u8 = parse_program_from_string(buf);
        if inc_prog == nil {
            return;
        }

        // Save and set current file context (for reader compilation in included files)
        var saved_file_decls *u8 = cg_current_file_decls;
        var saved_file_count i64 = cg_current_file_decl_count;
        var inc_decls *u8 = program_decls(inc_prog);
        var inc_count i64 = program_decl_count(inc_prog);
        cg_current_file_decls = inc_decls;
        cg_current_file_decl_count = inc_count;

        // Process declarations from included file
        var i i64 = 0;
        while i < inc_count {
            llvm_register_decl(get_decl(inc_decls, i));
            i = i + 1;
        }

        // Restore file context
        cg_current_file_decls = saved_file_decls;
        cg_current_file_decl_count = saved_file_count;
    } else if k == NODE_REQUIRE_DECL {
        // Require resolution (registration pass) - same algorithm as emit pass
        var path *u8 = require_decl_module(decl);
        var path_len i64 = require_decl_module_len(decl);

        // Build full path for tracking (matches include tracking format)
        var full_path *u8 = alloc(path_len + 6);
        memcpy(full_path, path, path_len);
        memcpy(full_path + path_len, ".lang", 5);
        *(full_path + path_len + 5) = 0;
        var full_len i64 = path_len + 5;
        var path_str *u8 = str_dup_n(full_path, full_len);

        // Skip if already required
        if map_has(llvm_first_pass_included, path_str) {
            return;
        }
        map_set(llvm_first_pass_included, path_str, 1);

        var local_exists i64 = file_mtime(full_path);
        var req_prog *u8 = nil;

        if local_exists != 0 {
            var buf *u8 = alloc(1024 * 1024);
            var fd i64 = file_open(str_dup_n(full_path, full_len), 0);
            if fd < 0 {
                eprint("error: cannot open require file: ");
                eprint_buf(path, path_len);
                eprintln("");
                return;
            }
            var n i64 = file_read(fd, buf, 1024 * 1024);
            file_close(fd);
            if n < 0 { return; }
            *(buf + n) = 0;

            req_prog = parse_program_from_string(buf);
            if req_prog == nil {
                eprint("error: failed to parse require file: ");
                eprint_buf(path, path_len);
                eprintln("");
                return;
            }
        } else {
            // Step 2: Check kernel built-ins
            var builtin_ast *u8 = find_kernel_builtin(path, path_len);
            if builtin_ast != nil {
                // -r mode: skip (already in kernel)
                if add_reader_mode != 0 {
                    return;
                }
                req_prog = parse_ast_from_string(builtin_ast);
                if req_prog == nil {
                    eprint("error: cannot parse kernel builtin: ");
                    eprint_buf(path, path_len);
                    eprintln("");
                    return;
                }
            } else {
                // Not found
                return;
            }
        }

        // Switch to new module ID for visibility tracking
        var saved_module i64 = cg_current_module;
        cg_current_module = cg_next_module;
        cg_next_module = cg_next_module + 1;

        var saved_file_decls *u8 = cg_current_file_decls;
        var saved_file_count i64 = cg_current_file_decl_count;
        var req_decls *u8 = program_decls(req_prog);
        var req_count i64 = program_decl_count(req_prog);
        cg_current_file_decls = req_decls;
        cg_current_file_decl_count = req_count;

        var i i64 = 0;
        while i < req_count {
            llvm_register_decl(get_decl(req_decls, i));
            i = i + 1;
        }

        cg_current_file_decls = saved_file_decls;
        cg_current_file_decl_count = saved_file_count;
        cg_current_module = saved_module;
    } else if k == NODE_READER_DECL {
        add_reader(decl);
    } else if k == NODE_EFFECT_DECL {
        llvm_add_effect(decl);
    } else if k == NODE_MODULES_DECL {
        // Metadata node - no registration needed
    }
}

// First pass: register top-level declarations (structs and functions)
func llvm_register_all_decls(prog *u8) void {
    llvm_first_pass_included = map_new();
    var decls *u8 = program_decls(prog);
    var count i64 = program_decl_count(prog);
    var i i64 = 0;
    while i < count {
        llvm_register_decl(get_decl(decls, i));
        i = i + 1;
    }
}

// Generate a single lambda function
func llvm_gen_lambda(lambda_node *u8, lambda_id i64, captures *u8, capture_count i64) void {
    // Reset temp counter and locals for this lambda
    llvm_temp_counter = 0;
    llvm_emitted_terminator = 0;
    cg_local_count = 0;
    llvm_let_depth = 0;
    llvm_anon_local_counter = 0;

    var param_count i64 = lambda_expr_param_count(lambda_node);
    var ret_type *u8 = lambda_expr_ret_type(lambda_node);

    // Emit function signature
    // With captures: define i64 @__lambda_N(i8* %closure, i64 %a.arg, ...) {
    // Without: define i64 @__lambda_N(i64 %a.arg, ...) {
    llvm_emit_str("define ");
    if is_void_type(ret_type) {
        llvm_emit_str("void");
    } else {
        llvm_emit_str("i64");
    }
    llvm_emit_str(" @__lambda_");
    llvm_emit_int(lambda_id);
    llvm_emit_str("(");

    // Add closure pointer as first param if has captures
    if capture_count > 0 {
        llvm_emit_str("i8* %closure");
        if param_count > 0 {
            llvm_emit_str(", ");
        }
    }

    // Emit user parameters
    var params *u8 = lambda_expr_params(lambda_node);
    var i i64 = 0;
    while i < param_count {
        if i > 0 {
            llvm_emit_str(", ");
        }
        var p *u8 = params + (i * 24);
        llvm_emit_str("i64 %");
        llvm_emit_n(param_name(p), param_name_len(p));
        llvm_emit_str(".arg");
        i = i + 1;
    }
    llvm_emit_line(") {");

    // Entry label
    llvm_emit_line("L.entry:");

    // Load captures from closure into local variables
    if capture_count > 0 {
        i = 0;
        while i < capture_count {
            var cap_entry *u8 = captures + (i * 32);
            var p_name **u8 = cap_entry;
            var cap_name *u8 = *p_name;
            var p_len *i64 = cap_entry + 8;
            var cap_len i64 = *p_len;
            // Capture type is at offset 24
            var p_type **u8 = cap_entry + 24;
            var cap_type *u8 = *p_type;

            var cap_offset i64 = 16 + (i * 8);

            // Allocate local for captured variable
            llvm_emit_str("    %");
            llvm_emit_n(cap_name, cap_len);
            llvm_emit_line(" = alloca i64");

            // Calculate address in closure: getelementptr i8, i8* %closure, i64 offset
            var gep_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(gep_temp);
            llvm_emit_str(" = getelementptr i8, i8* %closure, i64 ");
            llvm_emit_int(cap_offset);
            llvm_emit_char(10);

            // Cast to i64*
            var ptr_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(ptr_temp);
            llvm_emit_str(" = bitcast i8* %t");
            llvm_emit_int(gep_temp);
            llvm_emit_line(" to i64*");

            // Load value
            var val_temp i64 = llvm_next_temp();
            llvm_emit_str("    %t");
            llvm_emit_int(val_temp);
            llvm_emit_str(" = load i64, i64* %t");
            llvm_emit_int(ptr_temp);
            llvm_emit_char(10);

            // Store to local
            llvm_emit_str("    store i64 %t");
            llvm_emit_int(val_temp);
            llvm_emit_str(", i64* %");
            llvm_emit_n(cap_name, cap_len);
            llvm_emit_char(10);

            // Register as local with type (for field access)
            llvm_add_local(cap_name, cap_len);
            add_local(cap_name, cap_len, 0, cap_type);

            i = i + 1;
        }
    }

    // Store parameters to stack
    i = 0;
    while i < param_count {
        var p *u8 = params + (i * 24);
        var pname *u8 = param_name(p);
        var plen i64 = param_name_len(p);

        // %name = alloca i64
        llvm_emit_str("    %");
        llvm_emit_n(pname, plen);
        llvm_emit_line(" = alloca i64");

        // store i64 %name.arg, i64* %name
        llvm_emit_str("    store i64 %");
        llvm_emit_n(pname, plen);
        llvm_emit_str(".arg, i64* %");
        llvm_emit_n(pname, plen);
        llvm_emit_char(10);

        // Register local
        llvm_add_local(pname, plen);

        i = i + 1;
    }

    // Store return type for this function
    llvm_current_ret_type = ret_type;

    // Generate body
    var body *u8 = lambda_expr_body(lambda_node);
    llvm_emit_block(body);

    // Default return if needed
    if llvm_emitted_terminator == 0 {
        if is_void_type(ret_type) {
            llvm_emit_line("    ret void");
        } else {
            llvm_emit_line("    ret i64 0");
        }
    }

    llvm_emit_line("}");
    llvm_emit_char(10);
}

// Generate all collected lambdas
func llvm_gen_all_lambdas() void {
    var i i64 = 0;
    while i < llvm_lambda_count {
        var entry *u8 = llvm_lambdas + (i * 32);
        var p_node **u8 = entry;
        var lambda_node *u8 = *p_node;
        var p_id *i64 = entry + 8;
        var lambda_id i64 = *p_id;
        var p_captures **u8 = entry + 16;
        var captures *u8 = *p_captures;
        var p_cap_count *i64 = entry + 24;
        var capture_count i64 = *p_cap_count;
        llvm_gen_lambda(lambda_node, lambda_id, captures, capture_count);
        i = i + 1;
    }
}

func generate_llvm(prog *u8, output_file *u8) void {
    cg_has_llvm_backend = 1;  // Mark LLVM backend available for reader compilation
    cg_generate_llvm_fn = &generate_llvm;  // Set function pointer for fork-self
    llvm_init_output(output_file);
    llvm_included_files = map_new();
    llvm_init_func_table();
    llvm_init_globals();
    llvm_init_loop_stack();
    llvm_init_effects();
    llvm_init_strings();
    llvm_init_lambdas();
    llvm_init_let_bindings();

    // Initialize x86 backend's shared tracking
    cg_locals = alloc(LIMIT_LOCALS * 32);
    cg_local_count = 0;
    cg_globals = alloc(LIMIT_GLOBALS * 32);
    cg_global_count = 0;
    cg_structs = alloc(LIMIT_STRUCTS * 24);
    cg_struct_count = 0;
    cg_funcs = alloc(LIMIT_FUNCS * 24);
    cg_func_count = 0;
    cg_enums = alloc(LIMIT_ENUMS * 24);
    cg_enum_count = 0;
    cg_readers = alloc(LIMIT_READERS * 24);
    cg_reader_count = 0;
    cg_macros = alloc(LIMIT_MACROS * 24);
    cg_macro_count = 0;

    // Initialize visibility tracking arrays
    cg_func_is_pub = alloc(LIMIT_FUNCS * 8);
    cg_global_is_pub = alloc(LIMIT_GLOBALS * 8);
    cg_struct_is_pub = alloc(LIMIT_STRUCTS * 8);
    cg_enum_is_pub = alloc(LIMIT_ENUMS * 8);
    cg_effect_is_pub = alloc(LIMIT_EFFECTS * 8);
    cg_reader_is_pub = alloc(LIMIT_READERS * 8);

    // Initialize module tracking arrays
    cg_func_module = alloc(LIMIT_FUNCS * 8);
    cg_global_module = alloc(LIMIT_GLOBALS * 8);
    cg_struct_module = alloc(LIMIT_STRUCTS * 8);
    cg_enum_module = alloc(LIMIT_ENUMS * 8);
    cg_current_module = 0;
    cg_next_module = 1;

    // Initialize macro interpreter
    interp_init();

    // Set current file declarations for reader compilation
    cg_current_file_decls = program_decls(prog);
    cg_current_file_decl_count = program_decl_count(prog);

    // First pass: register structs and functions
    llvm_register_all_decls(prog);

    // Module header
    llvm_emit_line("; LLVM IR generated by lang compiler");
    // Emit target triple based on LANGOS environment variable
    var langos *u8 = getenv("LANGOS");
    var is_macos i64 = 0;
    if langos != nil {
        // Check if langos == "macos" (5 chars + null)
        if *langos == 'm' && *(langos+1) == 'a' && *(langos+2) == 'c' && *(langos+3) == 'o' && *(langos+4) == 's' && *(langos+5) == 0 {
            is_macos = 1;
        }
    }
    if is_macos {
        llvm_emit_line("target triple = \"arm64-apple-macosx\"");
        llvm_is_arm64 = 1;
    } else {
        llvm_emit_line("target triple = \"x86_64-unknown-linux-gnu\"");
        llvm_is_arm64 = 0;
    }
    llvm_emit_char(10);

    // Declare external syscall (variadic)
    llvm_emit_line("declare i64 @syscall(i64, ...)");
    llvm_emit_char(10);

    // Global variables for effect handling
    llvm_emit_line("@__handler_set = internal global i64 0");
    llvm_emit_line("@__handler_rbp = internal global i64 0");
    llvm_emit_line("@__handler_rsp = internal global i64 0");
    llvm_emit_line("@__handler_addr = internal global i64 0");
    llvm_emit_line("@__effect_value = internal global i64 0");
    llvm_emit_line("@__continuation_ptr = internal global i8* null");
    llvm_emit_line("@__effect_name_ptr = internal global i8* null");
    llvm_emit_line("@__effect_name_len = internal global i64 0");
    llvm_emit_line("@__resume_value = internal global i64 0");
    llvm_emit_char(10);

    // Environment pointer for getenv lazy init (matches x86 codegen)
    // Type as i64 to match how our codegen treats all globals
    llvm_emit_line("@___envp = global i64 0");
    llvm_emit_char(10);

    // Emit all declarations
    var decls *u8 = program_decls(prog);
    var count i64 = program_decl_count(prog);

    var i i64 = 0;
    while i < count {
        var decl *u8 = get_decl(decls, i);
        llvm_emit_decl(decl);
        i = i + 1;
    }

    // Emit collected lambdas
    llvm_gen_all_lambdas();

    // Emit string constants at end of module
    llvm_emit_all_strings();

    llvm_flush();
}
