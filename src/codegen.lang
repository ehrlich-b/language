// src/codegen.lang - x86-64 code generator for self-hosting compiler
// Emits GNU as compatible assembly

include "src/limits.lang"

// ============================================================
// Codegen state (global)
// ============================================================

var cg_out_fd i64 = 0;           // output file descriptor
var cg_label_num i64 = 0;        // for generating unique labels

// Locals array: each entry is [name_ptr:8][name_len:8][offset:8][type_ptr:8] = 32 bytes
// Max 1024 locals
var cg_locals *u8 = nil;
var cg_local_count i64 = 0;
var cg_stack_size i64 = 0;

// Globals array: each entry is [name_ptr:8][name_len:8][type_ptr:8][init_ptr:8] = 32 bytes
// Max 1000 globals
var cg_globals *u8 = nil;
var cg_global_count i64 = 0;

// Strings array: each entry is [str_ptr:8][str_len:8] = 16 bytes
// Max 1000 strings
var cg_strings *u8 = nil;
var cg_string_count i64 = 0;

// Output buffer for code (collect code first, emit strings/globals first)
var cg_code_buf *u8 = nil;
var cg_code_len i64 = 0;
var cg_code_cap i64 = 0;

// Temporary buffer for function bodies (to calculate stack size before prologue)
var cg_func_buf *u8 = nil;
var cg_func_len i64 = 0;
var cg_func_cap i64 = 0;
var cg_in_func_body i64 = 0;  // 1 = emit to func_buf, 0 = emit to code_buf

// Struct registry: simple array of struct decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 structs
var cg_structs *u8 = nil;
var cg_struct_count i64 = 0;

// Enum registry: simple array of enum decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 enums
var cg_enums *u8 = nil;
var cg_enum_count i64 = 0;

// Macro registry: simple array of macro decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 macros
var cg_macros *u8 = nil;
var cg_macro_count i64 = 0;

// Reader registry: simple array of reader decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 readers
var cg_readers *u8 = nil;
var cg_reader_count i64 = 0;

// Function registry: simple array of func decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 500 functions
var cg_funcs *u8 = nil;
var cg_func_count i64 = 0;

// Lambda registry: collect lambdas during codegen, emit at end
// Each entry: [lambda_node:8][name_id:8][captures_ptr:8][capture_count:8] = 32 bytes
// Max 500 lambdas
var cg_lambdas *u8 = nil;
var cg_lambda_count i64 = 0;

// Capture tracking during lambda analysis
// Each capture entry: [name_ptr:8][name_len:8][outer_offset:8][type:8] = 32 bytes
var cg_current_captures *u8 = nil;
var cg_current_capture_count i64 = 0;

// Scope marker for distinguishing outer vs inner locals during capture analysis
var cg_lambda_scope_start i64 = 0;

// Parent closure captures - used for nested lambdas to find captures from enclosing closures
var cg_parent_captures *u8 = nil;
var cg_parent_capture_count i64 = 0;

// Closure context for generating closure bodies
var cg_in_closure i64 = 0;                // 1 if generating a closure body
var cg_closure_ptr_offset i64 = 0;        // Stack offset where closure ptr is stored
var cg_closure_captures *u8 = nil;        // Captures array for current closure
var cg_closure_capture_count i64 = 0;     // Number of captures

// Effect registry: simple array of effect decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 effects
var cg_effects *u8 = nil;
var cg_effect_count i64 = 0;

// Handler stack for runtime effect handling
// This tracks the handler depth at codegen time (for labels)
var cg_handler_depth i64 = 0;

// Include stack for loop detection
// Each entry: [path_ptr:8][path_len:8] = 16 bytes
// Max 32 nested includes
var cg_include_stack *u8 = nil;
var cg_include_count i64 = 0;

// Map of already-included files (prevents duplicate processing)
var cg_included_files *u8 = nil;

// Debug flag: print macro expansions
var cg_expand_macros i64 = 0;  // v2

// Loop label stack for break/continue
// Each entry: [name_ptr:8][name_len:8][break_label:8][continue_label:8] = 32 bytes
// Max 32 nested loops
var cg_loop_stack *u8 = nil;
var cg_loop_depth i64 = 0;

func loop_stack_push(name *u8, name_len i64, break_label i64, continue_label i64) void {
    if cg_loop_stack == nil {
        cg_loop_stack = alloc(LIMIT_LOOP_DEPTH * 32);
    }
    var entry *u8 = cg_loop_stack + (cg_loop_depth * 32);
    var p_name **u8 = entry;
    *p_name = name;
    var p_len *i64 = entry + 8;
    *p_len = name_len;
    var p_break *i64 = entry + 16;
    *p_break = break_label;
    var p_cont *i64 = entry + 24;
    *p_cont = continue_label;
    cg_loop_depth = cg_loop_depth + 1;
}

func loop_stack_pop() void {
    if cg_loop_depth > 0 {
        cg_loop_depth = cg_loop_depth - 1;
    }
}

func loop_stack_find(name *u8, name_len i64) *u8 {
    // Search from top of stack (innermost loop first)
    var i i64 = cg_loop_depth - 1;
    while i >= 0 {
        var entry *u8 = cg_loop_stack + (i * 32);
        var p_name **u8 = entry;
        var entry_name *u8 = *p_name;
        var p_len *i64 = entry + 8;
        var entry_len i64 = *p_len;

        if name == nil {
            // No label specified, return innermost loop
            return entry;
        }
        if entry_name != nil && entry_len == name_len {
            // Compare names
            var is_match i64 = 1;
            var j i64 = 0;
            while j < name_len {
                if *(name + j) != *(entry_name + j) {
                    is_match = 0;
                }
                j = j + 1;
            }
            if is_match == 1 {
                return entry;
            }
        }
        i = i - 1;
    }
    return nil;
}

func loop_entry_break_label(entry *u8) i64 {
    var p *i64 = entry + 16;
    return *p;
}

func loop_entry_continue_label(entry *u8) i64 {
    var p *i64 = entry + 24;
    return *p;
}

// Program declarations (for interpreter function calls)
var cg_decls *u8 = nil;
var cg_decl_count i64 = 0;

// Workaround for codegen bug - temp storage
var cg_temp_struct_decl *u8 = nil;

// Current file context (for reader compilation)
var cg_current_file_decls *u8 = nil;
var cg_current_file_decl_count i64 = 0;
var cg_in_scoped_context i64 = 0;  // 1 when processing included files

// ============================================================
// Initialization
// ============================================================

func codegen_init() void {
    cg_locals = alloc(LIMIT_LOCALS * 32);
    cg_local_count = 0;
    cg_stack_size = 0;

    cg_globals = alloc(LIMIT_GLOBALS * 32);
    cg_global_count = 0;

    cg_strings = alloc(LIMIT_STRINGS * 16);
    cg_string_count = 0;

    cg_code_buf = alloc(SIZE_CODE_BUF);
    cg_code_len = 0;
    cg_code_cap = SIZE_CODE_BUF;

    cg_func_buf = alloc(SIZE_FUNC_BUF);
    cg_func_len = 0;
    cg_func_cap = SIZE_FUNC_BUF;
    cg_in_func_body = 0;

    cg_label_num = 0;

    cg_structs = alloc(LIMIT_STRUCTS * 24);
    cg_struct_count = 0;

    cg_enums = alloc(LIMIT_ENUMS * 24);
    cg_enum_count = 0;

    cg_effects = alloc(LIMIT_EFFECTS * 24);
    cg_effect_count = 0;

    cg_macros = alloc(LIMIT_MACROS * 24);
    cg_macro_count = 0;

    cg_readers = alloc(LIMIT_READERS * 24);
    cg_reader_count = 0;

    cg_funcs = alloc(LIMIT_FUNCS * 24);
    cg_func_count = 0;

    cg_include_stack = alloc(LIMIT_INCLUDE_DEPTH * 16);
    cg_include_count = 0;

    cg_included_files = map_new();
}

// ============================================================
// Local variable accessors
// ============================================================

func local_get_name(index i64) *u8 {
    var p **u8 = cg_locals + (index * 32);
    return *p;
}

func local_set_name(index i64, ptr *u8) void {
    var p **u8 = cg_locals + (index * 32);
    *p = ptr;
}

func local_get_name_len(index i64) i64 {
    var p *i64 = cg_locals + (index * 32) + 8;
    return *p;
}

func local_set_name_len(index i64, len i64) void {
    var p *i64 = cg_locals + (index * 32) + 8;
    *p = len;
}

func local_get_offset(index i64) i64 {
    var p *i64 = cg_locals + (index * 32) + 16;
    return *p;
}

func local_set_offset(index i64, off i64) void {
    var p *i64 = cg_locals + (index * 32) + 16;
    *p = off;
}

func local_get_type(index i64) *u8 {
    var p **u8 = cg_locals + (index * 32) + 24;
    return *p;
}

func local_set_type(index i64, t *u8) void {
    var p **u8 = cg_locals + (index * 32) + 24;
    *p = t;
}

func find_local(name *u8, name_len i64) i64 {
    // Search from end (most recent) to find correct variable in shadowing cases
    var i i64 = cg_local_count - 1;
    while i >= 0 {
        if local_get_name_len(i) == name_len {
            if memcmp(local_get_name(i), name, name_len) {
                return i;
            }
        }
        i = i - 1;
    }
    return 0 - 1;  // -1 not found
}

func add_local(name *u8, name_len i64, offset i64, t *u8) void {
    local_set_name(cg_local_count, name);
    local_set_name_len(cg_local_count, name_len);
    local_set_offset(cg_local_count, offset);
    local_set_type(cg_local_count, t);
    cg_local_count = cg_local_count + 1;
}

// ============================================================
// Capture accessors (for closures)
// Each entry: [name_ptr:8][name_len:8][outer_offset:8][type:8] = 32 bytes
// ============================================================

func capture_get_name(index i64) *u8 {
    var p **u8 = cg_current_captures + (index * 32);
    return *p;
}

func capture_set_name(index i64, ptr *u8) void {
    var p **u8 = cg_current_captures + (index * 32);
    *p = ptr;
}

func capture_get_name_len(index i64) i64 {
    var p *i64 = cg_current_captures + (index * 32) + 8;
    return *p;
}

func capture_set_name_len(index i64, len i64) void {
    var p *i64 = cg_current_captures + (index * 32) + 8;
    *p = len;
}

func capture_get_outer_offset(index i64) i64 {
    var p *i64 = cg_current_captures + (index * 32) + 16;
    return *p;
}

func capture_set_outer_offset(index i64, off i64) void {
    var p *i64 = cg_current_captures + (index * 32) + 16;
    *p = off;
}

func capture_get_type(index i64) *u8 {
    var p **u8 = cg_current_captures + (index * 32) + 24;
    return *p;
}

func capture_set_type(index i64, t *u8) void {
    var p **u8 = cg_current_captures + (index * 32) + 24;
    *p = t;
}

func find_capture(name *u8, name_len i64) i64 {
    var i i64 = 0;
    while i < cg_current_capture_count {
        if capture_get_name_len(i) == name_len {
            if memcmp(capture_get_name(i), name, name_len) {
                return i;
            }
        }
        i = i + 1;
    }
    return 0 - 1;  // -1 not found
}

func add_capture(name *u8, name_len i64, outer_offset i64, t *u8) void {
    // Check if already captured
    if find_capture(name, name_len) >= 0 {
        return;  // Already in capture list
    }
    capture_set_name(cg_current_capture_count, name);
    capture_set_name_len(cg_current_capture_count, name_len);
    capture_set_outer_offset(cg_current_capture_count, outer_offset);
    capture_set_type(cg_current_capture_count, t);
    cg_current_capture_count = cg_current_capture_count + 1;
}

func init_capture_tracking() void {
    if cg_current_captures == nil {
        cg_current_captures = alloc(LIMIT_CAPTURES * 32);
    }
    cg_current_capture_count = 0;
}

// Find a variable in parent captures (for nested lambdas)
// Returns index if found, -1 if not
func find_in_parent_captures(name *u8, name_len i64) i64 {
    if cg_parent_captures == nil { return 0 - 1; }
    var i i64 = 0;
    while i < cg_parent_capture_count {
        // Parent captures have same layout: [name_ptr:8][name_len:8][offset:8][type:8]
        var entry *u8 = cg_parent_captures + (i * 32);
        var cap_name_p **u8 = entry;
        var cap_name *u8 = *cap_name_p;
        var cap_len_p *i64 = entry + 8;
        var cap_len i64 = *cap_len_p;
        if cap_len == name_len {
            if memcmp(cap_name, name, name_len) {
                return i;
            }
        }
        i = i + 1;
    }
    return 0 - 1;
}

// Get the type from a parent capture by index
func get_parent_capture_type(index i64) *u8 {
    var entry *u8 = cg_parent_captures + (index * 32) + 24;
    var type_p **u8 = entry;
    return *type_p;
}

// ============================================================
// Capture analysis - walk AST to find free variables
// Note: Mutual recursion works without forward declarations
// because lang's parser collects all function decls first.
// ============================================================

func analyze_captures_block(block *u8) void {
    var stmts *u8 = block_stmt_stmts(block);
    var count i64 = block_stmt_count(block);
    var i i64 = 0;
    while i < count {
        var stmt_p **u8 = stmts + (i * 8);
        analyze_captures_stmt(*stmt_p);
        i = i + 1;
    }
}

func analyze_captures_stmt(stmt *u8) void {
    if stmt == nil { return; }
    var k i64 = node_kind(stmt);

    if k == NODE_BLOCK_STMT {
        analyze_captures_block(stmt);
    } else if k == NODE_IF_STMT {
        analyze_captures_expr(if_stmt_cond(stmt));
        analyze_captures_stmt(if_stmt_then(stmt));
        var else_part *u8 = if_stmt_else(stmt);
        if else_part != nil {
            analyze_captures_stmt(else_part);
        }
    } else if k == NODE_WHILE_STMT {
        analyze_captures_expr(while_stmt_cond(stmt));
        analyze_captures_stmt(while_stmt_body(stmt));
    } else if k == NODE_RETURN_STMT {
        var ret_val *u8 = return_stmt_value(stmt);
        if ret_val != nil {
            analyze_captures_expr(ret_val);
        }
    } else if k == NODE_EXPR_STMT {
        analyze_captures_expr(expr_stmt_expr(stmt));
    } else if k == NODE_VAR_DECL {
        // Note: The local is ADDED to scope by normal codegen
        // We need to analyze the initializer expression
        var init *u8 = var_decl_init(stmt);
        if init != nil {
            analyze_captures_expr(init);
        }
    } else if k == NODE_ASSIGN_STMT {
        analyze_captures_expr(assign_stmt_target(stmt));
        analyze_captures_expr(assign_stmt_value(stmt));
    }
    // BREAK_STMT and CONTINUE_STMT have no expressions to analyze
}

func analyze_captures_expr(expr *u8) void {
    if expr == nil { return; }
    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check if it's a local from BEFORE the lambda scope started
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 && local_idx < cg_lambda_scope_start {
            // This is an outer-scope variable - capture it!
            var outer_offset i64 = local_get_offset(local_idx);
            var local_type *u8 = local_get_type(local_idx);
            add_capture(name, name_len, outer_offset, local_type);
        } else if local_idx < 0 {
            // Not a local - check if it's in parent captures (for nested lambdas)
            var parent_idx i64 = find_in_parent_captures(name, name_len);
            if parent_idx >= 0 {
                // Found in parent captures - add to our captures too
                // Use a sentinel offset (-1) to mark this as "from parent"
                var parent_type *u8 = get_parent_capture_type(parent_idx);
                add_capture(name, name_len, 0 - 1, parent_type);
            }
        }
        // If it's a local within lambda scope, it's not captured
        // If it's not a local (global, function), it's not captured
    } else if k == NODE_BINARY_EXPR {
        analyze_captures_expr(binary_expr_left(expr));
        analyze_captures_expr(binary_expr_right(expr));
    } else if k == NODE_UNARY_EXPR {
        analyze_captures_expr(unary_expr_expr(expr));
    } else if k == NODE_CALL_EXPR {
        analyze_captures_expr(call_expr_func(expr));
        var args *u8 = call_expr_args(expr);
        var arg_count i64 = call_expr_arg_count(expr);
        var i i64 = 0;
        while i < arg_count {
            var arg_p **u8 = args + (i * 8);
            analyze_captures_expr(*arg_p);
            i = i + 1;
        }
    } else if k == NODE_FIELD_EXPR {
        analyze_captures_expr(field_expr_expr(expr));
    } else if k == NODE_INDEX_EXPR {
        // IndexExpr layout: [kind:8][expr:8][index:8]
        var idx_expr_p **u8 = expr + 8;
        var idx_index_p **u8 = expr + 16;
        analyze_captures_expr(*idx_expr_p);
        analyze_captures_expr(*idx_index_p);
    } else if k == NODE_GROUP_EXPR {
        analyze_captures_expr(group_expr_expr(expr));
    } else if k == NODE_LET_EXPR {
        analyze_captures_expr(let_expr_init(expr));
        // let bindings create a new local, but analyze body for more captures
        analyze_captures_expr(let_expr_body(expr));
    } else if k == NODE_LAMBDA_EXPR {
        // Nested lambda - we need to analyze its body for captures
        // This ensures that variables used by inner lambdas get captured by outer too
        // We don't register the nested lambda here - that happens when gen_expr processes it
        analyze_captures_block(lambda_expr_body(expr));
    } else if k == NODE_MATCH_EXPR {
        analyze_captures_expr(match_expr_scrutinee(expr));
        var arms *u8 = match_expr_arms(expr);
        var arm_count i64 = match_expr_arm_count(expr);
        var i i64 = 0;
        while i < arm_count {
            var arm *u8 = get_match_arm(arms, i);
            // Pattern bindings create locals, but analyze body
            analyze_captures_expr(match_arm_body(arm));
            i = i + 1;
        }
    }
    // NUMBER_EXPR, STRING_EXPR, BOOL_EXPR, NIL_EXPR have no sub-expressions
}

// Main function to analyze captures in a lambda
// Returns the number of captures found
func analyze_lambda_captures(lambda_node *u8, param_count i64) i64 {
    // Initialize capture tracking
    init_capture_tracking();

    // Mark current scope start - variables at or above this index are outer scope
    cg_lambda_scope_start = cg_local_count;

    // Walk the lambda body to find captures
    analyze_captures_block(lambda_expr_body(lambda_node));

    return cg_current_capture_count;
}

// Find a capture in the current closure context by name
// Returns capture index (>= 0) or -1 if not found
func find_closure_capture(name *u8, name_len i64) i64 {
    if cg_in_closure == 0 { return 0 - 1; }
    var i i64 = 0;
    while i < cg_closure_capture_count {
        var entry *u8 = cg_closure_captures + (i * 32);
        var cap_name **u8 = entry;
        var cap_len *i64 = entry + 8;
        if *cap_len == name_len {
            if memcmp(*cap_name, name, name_len) {
                return i;
            }
        }
        i = i + 1;
    }
    return 0 - 1;
}

// Get capture type from capture entry
func closure_capture_type(index i64) *u8 {
    var entry *u8 = cg_closure_captures + (index * 32);
    var type_ptr **u8 = entry + 24;
    return *type_ptr;
}

// Check if a lambda expression has captures (for compile-time safety check)
// Returns 1 if lambda captures outer variables, 0 otherwise
func lambda_has_captures(lambda_node *u8) i64 {
    // Save current capture tracking state
    var saved_captures *u8 = cg_current_captures;
    var saved_count i64 = cg_current_capture_count;
    var saved_scope_start i64 = cg_lambda_scope_start;

    // Set up parent captures if we're inside a closure
    // This is the same logic as in gen_expr for NODE_LAMBDA_EXPR
    var saved_parent_captures *u8 = cg_parent_captures;
    var saved_parent_count i64 = cg_parent_capture_count;
    if cg_in_closure == 1 {
        cg_parent_captures = cg_closure_captures;
        cg_parent_capture_count = cg_closure_capture_count;
    }

    // Analyze this lambda's captures
    var param_count i64 = lambda_expr_param_count(lambda_node);
    var capture_count i64 = analyze_lambda_captures(lambda_node, param_count);

    // Restore state
    cg_current_captures = saved_captures;
    cg_current_capture_count = saved_count;
    cg_lambda_scope_start = saved_scope_start;
    cg_parent_captures = saved_parent_captures;
    cg_parent_capture_count = saved_parent_count;

    if capture_count > 0 {
        return 1;
    }
    return 0;
}

// ============================================================
// Global variable accessors
// ============================================================

func global_get_name(index i64) *u8 {
    var p **u8 = cg_globals + (index * 32);
    return *p;
}

func global_set_name(index i64, ptr *u8) void {
    var p **u8 = cg_globals + (index * 32);
    *p = ptr;
}

func global_get_name_len(index i64) i64 {
    var p *i64 = cg_globals + (index * 32) + 8;
    return *p;
}

func global_set_name_len(index i64, len i64) void {
    var p *i64 = cg_globals + (index * 32) + 8;
    *p = len;
}

func global_get_type(index i64) *u8 {
    var p **u8 = cg_globals + (index * 32) + 16;
    return *p;
}

func global_set_type(index i64, t *u8) void {
    var p **u8 = cg_globals + (index * 32) + 16;
    *p = t;
}

func global_get_init(index i64) *u8 {
    var p **u8 = cg_globals + (index * 32) + 24;
    return *p;
}

func global_set_init(index i64, init *u8) void {
    var p **u8 = cg_globals + (index * 32) + 24;
    *p = init;
}

func find_global(name *u8, name_len i64) i64 {
    var i i64 = 0;
    while i < cg_global_count {
        if global_get_name_len(i) == name_len {
            if memcmp(global_get_name(i), name, name_len) {
                return i;
            }
        }
        i = i + 1;
    }
    return 0 - 1;  // -1 not found
}

func add_global(name *u8, name_len i64, t *u8, init *u8) void {
    global_set_name(cg_global_count, name);
    global_set_name_len(cg_global_count, name_len);
    global_set_type(cg_global_count, t);
    global_set_init(cg_global_count, init);
    cg_global_count = cg_global_count + 1;
}

// ============================================================
// Struct registry helpers
// ============================================================

func add_struct(decl *u8) void {
    var name *u8 = struct_decl_name(decl);
    var name_len i64 = struct_decl_name_len(decl);

    var entry *u8 = cg_structs + (cg_struct_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_struct_count = cg_struct_count + 1;
}

func find_struct(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_struct_count {
        var entry *u8 = cg_structs + (i * 24);

        var np **u8 = entry;
        var sname *u8 = *np;

        var nl *i64 = entry + 8;
        var slen i64 = *nl;

        if slen == name_len {
            if memcmp(sname, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Enum registry helpers
// ============================================================

func add_enum(decl *u8) void {
    var name *u8 = enum_decl_name(decl);
    var name_len i64 = enum_decl_name_len(decl);

    var entry *u8 = cg_enums + (cg_enum_count * 24);

    var np **u8 = entry;
    *np = name;

    var nl *i64 = entry + 8;
    *nl = name_len;

    var dp **u8 = entry + 16;
    *dp = decl;

    cg_enum_count = cg_enum_count + 1;
}

func find_enum(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_enum_count {
        var entry *u8 = cg_enums + (i * 24);

        var np **u8 = entry;
        var ename *u8 = *np;

        var nl *i64 = entry + 8;
        var elen i64 = *nl;

        if elen == name_len {
            if memcmp(ename, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

func find_variant(enum_decl *u8, name *u8, name_len i64) *u8 {
    var variants *u8 = enum_decl_variants(enum_decl);
    var count i64 = enum_decl_variant_count(enum_decl);
    var i i64 = 0;
    while i < count {
        var v *u8 = get_enum_variant(variants, i);
        var vname *u8 = enum_variant_name(v);
        var vlen i64 = enum_variant_name_len(v);
        if vlen == name_len {
            if memcmp(vname, name, name_len) {
                return v;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Effect registry
// ============================================================

func add_effect(decl *u8) void {
    var name *u8 = effect_decl_name(decl);
    var name_len i64 = effect_decl_name_len(decl);

    var entry *u8 = cg_effects + (cg_effect_count * 24);

    var np **u8 = entry;
    *np = name;

    var nl *i64 = entry + 8;
    *nl = name_len;

    var dp **u8 = entry + 16;
    *dp = decl;

    cg_effect_count = cg_effect_count + 1;
}

func find_effect(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_effect_count {
        var entry *u8 = cg_effects + (i * 24);

        var np **u8 = entry;
        var ename *u8 = *np;

        var nl *i64 = entry + 8;
        var elen i64 = *nl;

        if elen == name_len {
            if memcmp(ename, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Macro registry
// ============================================================

func add_macro(decl *u8) void {
    var name *u8 = macro_decl_name(decl);
    var name_len i64 = macro_decl_name_len(decl);

    var entry *u8 = cg_macros + (cg_macro_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_macro_count = cg_macro_count + 1;
}

func find_macro(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_macro_count {
        var entry *u8 = cg_macros + (i * 24);

        var np **u8 = entry;
        var mname *u8 = *np;

        var nl *i64 = entry + 8;
        var mlen i64 = *nl;

        if mlen == name_len {
            if memcmp(mname, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Reader registry functions
// ============================================================

// Execute a program, wait for completion (no stdin/stdout capture)
func exec_run(program *u8, arg1 *u8, arg2 *u8, arg3 *u8, arg4 *u8, arg5 *u8) i64 {
    var argv *u8 = alloc(56);  // 7 pointers
    var a0 **u8 = argv;      *a0 = program;
    var a1 **u8 = argv + 8;  *a1 = arg1;
    var a2 **u8 = argv + 16; *a2 = arg2;
    var a3 **u8 = argv + 24; *a3 = arg3;
    var a4 **u8 = argv + 32; *a4 = arg4;
    var a5 **u8 = argv + 40; *a5 = arg5;
    var a6 **u8 = argv + 48; *a6 = nil;

    var envp *u8 = alloc(8);
    var e0 **u8 = envp;
    *e0 = nil;

    var pid i64 = syscall(57);
    if pid == 0 {
        syscall(59, program, argv, envp);
        syscall(60, 127);
    }

    var status *i64 = alloc(8);
    syscall(61, pid, status, 0, 0);
    return (*status / 256) % 256;  // extract exit code
}

// Build reader cache path: .lang-cache/readers/<name>
func build_reader_cache_path(name *u8, name_len i64) *u8 {
    var path *u8 = alloc(256);
    var i i64 = 0;

    var prefix *u8 = ".lang-cache/readers/";
    while *prefix != 0 {
        *(path + i) = *prefix;
        i = i + 1;
        prefix = prefix + 1;
    }

    var j i64 = 0;
    while j < name_len {
        *(path + i) = *(name + j);
        i = i + 1;
        j = j + 1;
    }

    *(path + i) = 0;
    return path;
}

// Get file modification time (seconds since epoch)
// Returns 0 if file doesn't exist
func cg_file_mtime(path *u8) i64 {
    // syscall 4 = stat, struct stat is 144 bytes, st_mtime at offset 88
    var statbuf *u8 = alloc(144);
    var result i64 = syscall(4, path, statbuf);
    if result < 0 {
        return 0;
    }
    var mtime_ptr *i64 = statbuf + 88;
    return *mtime_ptr;
}

// Check if reader cache is valid (mtime-based)
// Returns 1 if should recompile, 0 if cache is valid
func should_recompile_reader(cached_exe *u8) i64 {
    var exe_mtime i64 = cg_file_mtime(cached_exe);
    if exe_mtime == 0 {
        return 1;  // doesn't exist
    }

    // Check if stable compiler is newer than cached reader
    if cg_file_mtime("./out/lang") > exe_mtime {
        return 1;
    }

    // Check if dev compiler is newer (for make verify)
    if cg_file_mtime("./out/lang_next") > exe_mtime {
        return 1;
    }

    // Check if stdlib is newer than cached reader
    if cg_file_mtime("std/core.lang") > exe_mtime {
        return 1;
    }

    return 0;  // cache is valid
}

// Generate and compile reader to executable
func compile_reader_to_executable(decl *u8) void {
    var name *u8 = reader_decl_name(decl);
    var name_len i64 = reader_decl_name_len(decl);
    var param_name *u8 = reader_decl_param_name(decl);
    var param_len i64 = reader_decl_param_len(decl);
    var body *u8 = reader_decl_body(decl);

    // Build cache path: .lang-cache/readers/<name>
    var base_path *u8 = build_reader_cache_path(name, name_len);
    var exe_path *u8 = str_dup(base_path);

    // Check if cache is valid (mtime-based)
    if should_recompile_reader(exe_path) == 0 {
        return;  // cache is valid, skip recompilation
    }

    // Create .lang-cache/readers/ directories
    syscall(83, ".lang-cache", 493);  // mkdir
    syscall(83, ".lang-cache/readers", 493);

    var src_path *u8 = str_concat(base_path, ".lang");
    var asm_path *u8 = str_concat(base_path, ".s");
    var obj_path *u8 = str_concat(base_path, ".o");

    // Loop variables used throughout function
    var i i64 = 0;
    var j i64 = 0;

    // Build wrapper source with sibling declarations from current file
    var wrapper *u8 = alloc(262144);  // 256KB for larger reader files
    var wp *u8 = wrapper;

    // Serialize sibling declarations from the reader's immediate context.
    // We only include declarations that are BETWEEN the file start and
    // the reader declaration, to avoid including stdlib functions.
    // For now, we only serialize include statements (user must explicitly
    // include helper files), and we find the reader in the decl list to
    // only include declarations that come BEFORE it in the same file.

    ast_str_init();

    // Always include std/core.lang for stdlib functions
    // String is: include "std/core.lang"\n = 24 chars
    ast_str_append_cstr("include \"std/core.lang\"\n");

    // Find the reader's position in the declaration list
    var reader_pos i64 = -1;
    i = 0;
    while i < cg_current_file_decl_count {
        var sibling *u8 = get_decl(cg_current_file_decls, i);
        if sibling == decl {
            reader_pos = i;
        }
        i = i + 1;
    }

    // Emit sibling declarations so the reader executable has access to them.
    // This includes: include statements, reader macro expansions (like #parser{}),
    // struct declarations, and function declarations that come BEFORE the reader.
    if reader_pos > 0 {
        // Emit include statements before the reader
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_INCLUDE_DECL {
                ast_to_string_include_decl(sibling);
            }
            i = i + 1;
        }

        // Emit reader macro expansions (e.g., #parser{} generates code)
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_READER_EXPR {
                // Get reader name and content
                var rname *u8 = reader_expr_name(sibling);
                var rname_len i64 = reader_expr_name_len(sibling);
                var rcontent *u8 = reader_expr_content(sibling);
                var rcontent_len i64 = reader_expr_content_len(sibling);

                // Build executable path
                var rexe_path *u8 = build_reader_cache_path(rname, rname_len);

                // Execute reader and get output
                var rout *u8 = alloc(131072);
                var rn i64 = exec_capture(rexe_path, rcontent, rcontent_len, rout, 131072);
                if rn > 0 {
                    // Append reader output directly (it's lang source code)
                    ast_str_append(rout, rn);
                    ast_str_append_char(10);
                }
            }
            i = i + 1;
        }

        // Emit struct declarations before the reader
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_STRUCT_DECL {
                ast_to_string_struct_decl(sibling);
            }
            i = i + 1;
        }

        // Emit function declarations before the reader (skip main)
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_FUNC_DECL {
                // Skip main() to avoid conflict with wrapper main
                var fname *u8 = func_decl_name(sibling);
                var flen i64 = func_decl_name_len(sibling);
                if flen != 4 || !memcmp(fname, "main", 4) {
                    ast_to_string_func_decl(sibling);
                }
            }
            i = i + 1;
        }
    }

    var siblings_src *u8 = ast_str_finish();

    // Copy sibling declarations to wrapper
    var siblings_copy *u8 = siblings_src;
    while *siblings_copy != 0 { *wp = *siblings_copy; wp = wp + 1; siblings_copy = siblings_copy + 1; }

    // Generate reader body source
    var body_src *u8 = ast_to_string_block(body);

    // func <name>(<param> *u8) *u8
    var fn_kw *u8 = "func ";
    while *fn_kw != 0 { *wp = *fn_kw; wp = wp + 1; fn_kw = fn_kw + 1; }
    j = 0;
    while j < name_len { *wp = *(name + j); wp = wp + 1; j = j + 1; }
    *wp = 40; wp = wp + 1;  // (
    j = 0;
    while j < param_len { *wp = *(param_name + j); wp = wp + 1; j = j + 1; }
    var sig *u8 = " *u8) *u8 ";
    while *sig != 0 { *wp = *sig; wp = wp + 1; sig = sig + 1; }
    while *body_src != 0 { *wp = *body_src; wp = wp + 1; body_src = body_src + 1; }
    *wp = 10; wp = wp + 1;  // newline

    // main() wrapper - use the reader's parameter name
    var main_src *u8 = "func main() i64 {\n    var buf *u8 = alloc(65536);\n    var n i64 = file_read(0, buf, 65536);\n    *(buf + n) = 0;\n    var result *u8 = ";
    while *main_src != 0 { *wp = *main_src; wp = wp + 1; main_src = main_src + 1; }
    j = 0;
    while j < name_len { *wp = *(name + j); wp = wp + 1; j = j + 1; }
    var main_end *u8 = "(buf);\n    print(result);\n    return 0;\n}\n";
    while *main_end != 0 { *wp = *main_end; wp = wp + 1; main_end = main_end + 1; }
    *wp = 0;

    // Write wrapper source to file
    var fd i64 = syscall(2, src_path, 577, 420);  // open with O_CREAT|O_TRUNC|O_WRONLY
    var wlen i64 = 0;
    var ws *u8 = wrapper;
    while *ws != 0 { wlen = wlen + 1; ws = ws + 1; }
    syscall(1, fd, wrapper, wlen);
    syscall(3, fd);

    // Compile: ./out/lang <src> -o <asm>
    // The wrapper source already has includes and sibling declarations serialized.
    // Don't pass std/core.lang - the wrapper handles its own dependencies.
    exec_run("./out/lang", src_path, "-o", asm_path, nil, nil);

    // Assemble: as <asm> -o <obj>
    exec_run("/usr/bin/as", asm_path, "-o", obj_path, nil, nil);

    // Link: ld <obj> -o <exe>
    exec_run("/usr/bin/ld", obj_path, "-o", exe_path, nil, nil);
}

func add_reader(decl *u8) void {
    var name *u8 = reader_decl_name(decl);
    var name_len i64 = reader_decl_name_len(decl);

    var entry *u8 = cg_readers + (cg_reader_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_reader_count = cg_reader_count + 1;

    // V2: Compile reader to executable
    compile_reader_to_executable(decl);
}

func find_reader(name *u8, name_len i64) *u8 {
    // First check registered readers
    var i i64 = 0;
    while i < cg_reader_count {
        var entry *u8 = cg_readers + (i * 24);

        var np **u8 = entry;
        var rname *u8 = *np;

        var nl *i64 = entry + 8;
        var rlen i64 = *nl;

        if rlen == name_len {
            if memcmp(rname, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }

    // Fall back to checking for pre-compiled reader in /tmp
    var exe_path *u8 = build_reader_cache_path(name, name_len);

    // Check if file exists by trying to open it
    var fd i64 = file_open(exe_path, 0);  // O_RDONLY = 0
    if fd >= 0 {
        file_close(fd);
        // Return non-nil sentinel to indicate reader found
        return exe_path;
    }

    return nil;
}

// ============================================================
// Function registry
// ============================================================

func add_func(decl *u8) void {
    var name *u8 = func_decl_name(decl);
    var name_len i64 = func_decl_name_len(decl);

    var entry *u8 = cg_funcs + (cg_func_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_func_count = cg_func_count + 1;
}

// Look up a function by name in function registry
func find_func(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_func_count {
        var entry *u8 = cg_funcs + (i * 24);

        var np **u8 = entry;
        var fname *u8 = *np;

        var nl *i64 = entry + 8;
        var flen i64 = *nl;

        if flen == name_len && memcmp(fname, name, name_len) {
            var dp **u8 = entry + 16;
            return *dp;
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Include stack operations (for loop detection)
// ============================================================

func include_stack_push(path *u8, path_len i64) void {
    var entry *u8 = cg_include_stack + (cg_include_count * 16);
    var pp **u8 = entry;
    *pp = path;
    var pl *i64 = entry + 8;
    *pl = path_len;
    cg_include_count = cg_include_count + 1;
}

func include_stack_pop() void {
    if cg_include_count > 0 {
        cg_include_count = cg_include_count - 1;
    }
}

func include_stack_contains(path *u8, path_len i64) bool {
    var i i64 = 0;
    while i < cg_include_count {
        var entry *u8 = cg_include_stack + (i * 16);
        var pp **u8 = entry;
        var stack_path *u8 = *pp;
        var pl *i64 = entry + 8;
        var stack_len i64 = *pl;

        if stack_len == path_len && memcmp(stack_path, path, path_len) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Read a file into a buffer (returns length, or -1 on error)
func read_file_contents(path *u8, path_len i64, buf *u8, buf_cap i64) i64 {
    // Null-terminate path
    var path_z *u8 = alloc(path_len + 1);
    var j i64 = 0;
    while j < path_len {
        *(path_z + j) = *(path + j);
        j = j + 1;
    }
    *(path_z + path_len) = 0;

    // Open file (O_RDONLY = 0)
    var fd i64 = syscall(2, path_z, 0, 0);
    if fd < 0 {
        return -1;
    }

    // Read contents
    var n i64 = syscall(0, fd, buf, buf_cap);
    syscall(3, fd);  // close

    if n >= 0 {
        *(buf + n) = 0;  // null-terminate
    }
    return n;
}

// Process a single declaration (first pass) - handles includes recursively
// Note: This function must be defined before process_include_first_pass uses it
func process_decl_first_pass(decl *u8) void {
    var k i64 = node_kind(decl);
    if k == NODE_STRUCT_DECL {
        add_struct(decl);
        return;
    }
    if k == NODE_ENUM_DECL {
        add_enum(decl);
        return;
    }
    if k == NODE_EFFECT_DECL {
        add_effect(decl);
        return;
    }
    if k == NODE_MACRO_DECL {
        add_macro(decl);
        return;
    }
    if k == NODE_READER_DECL {
        add_reader(decl);
        return;
    }
    if k == NODE_FUNC_DECL {
        add_func(decl);
        return;
    }
    // Reader macro at declaration level - expand to declarations
    if k == NODE_READER_EXPR {
        var name *u8 = reader_expr_name(decl);
        var name_len i64 = reader_expr_name_len(decl);
        var content *u8 = reader_expr_content(decl);
        var content_len i64 = reader_expr_content_len(decl);

        // Look up the reader
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            eprint("error: reader macro '");
            eprint_buf(name, name_len);
            eprintln("' not found");
            cg_had_error = 1;
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = build_reader_cache_path(name, name_len);

        // Execute reader with content as input
        var output *u8 = alloc(131072);  // 128KB
        var n i64 = exec_capture(exe_path, content, content_len, output, 131072);

        if n <= 0 {
            eprint("error: reader '");
            eprint_buf(name, name_len);
            eprintln("' returned no output");
            cg_had_error = 1;
            return;
        }

        // Parse the output as S-expr AST (readers MUST output AST)
        var prog *u8 = parse_ast_from_string(output);
        if prog == nil {
            eprint("error: reader '");
            eprint_buf(name, name_len);
            eprintln("' did not return valid AST");
            cg_had_error = 1;
            return;
        }

        // Process each generated declaration
        var gen_decls *u8 = program_decls(prog);
        var gen_count i64 = program_decl_count(prog);
        var gi i64 = 0;
        while gi < gen_count {
            process_decl_first_pass(get_decl(gen_decls, gi));
            gi = gi + 1;
        }
        return;
    }
    if k == NODE_VAR_DECL {
        add_global(
            var_decl_name(decl),
            var_decl_name_len(decl),
            var_decl_type(decl),
            var_decl_init(decl)
        );
        return;
    }
    if k == NODE_INCLUDE_DECL {
        // Inline include processing to avoid forward declaration
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Skip if already included (idempotent includes)
        if map_has(cg_included_files, str_dup_n(path, path_len)) {
            return;
        }
        map_set(cg_included_files, str_dup_n(path, path_len), 1);

        // Check for circular include
        if include_stack_contains(path, path_len) {
            eprint("error: circular include detected: ");
            eprint_buf(path, path_len);
            eprintln("");
            return;
        }

        // Push onto include stack
        include_stack_push(path, path_len);

        // Read file
        var buf *u8 = alloc(1048576);  // 1MB max
        var n i64 = read_file_contents(path, path_len, buf, 1048576);
        if n < 0 {
            eprint("error: cannot open include file: ");
            eprint_buf(path, path_len);
            eprintln("");
            include_stack_pop();
            return;
        }

        // Parse file
        var prog *u8 = parse_program_from_string(buf);
        if prog == nil {
            eprint("error: failed to parse include file: ");
            eprint_buf(path, path_len);
            eprintln("");
            include_stack_pop();
            return;
        }

        // Process declarations from included file (first pass)
        var inc_decls *u8 = program_decls(prog);
        var inc_count i64 = program_decl_count(prog);

        // Save and set current file context (for reader compilation)
        var saved_file_decls *u8 = cg_current_file_decls;
        var saved_file_count i64 = cg_current_file_decl_count;
        var saved_scoped i64 = cg_in_scoped_context;
        cg_current_file_decls = inc_decls;
        cg_current_file_decl_count = inc_count;
        cg_in_scoped_context = 1;  // Mark that we're in an included file

        var i i64 = 0;
        while i < inc_count {
            process_decl_first_pass(get_decl(inc_decls, i));
            i = i + 1;
        }

        // Restore current file context
        cg_current_file_decls = saved_file_decls;
        cg_current_file_decl_count = saved_file_count;
        cg_in_scoped_context = saved_scoped;

        // Pop from include stack
        include_stack_pop();
        return;
    }
}

// ============================================================
// String literal accessors
// ============================================================

func string_get_ptr(index i64) *u8 {
    var p **u8 = cg_strings + (index * 16);
    return *p;
}

func string_set_ptr(index i64, ptr *u8) void {
    var p **u8 = cg_strings + (index * 16);
    *p = ptr;
}

func string_get_len(index i64) i64 {
    var p *i64 = cg_strings + (index * 16) + 8;
    return *p;
}

func string_set_len(index i64, len i64) void {
    var p *i64 = cg_strings + (index * 16) + 8;
    *p = len;
}

func add_string(ptr *u8, len i64) i64 {
    var idx i64 = cg_string_count;
    string_set_ptr(idx, ptr);
    string_set_len(idx, len);
    cg_string_count = cg_string_count + 1;
    return idx;
}

// ============================================================
// Memory comparison
// ============================================================

func memcmp(a *u8, b *u8, len i64) bool {
    var i i64 = 0;
    while i < len {
        if *(a + i) != *(b + i) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// ============================================================
// Output helpers
// ============================================================

func emit_char(c u8) void {
    if cg_in_func_body != 0 {
        if cg_func_len >= cg_func_cap {
            eprintln("FATAL: cg_func_buf overflow!");
            exit(1);
        }
        *(cg_func_buf + cg_func_len) = c;
        cg_func_len = cg_func_len + 1;
    } else {
        if cg_code_len >= cg_code_cap {
            eprintln("FATAL: cg_code_buf overflow!");
            exit(1);
        }
        *(cg_code_buf + cg_code_len) = c;
        cg_code_len = cg_code_len + 1;
    }
}

func emit_str(s *u8) void {
    var i i64 = 0;
    while *(s + i) != 0 {
        emit_char(*(s + i));
        i = i + 1;
    }
}

func emit_n(s *u8, n i64) void {
    var i i64 = 0;
    while i < n {
        emit_char(*(s + i));
        i = i + 1;
    }
}

func emit_int(n i64) void {
    if n < 0 {
        emit_char(45);  // '-'
        n = 0 - n;
    }
    if n == 0 {
        emit_char(48);  // '0'
        return;
    }

    // Find highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Print each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        emit_char(48 + digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

func emit_line(s *u8) void {
    emit_str(s);
    emit_char(10);  // newline
}

func emit_label(label i64) void {
    emit_str(".L");
    emit_int(label);
}

func new_label() i64 {
    cg_label_num = cg_label_num + 1;
    return cg_label_num;
}

// Copy func body buffer to code buffer
func flush_func_body() void {
    var i i64 = 0;
    while i < cg_func_len {
        *(cg_code_buf + cg_code_len) = *(cg_func_buf + i);
        cg_code_len = cg_code_len + 1;
        i = i + 1;
    }
    cg_func_len = 0;
}

// ============================================================
// Direct file output (for final assembly)
// ============================================================

func out_char(c u8) void {
    file_write(cg_out_fd, &c, 1);
}

func out_str(s *u8) void {
    file_write(cg_out_fd, s, strlen(s));
}

func out_n(s *u8, n i64) void {
    file_write(cg_out_fd, s, n);
}

func out_int(n i64) void {
    if n < 0 {
        out_char(45);  // '-'
        n = 0 - n;
    }
    if n == 0 {
        out_char(48);  // '0'
        return;
    }

    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    while divisor > 0 {
        var digit i64 = n / divisor;
        out_char(48 + digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

func out_line(s *u8) void {
    out_str(s);
    out_char(10);
}

// ============================================================
// Type helpers
// ============================================================

// Get field offset within a struct
func get_field_offset(struct_decl *u8, field_name *u8, field_len i64) i64 {
    if struct_decl == nil {
        return 0 - 1;
    }
    var fields *u8 = struct_decl_fields(struct_decl);
    var count i64 = struct_decl_field_count(struct_decl);
    var offset i64 = 0;
    var i i64 = 0;
    while i < count {
        var f *u8 = get_struct_field(fields, i);
        var fname *u8 = struct_field_name(f);
        var fname_len i64 = struct_field_name_len(f);

        if fname_len == field_len {
            if memcmp(fname, field_name, field_len) {
                return offset;
            }
        }
        // Add actual field size, not hardcoded 8
        var field_type *u8 = struct_field_type(f);
        var field_size i64 = get_type_size(field_type);
        if field_size < 8 {
            field_size = 8;  // Minimum 8 for alignment
        }
        offset = offset + field_size;
        i = i + 1;
    }
    return 0 - 1;
}

// Get field type from a struct
func get_field_type(struct_decl *u8, field_name *u8, field_len i64) *u8 {
    if struct_decl == nil {
        return nil;
    }
    var fields *u8 = struct_decl_fields(struct_decl);
    var count i64 = struct_decl_field_count(struct_decl);
    var i i64 = 0;
    while i < count {
        var f *u8 = get_struct_field(fields, i);
        var fname *u8 = struct_field_name(f);
        var fname_len i64 = struct_field_name_len(f);

        if fname_len == field_len {
            if memcmp(fname, field_name, field_len) {
                return struct_field_type(f);
            }
        }
        i = i + 1;
    }
    return nil;
}

// Global to return base local index from nested field computation
var cg_nested_field_base_local i64 = 0;

// Compute total offset for nested field access like o.inner.x
// Returns total offset from base variable, sets cg_nested_field_base_local to base local index
// Returns -1 if not a simple nested field on a local variable
func compute_nested_field_offset(expr *u8) i64 {
    if expr == nil {
        return 0 - 1;
    }

    var k i64 = node_kind(expr);

    // Base case: identifier - find the local
    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        var local_idx i64 = find_local(name, name_len);
        if local_idx < 0 {
            return 0 - 1;
        }
        cg_nested_field_base_local = local_idx;
        return 0;  // No offset from the base itself
    }

    // Recursive case: field expression
    if k == NODE_FIELD_EXPR {
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // First, get the offset of the base expression
        var base_offset i64 = compute_nested_field_offset(base_expr);
        if base_offset < 0 {
            return 0 - 1;
        }

        // Get the type of the base expression to find the struct
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            return 0 - 1;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;

        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        }

        if struct_name == nil {
            return 0 - 1;
        }

        // Look up struct and get field offset
        var struct_decl *u8 = find_struct(struct_name, struct_name_len);
        if struct_decl == nil {
            return 0 - 1;
        }

        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
        if field_offset < 0 {
            return 0 - 1;
        }

        return base_offset + field_offset;
    }

    return 0 - 1;
}

// Calculate struct size by summing field sizes (with alignment)
func get_struct_size(decl *u8) i64 {
    var fields *u8 = struct_decl_fields(decl);
    var count i64 = struct_decl_field_count(decl);
    var size i64 = 0;
    var i i64 = 0;
    while i < count {
        var f *u8 = get_struct_field(fields, i);
        var field_type *u8 = struct_field_type(f);
        var field_size i64 = get_type_size(field_type);
        // Align to field size (simplistic: align to 8 for now)
        if field_size > 1 {
            var rem i64 = size % 8;
            if rem != 0 {
                size = size + 8 - rem;
            }
        }
        size = size + field_size;
        i = i + 1;
    }
    // Align total size to 8
    var rem i64 = size % 8;
    if rem != 0 {
        size = size + 8 - rem;
    }
    return size;
}

func get_type_size(t *u8) i64 {
    if t == nil {
        return 8;
    }
    var k i64 = type_kind(t);
    if k == TYPE_PTR {
        return 8;
    }
    if k == TYPE_FUNC {
        return 8;  // Function pointer
    }
    if k == TYPE_CLOSURE {
        return 8;  // Closure pointer (pointer to closure struct)
    }
    if k == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);

        // Check for 1-byte types
        if len == 2 {
            if memcmp(name, "u8", 2) || memcmp(name, "i8", 2) {
                return 1;
            }
        }
        // Check for 2-byte types
        if len == 3 {
            if memcmp(name, "u16", 3) || memcmp(name, "i16", 3) {
                return 2;
            }
            if memcmp(name, "u32", 3) || memcmp(name, "i32", 3) {
                return 4;
            }
            if memcmp(name, "u64", 3) || memcmp(name, "i64", 3) {
                return 8;
            }
        }
        if len == 4 {
            if memcmp(name, "bool", 4) {
                return 1;
            }
            if memcmp(name, "void", 4) {
                return 0;
            }
        }
        // Check if it's a struct type
        var struct_decl *u8 = find_struct(name, len);
        if struct_decl != nil {
            return get_struct_size(struct_decl);
        }
        // Check if it's an enum type
        var enum_decl *u8 = find_enum(name, len);
        if enum_decl != nil {
            return get_enum_size(enum_decl);
        }
    }
    return 8;  // default
}

// Enum size functions
func get_enum_max_payload(decl *u8) i64 {
    var variants *u8 = enum_decl_variants(decl);
    var count i64 = enum_decl_variant_count(decl);
    var max_payload i64 = 0;
    var i i64 = 0;
    while i < count {
        var v *u8 = get_enum_variant(variants, i);
        var vtype *u8 = enum_variant_type(v);
        if vtype != nil {
            var size i64 = get_type_size(vtype);
            if size > max_payload {
                max_payload = size;
            }
        }
        i = i + 1;
    }
    return max_payload;
}

func get_enum_size(decl *u8) i64 {
    // Layout: [tag:8][payload:max_payload_size]
    // Minimum payload size is 8 for alignment
    var max_payload i64 = get_enum_max_payload(decl);
    if max_payload < 8 {
        max_payload = 8;
    }
    return 8 + max_payload;  // tag + payload
}

func get_pointed_type(t *u8) *u8 {
    if t == nil {
        return nil;
    }
    if type_kind(t) == TYPE_PTR {
        return ptr_type_elem(t);
    }
    return nil;
}

func is_void_type(t *u8) bool {
    if t == nil {
        return true;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 4 {
            return memcmp(name, "void", 4);
        }
    }
    return false;
}

// Check if a type is a closure type (TYPE_CLOSURE)
// TYPE_CLOSURE: auto-closure calling enabled (pass struct as hidden first arg)
// TYPE_FUNC: plain function pointer, no auto-closure
func is_auto_closure_type(t *u8) i64 {
    if t == nil {
        return 0;
    }
    if type_kind(t) == TYPE_CLOSURE {
        return 1;
    }
    return 0;
}

// ============================================================
// Expression type inference
// ============================================================

func get_expr_type(expr *u8) *u8 {
    if expr == nil {
        return nil;
    }

    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check for closure captures first
        if cg_in_closure == 1 {
            var cap_idx i64 = find_closure_capture(name, name_len);
            if cap_idx >= 0 {
                return closure_capture_type(cap_idx);
            }
        }

        // Check locals first
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            return local_get_type(local_idx);
        }

        // Check globals
        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            return global_get_type(global_idx);
        }

        return nil;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_STAR {  // dereference
            var inner_type *u8 = get_expr_type(unary_expr_expr(expr));
            return get_pointed_type(inner_type);
        }
        if op == TOKEN_AMP {  // address-of
            // Should return pointer type, but we'd need to create it
            return nil;
        }
        return get_expr_type(unary_expr_expr(expr));
    }

    if k == NODE_BINARY_EXPR {
        return get_expr_type(binary_expr_left(expr));
    }

    if k == NODE_GROUP_EXPR {
        return get_expr_type(group_expr_expr(expr));
    }

    if k == NODE_FIELD_EXPR {
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Get type of base expression
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            return nil;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            // Pointer to struct: get the pointed-to type
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
            }
        }

        if struct_name == nil {
            return nil;
        }

        // Look up struct
        var struct_decl *u8 = find_struct(struct_name, struct_name_len);
        if struct_decl == nil {
            return nil;
        }

        // Get field type
        return get_field_type(struct_decl, field_name, field_len);
    }

    if k == NODE_LET_EXPR {
        // Type of let expression is the type of its body
        return get_expr_type(let_expr_body(expr));
    }

    if k == NODE_LAMBDA_EXPR {
        // Lambda expressions have function type
        // Build TYPE_FUNC from lambda's parameters and return type
        var t *u8 = func_type_alloc();
        func_type_set_params(t, lambda_expr_params(expr));
        func_type_set_param_count(t, lambda_expr_param_count(expr));
        func_type_set_ret(t, lambda_expr_ret_type(expr));
        return t;
    }

    // Default: i64
    return nil;
}

// ============================================================
// Constant evaluation (for global initializers)
// ============================================================

func eval_constant(expr *u8) i64 {
    if expr == nil {
        return 0;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        // Parse the number string
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        var val i64 = 0;
        var i i64 = 0;
        while i < len {
            val = val * 10 + (*(ptr + i) - 48);
            i = i + 1;
        }
        return val;
    }

    if k == NODE_BOOL_EXPR {
        return bool_expr_value(expr);
    }

    if k == NODE_NIL_EXPR {
        return 0;
    }

    if k == NODE_IDENT_EXPR {
        // Look up global constant
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check for "nil"
        if name_len == 3 {
            if memcmp(name, "nil", 3) {
                return 0;
            }
        }

        var idx i64 = find_global(name, name_len);
        if idx >= 0 {
            var init *u8 = global_get_init(idx);
            if init != nil {
                return eval_constant(init);
            }
        }
        return 0;
    }

    if k == NODE_UNARY_EXPR {
        var val i64 = eval_constant(unary_expr_expr(expr));
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_MINUS {
            return 0 - val;
        }
        if op == TOKEN_BANG {
            if val == 0 {
                return 1;
            }
            return 0;
        }
        return val;
    }

    if k == NODE_BINARY_EXPR {
        var left i64 = eval_constant(binary_expr_left(expr));
        var right i64 = eval_constant(binary_expr_right(expr));
        var op i64 = binary_expr_op(expr);

        if op == TOKEN_PLUS { return left + right; }
        if op == TOKEN_MINUS { return left - right; }
        if op == TOKEN_STAR { return left * right; }
        if op == TOKEN_SLASH {
            if right != 0 { return left / right; }
            return 0;
        }
        if op == TOKEN_PERCENT {
            if right != 0 { return left % right; }
            return 0;
        }
        if op == TOKEN_EQEQ {
            if left == right { return 1; }
            return 0;
        }
        if op == TOKEN_BANGEQ {
            if left != right { return 1; }
            return 0;
        }
        if op == TOKEN_LT {
            if left < right { return 1; }
            return 0;
        }
        if op == TOKEN_GT {
            if left > right { return 1; }
            return 0;
        }
        if op == TOKEN_LTEQ {
            if left <= right { return 1; }
            return 0;
        }
        if op == TOKEN_GTEQ {
            if left >= right { return 1; }
            return 0;
        }
        return 0;
    }

    if k == NODE_GROUP_EXPR {
        return eval_constant(group_expr_expr(expr));
    }

    return 0;
}

// ============================================================
// String formatting for .ascii directive
// ============================================================

func emit_ascii_string(ptr *u8, len i64) void {
    // Skip quotes in original string
    var start *u8 = ptr + 1;
    var end i64 = len - 2;

    emit_char(34);  // opening quote

    var i i64 = 0;
    while i < end {
        var c u8 = *(start + i);

        if c == 92 && i + 1 < end {  // backslash escape
            i = i + 1;
            var next u8 = *(start + i);
            if next == 110 {  // 'n'
                emit_str("\\012");
            } else if next == 116 {  // 't'
                emit_str("\\011");
            } else if next == 114 {  // 'r'
                emit_str("\\015");
            } else if next == 92 {  // '\'
                emit_str("\\\\");
            } else if next == 34 {  // '"'
                emit_str("\\\"");
            } else if next == 48 {  // '0'
                emit_str("\\000");
            } else {
                emit_char(next);
            }
        } else if c >= 32 && c < 127 && c != 34 && c != 92 {
            emit_char(c);
        } else {
            // Octal escape
            emit_char(92);  // '\'
            emit_char(48 + (c / 64));
            emit_char(48 + ((c / 8) % 8));
            emit_char(48 + (c % 8));
        }
        i = i + 1;
    }

    emit_str("\\000");  // null terminator
    emit_char(34);  // closing quote
}

// ============================================================
// Expression code generation
// ============================================================

func gen_expr(expr *u8) void {
    if expr == nil {
        return;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        emit_str("    mov $");
        emit_n(number_expr_value(expr), number_expr_value_len(expr));
        emit_line(", %rax");
        return;
    }

    if k == NODE_STRING_EXPR {
        var idx i64 = add_string(string_expr_value(expr), string_expr_value_len(expr));
        emit_str("    lea .str");
        emit_int(idx);
        emit_line("(%rip), %rax");
        return;
    }

    if k == NODE_BOOL_EXPR {
        if bool_expr_value(expr) != 0 {
            emit_line("    mov $1, %rax");
        } else {
            emit_line("    xor %rax, %rax");
        }
        return;
    }

    if k == NODE_NIL_EXPR {
        emit_line("    xor %rax, %rax");
        return;
    }

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check for closure captures first
        if cg_in_closure == 1 {
            var cap_idx i64 = find_closure_capture(name, name_len);
            if cap_idx >= 0 {
                // Load from closure struct: [tag:8][fn_ptr:8][capture0:8][capture1:8]...
                var capture_offset i64 = 16 + (cap_idx * 8);
                // Load closure pointer
                emit_str("    mov ");
                emit_int(cg_closure_ptr_offset);
                emit_line("(%rbp), %rax");
                // Load captured value from closure
                emit_str("    mov ");
                emit_int(capture_offset);
                emit_line("(%rax), %rax");
                return;
            }
        }

        // Check locals
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            var local_type *u8 = local_get_type(local_idx);

            // For aggregate types (structs and enums), return pointer instead of loading value
            if local_type != nil && type_kind(local_type) == TYPE_BASE {
                var type_name *u8 = base_type_name(local_type);
                var type_name_len i64 = base_type_name_len(local_type);
                if find_struct(type_name, type_name_len) != nil {
                    // Struct type - return address
                    emit_str("    lea ");
                    emit_int(local_get_offset(local_idx));
                    emit_line("(%rbp), %rax");
                    return;
                }
                if find_enum(type_name, type_name_len) != nil {
                    // Enum type - return address
                    emit_str("    lea ");
                    emit_int(local_get_offset(local_idx));
                    emit_line("(%rbp), %rax");
                    return;
                }
            }

            emit_str("    mov ");
            emit_int(local_get_offset(local_idx));
            emit_line("(%rbp), %rax");
            return;
        }

        // Check globals
        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            emit_str("    mov ");
            emit_n(name, name_len);
            emit_line("(%rip), %rax");
            return;
        }

        // Function reference
        emit_str("    lea ");
        emit_n(name, name_len);
        emit_line("(%rip), %rax");
        return;
    }

    if k == NODE_GROUP_EXPR {
        gen_expr(group_expr_expr(expr));
        return;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);

        if op == TOKEN_AMP {  // address-of
            var inner *u8 = unary_expr_expr(expr);
            if node_kind(inner) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(inner);
                var name_len i64 = ident_expr_name_len(inner);

                var local_idx i64 = find_local(name, name_len);
                if local_idx >= 0 {
                    emit_str("    lea ");
                    emit_int(local_get_offset(local_idx));
                    emit_line("(%rbp), %rax");
                    return;
                }

                var global_idx i64 = find_global(name, name_len);
                if global_idx >= 0 {
                    emit_str("    lea ");
                    emit_n(name, name_len);
                    emit_line("(%rip), %rax");
                    return;
                }

                // Check for function address
                var func_decl *u8 = find_func(name, name_len);
                if func_decl != nil {
                    // Return plain function pointer (no closure struct)
                    // This is used when assigning to *u8 type
                    emit_str("    lea ");
                    emit_n(name, name_len);
                    emit_line("(%rip), %rax");
                    return;
                }

                // Error: identifier not found
                eprint("error: cannot take address of undefined identifier '");
                eprint_buf(name, name_len);
                eprintln("'");
                cg_had_error = 1;
            }

            // Check for field expression: &struct.field or &ptr.field
            if node_kind(inner) == NODE_FIELD_EXPR {
                var base_expr *u8 = field_expr_expr(inner);
                var field_name *u8 = field_expr_field(inner);
                var field_len i64 = field_expr_field_len(inner);

                // Get type of base expression to find struct
                var base_type *u8 = get_expr_type(base_expr);
                var struct_name *u8 = nil;
                var struct_name_len i64 = 0;
                var base_is_pointer i64 = 0;

                if base_type != nil {
                    if type_kind(base_type) == TYPE_BASE {
                        struct_name = base_type_name(base_type);
                        struct_name_len = base_type_name_len(base_type);
                    } else if type_kind(base_type) == TYPE_PTR {
                        // Pointer to struct
                        var pointed_type *u8 = ptr_type_elem(base_type);
                        if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                            struct_name = base_type_name(pointed_type);
                            struct_name_len = base_type_name_len(pointed_type);
                            base_is_pointer = 1;
                        }
                    }
                }

                if struct_name != nil {
                    var struct_decl *u8 = find_struct(struct_name, struct_name_len);
                    if struct_decl != nil {
                        var field_offset i64 = get_field_offset(struct_decl, field_name, field_len);
                        if field_offset >= 0 {
                            if base_is_pointer != 0 {
                                // Base is a pointer to struct: load pointer, add offset
                                gen_expr(base_expr);
                                if field_offset != 0 {
                                    emit_str("    add $");
                                    emit_int(field_offset);
                                    emit_line(", %rax");
                                }
                                return;
                            }
                            // Base is a local struct variable
                            if node_kind(base_expr) == NODE_IDENT_EXPR {
                                var bname *u8 = ident_expr_name(base_expr);
                                var bname_len i64 = ident_expr_name_len(base_expr);
                                var local_idx i64 = find_local(bname, bname_len);
                                if local_idx >= 0 {
                                    var base_offset i64 = local_get_offset(local_idx);
                                    emit_str("    lea ");
                                    emit_int(base_offset + field_offset);
                                    emit_line("(%rbp), %rax");
                                    return;
                                }
                            }
                        }
                    }
                }
            }
            return;
        }

        gen_expr(unary_expr_expr(expr));

        if op == TOKEN_MINUS {
            emit_line("    neg %rax");
            return;
        }

        if op == TOKEN_BANG {
            emit_line("    test %rax, %rax");
            emit_line("    setz %al");
            emit_line("    movzx %al, %rax");
            return;
        }

        if op == TOKEN_STAR {  // dereference
            var ptr_type *u8 = get_expr_type(unary_expr_expr(expr));
            var elem_type *u8 = get_pointed_type(ptr_type);
            var size i64 = 8;
            if elem_type != nil {
                size = get_type_size(elem_type);
            }

            if size == 1 {
                emit_line("    movzbl (%rax), %eax");
            } else if size == 2 {
                emit_line("    movzwl (%rax), %eax");
            } else if size == 4 {
                emit_line("    mov (%rax), %eax");
            } else {
                emit_line("    mov (%rax), %rax");
            }
            return;
        }

        return;
    }

    if k == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);

        // Assignment
        if op == TOKEN_EQ {
            gen_expr(binary_expr_right(expr));
            gen_lvalue_store(binary_expr_left(expr));
            return;
        }

        // Short-circuit &&
        if op == TOKEN_AMPAMP {
            var end_label i64 = new_label();
            gen_expr(binary_expr_left(expr));
            emit_line("    test %rax, %rax");
            emit_str("    jz ");
            emit_label(end_label);
            emit_char(10);
            gen_expr(binary_expr_right(expr));
            emit_label(end_label);
            emit_line(":");
            return;
        }

        // Short-circuit ||
        if op == TOKEN_PIPEPIPE {
            var end_label i64 = new_label();
            gen_expr(binary_expr_left(expr));
            emit_line("    test %rax, %rax");
            emit_str("    jnz ");
            emit_label(end_label);
            emit_char(10);
            gen_expr(binary_expr_right(expr));
            emit_label(end_label);
            emit_line(":");
            return;
        }

        // General binary: left in rax, push, right in rcx
        gen_expr(binary_expr_left(expr));
        emit_line("    push %rax");
        gen_expr(binary_expr_right(expr));
        emit_line("    mov %rax, %rcx");
        emit_line("    pop %rax");

        if op == TOKEN_PLUS {
            // Pointer arithmetic: scale offset by element size
            var left_type *u8 = get_expr_type(binary_expr_left(expr));
            if left_type != nil && type_kind(left_type) == TYPE_PTR {
                var elem_type *u8 = ptr_type_elem(left_type);
                var elem_size i64 = get_type_size(elem_type);
                if elem_size > 1 {
                    emit_str("    imul $");
                    emit_int(elem_size);
                    emit_line(", %rcx");
                }
            }
            emit_line("    add %rcx, %rax");
        } else if op == TOKEN_MINUS {
            // Pointer arithmetic: scale offset by element size
            var left_type *u8 = get_expr_type(binary_expr_left(expr));
            if left_type != nil && type_kind(left_type) == TYPE_PTR {
                var elem_type *u8 = ptr_type_elem(left_type);
                var elem_size i64 = get_type_size(elem_type);
                if elem_size > 1 {
                    emit_str("    imul $");
                    emit_int(elem_size);
                    emit_line(", %rcx");
                }
            }
            emit_line("    sub %rcx, %rax");
        } else if op == TOKEN_STAR {
            emit_line("    imul %rcx, %rax");
        } else if op == TOKEN_SLASH {
            emit_line("    cqo");
            emit_line("    idiv %rcx");
        } else if op == TOKEN_PERCENT {
            emit_line("    cqo");
            emit_line("    idiv %rcx");
            emit_line("    mov %rdx, %rax");
        } else if op == TOKEN_EQEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    sete %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_BANGEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setne %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_LT {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setl %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_GT {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setg %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_LTEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setle %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_GTEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setge %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_AMP {
            emit_line("    and %rcx, %rax");
        } else if op == TOKEN_PIPE {
            emit_line("    or %rcx, %rax");
        } else if op == TOKEN_CARET {
            emit_line("    xor %rcx, %rax");
        } else if op == TOKEN_LTLT {
            emit_line("    shl %cl, %rax");
        } else if op == TOKEN_GTGT {
            emit_line("    sar %cl, %rax");
        }
        return;
    }

    if k == NODE_CALL_EXPR {
        var func_expr *u8 = call_expr_func(expr);
        var args *u8 = call_expr_args(expr);
        var arg_count i64 = call_expr_arg_count(expr);

        // Check for enum variant construction: EnumName.Variant(payload)
        if node_kind(func_expr) == NODE_FIELD_EXPR {
            var field_base *u8 = field_expr_expr(func_expr);
            var field_name *u8 = field_expr_field(func_expr);
            var field_len i64 = field_expr_field_len(func_expr);

            // Check if base is an ident that matches an enum
            if node_kind(field_base) == NODE_IDENT_EXPR {
                var enum_name *u8 = ident_expr_name(field_base);
                var enum_name_len i64 = ident_expr_name_len(field_base);
                var enum_decl *u8 = find_enum(enum_name, enum_name_len);

                if enum_decl != nil {
                    // Find the variant
                    var variant *u8 = find_variant(enum_decl, field_name, field_len);
                    if variant == nil {
                        eprint("error: enum '");
                        eprint_buf(enum_name, enum_name_len);
                        eprint("' has no variant '");
                        eprint_buf(field_name, field_len);
                        eprintln("'");
                        cg_had_error = 1;
                        return;
                    }

                    // Allocate space for enum on stack
                    var enum_size i64 = get_enum_size(enum_decl);
                    cg_stack_size = cg_stack_size + enum_size;
                    var enum_offset i64 = 0 - cg_stack_size;

                    // Set tag
                    var tag i64 = enum_variant_tag(variant);
                    emit_str("    movq $");
                    emit_int(tag);
                    emit_str(", ");
                    emit_int(enum_offset);
                    emit_line("(%rbp)");

                    // Set payload if present
                    if arg_count > 0 {
                        var p **u8 = args;
                        gen_expr(*p);
                        // %rax now has value (for primitives) or pointer (for aggregates)

                        var payload_type *u8 = enum_variant_type(variant);
                        var payload_size i64 = 8;
                        if payload_type != nil {
                            payload_size = get_type_size(payload_type);
                        }

                        if payload_size <= 8 {
                            // Simple 8-byte copy
                            emit_str("    movq %rax, ");
                            emit_int(enum_offset + 8);
                            emit_line("(%rbp)");
                        } else {
                            // Aggregate type - %rax is pointer, copy full payload
                            emit_line("    mov %rax, %rsi");  // source pointer
                            var i i64 = 0;
                            while i < payload_size {
                                emit_str("    mov ");
                                emit_int(i);
                                emit_line("(%rsi), %rcx");
                                emit_str("    mov %rcx, ");
                                emit_int(enum_offset + 8 + i);
                                emit_line("(%rbp)");
                                i = i + 8;
                            }
                        }
                    }

                    // Return pointer to enum value
                    emit_str("    lea ");
                    emit_int(enum_offset);
                    emit_line("(%rbp), %rax");
                    return;
                }
            }
        }

        // Check for syscall
        if node_kind(func_expr) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(func_expr);
            var name_len i64 = ident_expr_name_len(func_expr);
            if name_len == 7 {
                if memcmp(name, "syscall", 7) {
                    gen_syscall(args, arg_count);
                    return;
                }
            }

            // Check argument count (skip for 'main' - wrapper handles both signatures)
            var func_decl *u8 = find_func(name, name_len);
            if func_decl != nil {
                var is_main i64 = 0;
                if name_len == 4 {
                    if memcmp(name, "main", 4) {
                        is_main = 1;
                    }
                }
                var param_count i64 = func_decl_param_count(func_decl);
                if arg_count != param_count && is_main == 0 {
                    eprint("Error: function '");
                    eprint_buf(name, name_len);
                    eprint("' expects ");
                    eprint_i64(param_count);
                    eprint(" argument(s), got ");
                    eprint_i64(arg_count);
                    eprintln("");
                    exit(1);
                }
            }

            // Check for macro call
            var macro_def *u8 = find_macro(name, name_len);
            if macro_def != nil {
                // Call the macro interpreter
                var expanded *u8 = interp_call_macro(macro_def, args, arg_count);
                // Print expansion if --expand-macros flag is set
                if cg_expand_macros != 0 && expanded != nil {
                    eprint("[macro ");
                    eprint_buf(name, name_len);
                    eprint("] => ");
                    print_expr_ast(expanded);
                    eprintln("");
                }
                // Generate code for the expanded AST
                if expanded != nil {
                    gen_expr(expanded);
                }
                return;
            }
        }

        // Push args in reverse order
        var i i64 = arg_count - 1;
        while i >= 0 {
            var p **u8 = args + (i * 8);
            gen_expr(*p);
            emit_line("    push %rax");
            i = i - 1;
        }

        // Pop into arg registers: rdi, rsi, rdx, rcx, r8, r9
        i = 0;
        while i < arg_count && i < 6 {
            if i == 0 { emit_line("    pop %rdi"); }
            else if i == 1 { emit_line("    pop %rsi"); }
            else if i == 2 { emit_line("    pop %rdx"); }
            else if i == 3 { emit_line("    pop %rcx"); }
            else if i == 4 { emit_line("    pop %r8"); }
            else if i == 5 { emit_line("    pop %r9"); }
            i = i + 1;
        }

        // Call function
        if node_kind(func_expr) == NODE_IDENT_EXPR {
            var fn_name *u8 = ident_expr_name(func_expr);
            var fn_name_len i64 = ident_expr_name_len(func_expr);

            // Check if it's a local variable (function pointer or closure)
            var local_idx i64 = find_local(fn_name, fn_name_len);
            if local_idx >= 0 {
                // Check if it's an auto-closure (TYPE_FUNC without *u8 first param)
                var var_type *u8 = local_get_type(local_idx);
                if is_auto_closure_type(var_type) == 1 {
                    // Closure struct layout: [tag:8][fn_ptr:8][captures...]
                    // tag == 0: plain function (no closure arg)
                    // tag == 1: closure (pass struct as first arg)

                    // Load closure struct pointer
                    emit_str("    mov ");
                    emit_int(local_get_offset(local_idx));
                    emit_line("(%rbp), %r10");

                    // Check tag
                    emit_line("    mov (%r10), %r11");
                    emit_line("    test %r11, %r11");
                    var plain_label i64 = new_label();
                    var end_label i64 = new_label();
                    emit_str("    jz ");
                    emit_label(plain_label);
                    emit_char(10);

                    // Tag == 1: Closure call - shift args and pass closure as first arg
                    if arg_count >= 5 { emit_line("    mov %r9, %rax"); emit_line("    push %rax"); }
                    if arg_count >= 5 { emit_line("    mov %r8, %r9"); }
                    if arg_count >= 4 { emit_line("    mov %rcx, %r8"); }
                    if arg_count >= 3 { emit_line("    mov %rdx, %rcx"); }
                    if arg_count >= 2 { emit_line("    mov %rsi, %rdx"); }
                    if arg_count >= 1 { emit_line("    mov %rdi, %rsi"); }
                    emit_line("    mov %r10, %rdi");  // Closure as first arg
                    emit_line("    mov 8(%r10), %rax");  // Load fn_ptr
                    emit_line("    call *%rax");
                    emit_str("    jmp ");
                    emit_label(end_label);
                    emit_char(10);

                    // Tag == 0: Plain function call
                    emit_label(plain_label);
                    emit_line(":");
                    emit_line("    mov 8(%r10), %rax");  // Load fn_ptr (at offset 8)
                    emit_line("    call *%rax");

                    emit_label(end_label);
                    emit_line(":");
                } else {
                    // Plain function pointer call (manual mode or non-function type)
                    emit_str("    mov ");
                    emit_int(local_get_offset(local_idx));
                    emit_line("(%rbp), %rax");
                    emit_line("    call *%rax");
                }
            } else {
                // Check if it's a global variable
                var global_idx i64 = find_global(fn_name, fn_name_len);
                if global_idx >= 0 {
                    // Check if it's an auto-closure
                    var var_type *u8 = global_get_type(global_idx);
                    if is_auto_closure_type(var_type) == 1 {
                        // Closure struct layout: [tag:8][fn_ptr:8][captures...]
                        emit_str("    mov ");
                        emit_n(fn_name, fn_name_len);
                        emit_line("(%rip), %r10");

                        emit_line("    mov (%r10), %r11");
                        emit_line("    test %r11, %r11");
                        var plain_label i64 = new_label();
                        var end_label i64 = new_label();
                        emit_str("    jz ");
                        emit_label(plain_label);
                        emit_char(10);

                        // Closure call
                        if arg_count >= 5 { emit_line("    mov %r9, %rax"); emit_line("    push %rax"); }
                        if arg_count >= 5 { emit_line("    mov %r8, %r9"); }
                        if arg_count >= 4 { emit_line("    mov %rcx, %r8"); }
                        if arg_count >= 3 { emit_line("    mov %rdx, %rcx"); }
                        if arg_count >= 2 { emit_line("    mov %rsi, %rdx"); }
                        if arg_count >= 1 { emit_line("    mov %rdi, %rsi"); }
                        emit_line("    mov %r10, %rdi");
                        emit_line("    mov 8(%r10), %rax");
                        emit_line("    call *%rax");
                        emit_str("    jmp ");
                        emit_label(end_label);
                        emit_char(10);

                        // Plain function call
                        emit_label(plain_label);
                        emit_line(":");
                        emit_line("    mov 8(%r10), %rax");
                        emit_line("    call *%rax");

                        emit_label(end_label);
                        emit_line(":");
                    } else {
                        // Plain function pointer call (manual mode or non-function type)
                        emit_str("    mov ");
                        emit_n(fn_name, fn_name_len);
                        emit_line("(%rip), %rax");
                        emit_line("    call *%rax");
                    }
                } else {
                    // Direct function call
                    emit_str("    call ");
                    emit_n(fn_name, fn_name_len);
                    emit_char(10);
                }
            }
        } else {
            gen_expr(func_expr);
            emit_line("    call *%rax");
        }

        // Clean up stack args for 7+ parameter calls
        // Args 1-6 go in registers, args 7+ go on the stack
        // After the call, we need to pop those extra stack args
        if arg_count > 6 {
            var extra_args i64 = arg_count - 6;
            var cleanup_bytes i64 = extra_args * 8;
            emit_str("    add $");
            emit_int(cleanup_bytes);
            emit_line(", %rsp");
        }
        return;
    }

    if k == NODE_INDEX_EXPR {
        // Not implemented for now
        return;
    }

    if k == NODE_FIELD_EXPR {
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Check for enum unit variant construction: EnumName.Variant
        if node_kind(base_expr) == NODE_IDENT_EXPR {
            var enum_name *u8 = ident_expr_name(base_expr);
            var enum_name_len i64 = ident_expr_name_len(base_expr);
            var enum_decl *u8 = find_enum(enum_name, enum_name_len);

            if enum_decl != nil {
                // Find the variant
                var variant *u8 = find_variant(enum_decl, field_name, field_len);
                if variant == nil {
                    eprint("error: enum '");
                    eprint_buf(enum_name, enum_name_len);
                    eprint("' has no variant '");
                    eprint_buf(field_name, field_len);
                    eprintln("'");
                    cg_had_error = 1;
                    return;
                }

                // Allocate space for enum on stack
                var enum_size i64 = get_enum_size(enum_decl);
                cg_stack_size = cg_stack_size + enum_size;
                var enum_offset i64 = 0 - cg_stack_size;

                // Set tag
                var tag i64 = enum_variant_tag(variant);
                emit_str("    movq $");
                emit_int(tag);
                emit_str(", ");
                emit_int(enum_offset);
                emit_line("(%rbp)");

                // Zero out payload slot (for safety)
                emit_str("    movq $0, ");
                emit_int(enum_offset + 8);
                emit_line("(%rbp)");

                // Return pointer to enum value
                emit_str("    lea ");
                emit_int(enum_offset);
                emit_line("(%rbp), %rax");
                return;
            }
        }

        // Get type of base expression
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            return;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;
        var is_pointer i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            // Pointer to struct: get the pointed-to type
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
                is_pointer = 1;
            }
        }

        if struct_name == nil {
            return;
        }

        // Look up struct
        cg_temp_struct_decl = find_struct(struct_name, struct_name_len);
        if cg_temp_struct_decl == nil {
            return;
        }

        // Get field offset
        var field_offset i64 = get_field_offset(cg_temp_struct_decl, field_name, field_len);
        if field_offset < 0 {
            return;
        }

        // Get field type to check if it's an aggregate (struct)
        var field_type *u8 = get_field_type(cg_temp_struct_decl, field_name, field_len);
        var field_is_struct i64 = 0;
        if field_type != nil && type_kind(field_type) == TYPE_BASE {
            var ft_name *u8 = base_type_name(field_type);
            var ft_name_len i64 = base_type_name_len(field_type);
            if find_struct(ft_name, ft_name_len) != nil {
                field_is_struct = 1;
            }
        }

        // Generate code to load field value (or address for struct fields)
        if is_pointer != 0 {
            // Pointer to struct: load pointer, then access field
            gen_expr(base_expr);
            if field_is_struct != 0 {
                // Field is a struct - return address, not value
                if field_offset == 0 {
                    // Address is already in %rax
                } else {
                    emit_str("    add $");
                    emit_int(field_offset);
                    emit_line(", %rax");
                }
            } else {
                // Field is a scalar - load value
                if field_offset == 0 {
                    emit_line("    mov (%rax), %rax");
                } else {
                    emit_str("    mov ");
                    emit_int(field_offset);
                    emit_line("(%rax), %rax");
                }
            }
            return;
        }

        // Direct struct variable: load from (base_offset + field_offset)(%rbp)
        if node_kind(base_expr) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(base_expr);
            var name_len i64 = ident_expr_name_len(base_expr);
            var local_idx i64 = find_local(name, name_len);
            if local_idx >= 0 {
                var base_offset i64 = local_get_offset(local_idx);
                if field_is_struct != 0 {
                    // Field is a struct - return address
                    emit_str("    lea ");
                    emit_int(base_offset + field_offset);
                    emit_line("(%rbp), %rax");
                } else {
                    emit_str("    mov ");
                    emit_int(base_offset + field_offset);
                    emit_line("(%rbp), %rax");
                }
                return;
            }
        }

        // Base is a field expression that evaluates to an address (e.g., r.size.x where r is *Rect)
        // In this case, evaluate base_expr (returns address), then access field
        if node_kind(base_expr) == NODE_FIELD_EXPR {
            gen_expr(base_expr);  // This now correctly returns address for struct fields
            if field_is_struct != 0 {
                // Field is a struct - add offset to get address
                if field_offset != 0 {
                    emit_str("    add $");
                    emit_int(field_offset);
                    emit_line(", %rax");
                }
            } else {
                // Field is a scalar - load value
                if field_offset == 0 {
                    emit_line("    mov (%rax), %rax");
                } else {
                    emit_str("    mov ");
                    emit_int(field_offset);
                    emit_line("(%rax), %rax");
                }
            }
            return;
        }

        // Nested field access (e.g., o.inner.x): use recursive helper
        var total_offset i64 = compute_nested_field_offset(expr);
        if total_offset >= 0 {
            var base_offset i64 = local_get_offset(cg_nested_field_base_local);
            emit_str("    mov ");
            emit_int(base_offset + total_offset);
            emit_line("(%rbp), %rax");
            return;
        }
        return;
    }

    if k == NODE_READER_EXPR {
        // Reader macro invocation - V2: run compiled executable
        var name *u8 = reader_expr_name(expr);
        var name_len i64 = reader_expr_name_len(expr);
        var content *u8 = reader_expr_content(expr);
        var content_len i64 = reader_expr_content_len(expr);

        // Look up the reader
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            eprint("error: reader macro '");
            eprint_buf(name, name_len);
            eprintln("' not found");
            cg_had_error = 1;
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = build_reader_cache_path(name, name_len);

        // Execute reader with content as input
        var output *u8 = alloc(65536);
        var n i64 = exec_capture(exe_path, content, content_len, output, 65536);

        if n <= 0 {
            eprint("error: reader '");
            eprint_buf(name, name_len);
            eprintln("' returned no output");
            cg_had_error = 1;
            return;
        }

        // Parse the output as S-expr AST expression (readers MUST output AST)
        var expanded *u8 = parse_ast_expression_from_string(output);
        if expanded != nil {
            gen_expr(expanded);
        }
        return;
    }

    if k == NODE_LET_EXPR {
        // Save local scope for restoration after body
        var saved_local_count i64 = cg_local_count;

        // Get type (use i64 as default if no type annotation)
        var var_type *u8 = let_expr_type(expr);
        if var_type == nil {
            // Infer type from init expression
            var_type = get_expr_type(let_expr_init(expr));
            if var_type == nil {
                // Default to i64 if type inference fails
                var_type = alloc(24);
                node_set_kind(var_type, TYPE_BASE);
                var p **u8 = var_type + 8;
                *p = "i64";
                var pl *i64 = var_type + 16;
                *pl = 3;
            }
        }

        // Allocate stack space
        var var_size i64 = get_type_size(var_type);
        if var_size < 8 {
            var_size = 8;
        }
        cg_stack_size = cg_stack_size + var_size;
        var offset i64 = 0 - cg_stack_size;

        // Add local variable
        add_local(let_expr_name(expr), let_expr_name_len(expr), offset, var_type);

        // Generate init expression and store to local
        gen_expr(let_expr_init(expr));
        emit_str("    mov %rax, ");
        emit_int(offset);
        emit_line("(%rbp)");

        // Generate body expression (result stays in %rax)
        gen_expr(let_expr_body(expr));

        // Restore local scope (variable goes out of scope)
        cg_local_count = saved_local_count;
        return;
    }

    if k == NODE_LAMBDA_EXPR {
        // Set up parent captures if we're inside a closure
        // This allows nested lambdas to capture variables from enclosing closures
        var saved_parent_captures *u8 = cg_parent_captures;
        var saved_parent_count i64 = cg_parent_capture_count;
        if cg_in_closure == 1 {
            // We're inside a closure - make current closure's captures available as parent
            cg_parent_captures = cg_closure_captures;
            cg_parent_capture_count = cg_closure_capture_count;
        }

        // Analyze captures for this lambda
        var param_count i64 = lambda_expr_param_count(expr);
        var capture_count i64 = analyze_lambda_captures(expr, param_count);

        // Restore parent captures
        cg_parent_captures = saved_parent_captures;
        cg_parent_capture_count = saved_parent_count;

        // Register lambda for later emission
        if cg_lambdas == nil {
            cg_lambdas = alloc(LIMIT_LAMBDAS * 32);
        }
        var lambda_id i64 = cg_lambda_count;
        var entry *u8 = cg_lambdas + (cg_lambda_count * 32);
        var p_node **u8 = entry;
        *p_node = expr;
        var p_id *i64 = entry + 8;
        *p_id = lambda_id;

        // Store capture info with lambda
        // Copy captures array for this lambda (so it persists)
        var captures_copy *u8 = nil;
        if capture_count > 0 {
            captures_copy = alloc(capture_count * 32);
            var i i64 = 0;
            while i < capture_count {
                var src *u8 = cg_current_captures + (i * 32);
                var dst *u8 = captures_copy + (i * 32);
                // Copy 32 bytes per entry
                var j i64 = 0;
                while j < 32 {
                    *(dst + j) = *(src + j);
                    j = j + 1;
                }
                i = i + 1;
            }
        }
        var p_captures **u8 = entry + 16;
        *p_captures = captures_copy;
        var p_cap_count *i64 = entry + 24;
        *p_cap_count = capture_count;
        cg_lambda_count = cg_lambda_count + 1;

        if capture_count == 0 {
            // No captures - just return function address
            emit_str("    lea __lambda_");
            emit_int(lambda_id);
            emit_line("(%rip), %rax");
        } else {
            // Has captures - allocate closure struct
            // Closure layout: [tag:8][fn_ptr:8][capture1:8][capture2:8]...
            // tag = 1 means "this is a closure, pass struct as hidden first arg"
            var closure_size i64 = 16 + (capture_count * 8);

            // Allocate closure struct
            emit_str("    mov $");
            emit_int(closure_size);
            emit_line(", %rdi");
            emit_line("    call alloc");
            emit_line("    push %rax");  // Save closure ptr

            // Store tag = 1 (closure with captures)
            emit_line("    movq $1, (%rax)");

            // Store function pointer at offset 8
            emit_str("    lea __lambda_");
            emit_int(lambda_id);
            emit_line("(%rip), %rbx");
            emit_line("    mov %rbx, 8(%rax)");

            // Copy captured values from outer scope (starting at offset 16)
            var i i64 = 0;
            while i < capture_count {
                var outer_offset i64 = capture_get_outer_offset(i);
                var closure_offset i64 = 16 + (i * 8);

                if outer_offset == (0 - 1) {
                    // Capture from parent closure - need to load from parent closure struct
                    // First, find which capture index in parent this corresponds to
                    var cap_name *u8 = capture_get_name(i);
                    var cap_name_len i64 = capture_get_name_len(i);
                    var parent_cap_idx i64 = find_closure_capture(cap_name, cap_name_len);
                    if parent_cap_idx >= 0 {
                        var parent_offset i64 = 16 + (parent_cap_idx * 8);
                        // Load parent closure pointer
                        emit_str("    mov ");
                        emit_int(cg_closure_ptr_offset);
                        emit_line("(%rbp), %rcx");
                        // Load from parent closure
                        emit_str("    mov ");
                        emit_int(parent_offset);
                        emit_line("(%rcx), %rbx");
                    }
                } else {
                    // Load from outer scope (regular local variable)
                    emit_str("    mov ");
                    emit_int(outer_offset);
                    emit_line("(%rbp), %rbx");
                }

                // Store into closure struct
                emit_line("    pop %rax");
                emit_line("    push %rax");
                emit_str("    mov %rbx, ");
                emit_int(closure_offset);
                emit_line("(%rax)");

                i = i + 1;
            }

            // Return closure pointer
            emit_line("    pop %rax");
        }
        return;
    }

    if k == NODE_MATCH_EXPR {
        // Generate match expression: compile to if/else chain
        var scrutinee *u8 = match_expr_scrutinee(expr);
        var arms *u8 = match_expr_arms(expr);
        var arm_count i64 = match_expr_arm_count(expr);

        // Allocate space to save scrutinee pointer
        cg_stack_size = cg_stack_size + 8;
        var scrutinee_offset i64 = 0 - cg_stack_size;

        // Evaluate scrutinee and save pointer
        gen_expr(scrutinee);
        emit_str("    mov %rax, ");
        emit_int(scrutinee_offset);
        emit_line("(%rbp)");

        // Load tag from scrutinee
        emit_line("    mov (%rax), %rbx");  // tag in %rbx

        var end_label i64 = new_label();

        var i i64 = 0;
        while i < arm_count {
            var arm *u8 = get_match_arm(arms, i);
            var pattern *u8 = match_arm_pattern(arm);
            var body *u8 = match_arm_body(arm);
            var pk i64 = node_kind(pattern);

            if pk == NODE_PATTERN_WILDCARD {
                // Wildcard matches anything - just emit body
                // (body is either expression or NODE_BLOCK_EXPR, both handled by gen_expr)
                gen_expr(body);
                emit_str("    jmp ");
                emit_label(end_label);
                emit_char(10);
            } else if pk == NODE_PATTERN_VARIANT {
                // Get variant info from pattern
                var enum_name *u8 = pattern_variant_enum_name(pattern);
                var enum_len i64 = pattern_variant_enum_len(pattern);
                var var_name *u8 = pattern_variant_name(pattern);
                var var_len i64 = pattern_variant_name_len(pattern);
                var binding *u8 = pattern_variant_binding(pattern);
                var binding_len i64 = pattern_variant_binding_len(pattern);

                // Look up enum and variant to get tag
                var enum_decl *u8 = find_enum(enum_name, enum_len);
                if enum_decl == nil {
                    eprint("error: unknown enum '");
                    eprint_buf(enum_name, enum_len);
                    eprintln("' in match pattern");
                    cg_had_error = 1;
                    return;
                }
                var variant *u8 = find_variant(enum_decl, var_name, var_len);
                if variant == nil {
                    eprint("error: unknown variant '");
                    eprint_buf(var_name, var_len);
                    eprintln("' in match pattern");
                    cg_had_error = 1;
                    return;
                }
                var expected_tag i64 = enum_variant_tag(variant);

                // Compare tag
                var next_label i64 = new_label();
                emit_str("    cmp $");
                emit_int(expected_tag);
                emit_line(", %rbx");
                emit_str("    jne ");
                emit_label(next_label);
                emit_char(10);

                // If we have a binding, bind the payload
                if binding != nil {
                    var saved_local_count i64 = cg_local_count;

                    // Infer type and size from variant payload
                    var payload_type *u8 = enum_variant_type(variant);
                    var payload_size i64 = 8;
                    if payload_type != nil {
                        payload_size = get_type_size(payload_type);
                    }

                    // Create local for the binding (full payload size)
                    cg_stack_size = cg_stack_size + payload_size;
                    var bind_offset i64 = 0 - cg_stack_size;
                    add_local(binding, binding_len, bind_offset, payload_type);

                    // Copy payload from scrutinee+8
                    emit_str("    mov ");
                    emit_int(scrutinee_offset);
                    emit_line("(%rbp), %rsi");  // scrutinee pointer

                    var copy_idx i64 = 0;
                    while copy_idx < payload_size {
                        emit_str("    mov ");
                        emit_int(8 + copy_idx);
                        emit_line("(%rsi), %rcx");
                        emit_str("    mov %rcx, ");
                        emit_int(bind_offset + copy_idx);
                        emit_line("(%rbp)");
                        copy_idx = copy_idx + 8;
                    }

                    // Generate body (expression or block expression)
                    gen_expr(body);

                    // Restore scope
                    cg_local_count = saved_local_count;
                } else {
                    // No binding, just generate body
                    gen_expr(body);
                }

                emit_str("    jmp ");
                emit_label(end_label);
                emit_char(10);

                emit_label(next_label);
                emit_line(":");
            }
            i = i + 1;
        }

        emit_label(end_label);
        emit_line(":");
        return;
    }

    // If expression: if cond { then } else { else }
    // Evaluates to the value of the taken branch
    if k == NODE_IF_STMT {
        var if_else_label i64 = new_label();
        var if_end_label i64 = new_label();
        var if_then *u8 = if_stmt_then(expr);
        var if_else *u8 = if_stmt_else(expr);

        // Evaluate condition
        gen_expr(if_stmt_cond(expr));
        emit_line("    test %rax, %rax");

        if if_else != nil {
            // Has else branch
            emit_str("    jz ");
            emit_label(if_else_label);
            emit_char(10);

            // Generate then branch (expression or statement)
            if node_kind(if_then) == NODE_BLOCK_STMT {
                gen_stmt(if_then);
            } else {
                gen_expr(if_then);
            }

            emit_str("    jmp ");
            emit_label(if_end_label);
            emit_char(10);

            emit_label(if_else_label);
            emit_line(":");

            // Generate else branch
            if node_kind(if_else) == NODE_BLOCK_STMT {
                gen_stmt(if_else);
            } else {
                gen_expr(if_else);
            }
        } else {
            // No else branch - result is 0 (nil) if condition is false
            emit_str("    jz ");
            emit_label(if_end_label);
            emit_char(10);

            if node_kind(if_then) == NODE_BLOCK_STMT {
                gen_stmt(if_then);
            } else {
                gen_expr(if_then);
            }
        }

        emit_label(if_end_label);
        emit_line(":");
        return;
    }

    // Block expression: { stmts; tail_expr }
    // Evaluates to the tail expression's value
    if k == NODE_BLOCK_EXPR {
        var stmts *u8 = block_expr_stmts(expr);
        var count i64 = block_expr_count(expr);
        var tail *u8 = block_expr_tail(expr);

        // Generate all statements
        var i i64 = 0;
        while i < count {
            var p **u8 = stmts + (i * 8);
            gen_stmt(*p);
            i = i + 1;
        }

        // Generate tail expression (leaves value in %rax)
        if tail != nil {
            gen_expr(tail);
        }
        return;
    }

    // Handle expression: handle { body } with { return(v) => ..., Effect(e, k) => ... }
    if k == NODE_HANDLE_EXPR {
        var body *u8 = handle_expr_body(expr);
        var cases *u8 = handle_expr_cases(expr);
        var case_count i64 = handle_expr_case_count(expr);
        var ret_bind *u8 = handle_expr_ret_bind(expr);
        var ret_bind_len i64 = handle_expr_ret_bind_len(expr);
        var ret_body *u8 = handle_expr_ret_body(expr);

        // Generate labels
        var handler_label i64 = new_label();
        var done_label i64 = new_label();

        // Set up handler - save current state and set handler address
        emit_line("    movq %rbp, __handler_rbp(%rip)");
        emit_line("    movq %rsp, __handler_rsp(%rip)");
        emit_str("    leaq ");
        emit_label(handler_label);
        emit_line("(%rip), %rax");
        emit_line("    movq %rax, __handler_addr(%rip)");
        emit_line("    movq $1, __handler_set(%rip)");

        // Generate body (may be expression or block statement)
        if node_kind(body) == NODE_BLOCK_STMT {
            gen_stmt(body);
        } else {
            gen_expr(body);
        }

        // Normal completion - go to done (skip handler)
        emit_str("    jmp ");
        emit_label(done_label);
        emit_char(10);

        // Handler entry point
        emit_label(handler_label);
        emit_line(":");

        // Effect value is in __effect_value, continuation in __continuation_ptr
        // Effect name is in __effect_name_ptr/__effect_name_len
        // Case layout: [name:8][len:8][bind:8][bind_len:8][k:8][k_len:8][body:8] = 56 bytes

        // Generate dispatch code for each effect case
        var case_i i64 = 0;
        while case_i < case_count {
            var entry *u8 = cases + (case_i * 56);
            var eff_name *u8 = effect_case_name(entry);
            var eff_name_len i64 = effect_case_name_len(entry);
            var bind_ptr *u8 = effect_case_binding(entry);
            var bind_len i64 = effect_case_binding_len(entry);
            var k_ptr *u8 = effect_case_k(entry);
            var k_len i64 = effect_case_k_len(entry);
            var case_body *u8 = effect_case_body(entry);

            // Look up effect declaration to check arity
            var eff_decl *u8 = find_effect(eff_name, eff_name_len);
            var eff_param_count i64 = 0;
            if eff_decl != nil {
                eff_param_count = effect_decl_param_type_count(eff_decl);
            }

            // For zero-arg effects like Read(), the syntax is Read(k) where k is continuation
            if eff_param_count == 0 && k_len == 0 && bind_len > 0 {
                k_ptr = bind_ptr;
                k_len = bind_len;
                bind_ptr = nil;
                bind_len = 0;
            }

            // Generate label for this case and next case
            var case_label i64 = new_label();
            var next_case_label i64 = new_label();

            // Compare performed effect name with this case's effect name
            // First check length
            emit_line("    movq __effect_name_len(%rip), %rax");
            emit_str("    cmpq $");
            emit_int(eff_name_len);
            emit_line(", %rax");
            emit_str("    jne ");
            emit_label(next_case_label);
            emit_char(10);

            // Compare strings inline (repe cmpsb)
            var eff_str_idx i64 = add_string(eff_name, eff_name_len);
            emit_line("    movq __effect_name_ptr(%rip), %rsi");
            emit_str("    leaq .str");
            emit_int(eff_str_idx);
            emit_line("(%rip), %rdi");
            emit_str("    movq $");
            emit_int(eff_name_len);
            emit_line(", %rcx");
            emit_line("    repe cmpsb");
            emit_str("    je ");
            emit_label(case_label);
            emit_char(10);

            // Case body
            emit_label(case_label);
            emit_line(":");

            var saved_local_count i64 = cg_local_count;

            // Create local for effect value binding (e)
            var bind_offset i64 = 0;
            if bind_len > 0 {
                cg_stack_size = cg_stack_size + 8;
                bind_offset = 0 - cg_stack_size;
                add_local(bind_ptr, bind_len, bind_offset, nil);

                emit_line("    movq __effect_value(%rip), %rax");
                emit_str("    movq %rax, ");
                emit_int(bind_offset);
                emit_line("(%rbp)");
            }

            // Create local for continuation binding (k)
            if k_len > 0 {
                cg_stack_size = cg_stack_size + 8;
                var k_offset i64 = 0 - cg_stack_size;
                add_local(k_ptr, k_len, k_offset, nil);

                emit_line("    movq __continuation_ptr(%rip), %rax");
                emit_str("    movq %rax, ");
                emit_int(k_offset);
                emit_line("(%rbp)");
            }

            // Generate case body
            if node_kind(case_body) == NODE_BLOCK_STMT {
                gen_stmt(case_body);
            } else {
                gen_expr(case_body);
            }

            cg_local_count = saved_local_count;

            // Jump to done after case
            emit_str("    jmp ");
            emit_label(done_label);
            emit_char(10);

            // Next case label
            emit_label(next_case_label);
            emit_line(":");

            case_i = case_i + 1;
        }

        // Done - clear handler and result is in %rax
        emit_label(done_label);
        emit_line(":");
        emit_line("    movq $0, __handler_set(%rip)");

        // Apply return case if present (for normal completion path)
        // The body result is already in %rax
        // For simplicity, return case is just identity for now
        return;
    }

    // Perform expression: perform Effect(args)
    // Creates a continuation struct and jumps to handler
    if k == NODE_PERFORM_EXPR {
        var args *u8 = perform_expr_args(expr);
        var arg_count i64 = perform_expr_arg_count(expr);

        // Create a resume label (where we'll return to after resume)
        var resume_label i64 = new_label();

        // Allocate continuation struct: [rbp:8][rsp:8][return_addr:8] = 24 bytes
        emit_line("    mov $24, %rdi");
        emit_line("    call alloc");
        emit_line("    push %rax");  // Save continuation pointer

        // Store rbp at offset 0
        emit_line("    movq %rbp, (%rax)");

        // Store rsp at offset 8 (current rsp, before we pushed)
        emit_line("    leaq 8(%rsp), %rbx");  // rsp before push
        emit_line("    movq %rbx, 8(%rax)");

        // Store return address at offset 16
        emit_str("    leaq ");
        emit_label(resume_label);
        emit_line("(%rip), %rbx");
        emit_line("    movq %rbx, 16(%rax)");

        // Store continuation pointer in global
        emit_line("    movq %rax, __continuation_ptr(%rip)");

        // Store effect name for handler dispatch
        var eff_name *u8 = perform_expr_name(expr);
        var eff_name_len i64 = perform_expr_name_len(expr);
        var eff_str_idx i64 = add_string(eff_name, eff_name_len);
        emit_str("    leaq .str");
        emit_int(eff_str_idx);
        emit_line("(%rip), %rax");
        emit_line("    movq %rax, __effect_name_ptr(%rip)");
        emit_str("    movq $");
        emit_int(eff_name_len);
        emit_line(", %rax");
        emit_line("    movq %rax, __effect_name_len(%rip)");

        // Evaluate first arg (if any) and store in __effect_value
        if arg_count > 0 {
            var first_arg_ptr **u8 = args;
            gen_expr(*first_arg_ptr);
            emit_line("    movq %rax, __effect_value(%rip)");
        }

        // Pop the continuation pointer (we stored it in global)
        emit_line("    addq $8, %rsp");

        // Restore handler's rbp (for accessing handler's locals) but NOT rsp
        // Keeping rsp at effectful function's stack prevents handler's push/pop
        // from overwriting the effectful function's return address
        emit_line("    movq __handler_rbp(%rip), %rbp");
        emit_line("    jmpq *__handler_addr(%rip)");

        // Resume point: when resume k(v) is called, we land here with v in %rax
        emit_label(resume_label);
        emit_line(":");
        return;
    }

    // Resume expression: resume k(value)
    // Restores continuation and returns to perform site
    if k == NODE_RESUME_EXPR {
        var k_expr *u8 = resume_expr_k(expr);
        var value *u8 = resume_expr_value(expr);

        // Evaluate continuation expression (the k variable)
        gen_expr(k_expr);
        emit_line("    mov %rax, %rbx");  // rbx = continuation pointer

        // Extract all values from continuation BEFORE restoring stack
        // Continuation struct: [rbp:8][rsp:8][return_addr:8]
        emit_line("    movq (%rbx), %r12");    // r12 = saved rbp
        emit_line("    movq 8(%rbx), %r13");   // r13 = saved rsp
        emit_line("    movq 16(%rbx), %r14");  // r14 = return address

        // Evaluate value to resume with (if any)
        if value != nil {
            gen_expr(value);
        } else {
            emit_line("    xor %eax, %eax");  // Default to 0
        }
        // rax now has the resume value

        // Restore rbp and rsp, then jump
        emit_line("    mov %r12, %rbp");
        emit_line("    mov %r13, %rsp");
        emit_line("    jmpq *%r14");
        return;
    }
}

func gen_syscall(args *u8, arg_count i64) void {
    if arg_count == 0 {
        return;
    }

    // Push all args in reverse
    var i i64 = arg_count - 1;
    while i >= 0 {
        var p **u8 = args + (i * 8);
        gen_expr(*p);
        emit_line("    push %rax");
        i = i - 1;
    }

    // Pop syscall number into rax
    emit_line("    pop %rax");

    // Pop args into syscall registers: rdi, rsi, rdx, r10, r8, r9
    i = 1;
    while i < arg_count && i <= 6 {
        if i == 1 { emit_line("    pop %rdi"); }
        else if i == 2 { emit_line("    pop %rsi"); }
        else if i == 3 { emit_line("    pop %rdx"); }
        else if i == 4 { emit_line("    pop %r10"); }
        else if i == 5 { emit_line("    pop %r8"); }
        else if i == 6 { emit_line("    pop %r9"); }
        i = i + 1;
    }

    emit_line("    syscall");
}

func gen_lvalue_store(expr *u8) void {
    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            var offset i64 = local_get_offset(local_idx);
            var var_type *u8 = local_get_type(local_idx);

            // Check if this is an enum type - need to copy full value
            if var_type != nil && type_kind(var_type) == TYPE_BASE {
                var type_name *u8 = base_type_name(var_type);
                var type_name_len i64 = base_type_name_len(var_type);
                var enum_decl *u8 = find_enum(type_name, type_name_len);
                if enum_decl != nil {
                    // %rax has pointer to source enum, copy full enum
                    var enum_size i64 = get_enum_size(enum_decl);
                    emit_line("    mov %rax, %rsi");  // source pointer
                    var copy_i i64 = 0;
                    while copy_i < enum_size {
                        emit_str("    mov ");
                        emit_int(copy_i);
                        emit_line("(%rsi), %rcx");
                        emit_str("    mov %rcx, ");
                        emit_int(offset + copy_i);
                        emit_line("(%rbp)");
                        copy_i = copy_i + 8;
                    }
                    return;
                }
            }

            emit_str("    mov %rax, ");
            emit_int(offset);
            emit_line("(%rbp)");
            return;
        }

        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            emit_str("    mov %rax, ");
            emit_n(name, name_len);
            emit_line("(%rip)");
            return;
        }
        return;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_STAR {
            // *ptr = value
            emit_line("    push %rax");
            gen_expr(unary_expr_expr(expr));
            emit_line("    mov %rax, %rcx");
            emit_line("    pop %rax");
            emit_line("    mov %rax, (%rcx)");
            return;
        }
    }

    if k == NODE_FIELD_EXPR {
        // p.x = value - store to struct field
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Get type of base expression
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            return;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;
        var is_pointer i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
                is_pointer = 1;
            }
        }

        if struct_name == nil {
            return;
        }

        // Look up struct
        cg_temp_struct_decl = find_struct(struct_name, struct_name_len);
        if cg_temp_struct_decl == nil {
            return;
        }

        // Get field offset
        var field_offset i64 = get_field_offset(cg_temp_struct_decl, field_name, field_len);
        if field_offset < 0 {
            return;
        }

        // Check if this field is an enum type
        var field_type *u8 = get_field_type(cg_temp_struct_decl, field_name, field_len);
        var is_enum_field i64 = 0;
        if field_type != nil && type_kind(field_type) == TYPE_BASE {
            var ft_name *u8 = base_type_name(field_type);
            var ft_name_len i64 = base_type_name_len(field_type);
            if find_enum(ft_name, ft_name_len) != nil {
                is_enum_field = 1;
            }
        }

        // Generate code to store to field
        if is_pointer != 0 {
            // Pointer to struct: save value, load pointer, store to field
            emit_line("    push %rax");
            gen_expr(base_expr);
            emit_line("    mov %rax, %rcx");
            emit_line("    pop %rax");
            if is_enum_field != 0 {
                // Copy tag + payload for enum field
                emit_line("    mov (%rax), %rbx");
                if field_offset == 0 {
                    emit_line("    mov %rbx, (%rcx)");
                } else {
                    emit_str("    mov %rbx, ");
                    emit_int(field_offset);
                    emit_line("(%rcx)");
                }
                emit_line("    mov 8(%rax), %rbx");
                emit_str("    mov %rbx, ");
                emit_int(field_offset + 8);
                emit_line("(%rcx)");
            } else {
                if field_offset == 0 {
                    emit_line("    mov %rax, (%rcx)");
                } else {
                    emit_str("    mov %rax, ");
                    emit_int(field_offset);
                    emit_line("(%rcx)");
                }
            }
            return;
        }

        // Direct struct variable: store to (base_offset + field_offset)(%rbp)
        if node_kind(base_expr) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(base_expr);
            var name_len i64 = ident_expr_name_len(base_expr);
            var local_idx i64 = find_local(name, name_len);
            if local_idx >= 0 {
                var base_offset i64 = local_get_offset(local_idx);
                if is_enum_field != 0 {
                    // Copy tag + payload for enum field
                    emit_line("    mov (%rax), %rcx");
                    emit_str("    mov %rcx, ");
                    emit_int(base_offset + field_offset);
                    emit_line("(%rbp)");
                    emit_line("    mov 8(%rax), %rcx");
                    emit_str("    mov %rcx, ");
                    emit_int(base_offset + field_offset + 8);
                    emit_line("(%rbp)");
                } else {
                    emit_str("    mov %rax, ");
                    emit_int(base_offset + field_offset);
                    emit_line("(%rbp)");
                }
                return;
            }
        }

        // Nested field access (e.g., o.inner.x = val): use recursive helper
        var total_offset i64 = compute_nested_field_offset(expr);
        if total_offset >= 0 {
            var base_offset i64 = local_get_offset(cg_nested_field_base_local);
            if is_enum_field != 0 {
                // Copy tag + payload for enum field
                emit_line("    mov (%rax), %rcx");
                emit_str("    mov %rcx, ");
                emit_int(base_offset + total_offset);
                emit_line("(%rbp)");
                emit_line("    mov 8(%rax), %rcx");
                emit_str("    mov %rcx, ");
                emit_int(base_offset + total_offset + 8);
                emit_line("(%rbp)");
            } else {
                emit_str("    mov %rax, ");
                emit_int(base_offset + total_offset);
                emit_line("(%rbp)");
            }
            return;
        }
        return;
    }
}

// ============================================================
// Statement code generation
// ============================================================

func gen_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }

    var k i64 = node_kind(stmt);

    if k == NODE_VAR_DECL {
        var var_type *u8 = var_decl_type(stmt);
        var var_size i64 = get_type_size(var_type);
        if var_size < 8 {
            var_size = 8;  // Minimum 8 bytes for alignment
        }
        cg_stack_size = cg_stack_size + var_size;
        var offset i64 = 0 - cg_stack_size;

        add_local(var_decl_name(stmt), var_decl_name_len(stmt), offset, var_decl_type(stmt));

        var init *u8 = var_decl_init(stmt);
        if init != nil {
            // Safety check: capturing lambda assigned to fn type is unsafe
            // Because fn(T) R uses plain function pointer calling convention,
            // but closures need their struct passed as first argument.
            // Use closure(T) R type for capturing lambdas (auto-calling convention).
            if var_type != nil && type_kind(var_type) == TYPE_FUNC {
                if node_kind(init) == NODE_LAMBDA_EXPR {
                    if lambda_has_captures(init) == 1 {
                        eprint("error: cannot assign capturing lambda to 'fn' type variable '");
                        eprint_buf(var_decl_name(stmt), var_decl_name_len(stmt));
                        eprintln("'");
                        eprintln("  hint: use 'closure(T) R' type for capturing lambdas");
                        eprintln("  hint: fn(T) R only accepts non-capturing lambdas and &func");
                        cg_had_error = 1;
                        return;
                    }
                }
            }

            gen_expr(init);

            // Check if assigning non-capturing lambda to closure type
            // Wrap it in a closure struct with tag=0
            if var_type != nil && type_kind(var_type) == TYPE_CLOSURE {
                if node_kind(init) == NODE_LAMBDA_EXPR {
                    if lambda_has_captures(init) == 0 {
                        // %rax has function pointer, wrap in closure struct
                        // Allocate struct: [tag:8][fn_ptr:8] = 16 bytes
                        emit_line("    push %rax");  // Save fn ptr
                        emit_line("    mov $16, %rdi");
                        emit_line("    call alloc");
                        emit_line("    movq $0, (%rax)");  // tag = 0 (plain function)
                        emit_line("    pop %rbx");
                        emit_line("    mov %rbx, 8(%rax)");  // fn_ptr at offset 8
                    }
                }
            }

            // Check if this is an enum type - need to copy full value
            if type_kind(var_type) == TYPE_BASE {
                var type_name *u8 = base_type_name(var_type);
                var type_name_len i64 = base_type_name_len(var_type);
                var enum_decl *u8 = find_enum(type_name, type_name_len);
                if enum_decl != nil {
                    // %rax has pointer to source enum, copy full enum
                    var enum_size i64 = get_enum_size(enum_decl);
                    emit_line("    mov %rax, %rsi");  // source pointer
                    var copy_j i64 = 0;
                    while copy_j < enum_size {
                        emit_str("    mov ");
                        emit_int(copy_j);
                        emit_line("(%rsi), %rcx");
                        emit_str("    mov %rcx, ");
                        emit_int(offset + copy_j);
                        emit_line("(%rbp)");
                        copy_j = copy_j + 8;
                    }
                    return;
                }
            }

            emit_str("    mov %rax, ");
            emit_int(offset);
            emit_line("(%rbp)");
        }
        return;
    }

    if k == NODE_EXPR_STMT {
        gen_expr(expr_stmt_expr(stmt));
        return;
    }

    // Explicit assignment statement (AST 2.0)
    if k == NODE_ASSIGN_STMT {
        gen_expr(assign_stmt_value(stmt));
        gen_lvalue_store(assign_stmt_target(stmt));
        return;
    }

    if k == NODE_RETURN_STMT {
        var value *u8 = return_stmt_value(stmt);
        if value != nil {
            gen_expr(value);
        } else {
            emit_line("    xor %rax, %rax");
        }
        emit_line("    leave");
        emit_line("    ret");
        return;
    }

    if k == NODE_IF_STMT {
        var else_label i64 = new_label();
        var end_label i64 = new_label();

        gen_expr(if_stmt_cond(stmt));
        emit_line("    test %rax, %rax");

        if if_stmt_else(stmt) != nil {
            emit_str("    jz ");
            emit_label(else_label);
            emit_char(10);
        } else {
            emit_str("    jz ");
            emit_label(end_label);
            emit_char(10);
        }

        gen_block(if_stmt_then(stmt));

        if if_stmt_else(stmt) != nil {
            emit_str("    jmp ");
            emit_label(end_label);
            emit_char(10);

            emit_label(else_label);
            emit_line(":");

            var els *u8 = if_stmt_else(stmt);
            if node_kind(els) == NODE_BLOCK_STMT {
                gen_block(els);
            } else {
                gen_stmt(els);
            }
        }

        emit_label(end_label);
        emit_line(":");
        return;
    }

    if k == NODE_WHILE_STMT {
        var start_label i64 = new_label();
        var end_label i64 = new_label();

        // Push loop onto stack with optional label
        var loop_name *u8 = while_stmt_label(stmt);
        var loop_name_len i64 = while_stmt_label_len(stmt);
        loop_stack_push(loop_name, loop_name_len, end_label, start_label);

        emit_label(start_label);
        emit_line(":");

        gen_expr(while_stmt_cond(stmt));
        emit_line("    test %rax, %rax");
        emit_str("    jz ");
        emit_label(end_label);
        emit_char(10);

        gen_block(while_stmt_body(stmt));

        emit_str("    jmp ");
        emit_label(start_label);
        emit_char(10);

        emit_label(end_label);
        emit_line(":");

        // Pop loop from stack
        loop_stack_pop();
        return;
    }

    if k == NODE_BLOCK_STMT {
        gen_block(stmt);
        return;
    }

    if k == NODE_BREAK_STMT {
        var label *u8 = break_stmt_label(stmt);
        var label_len i64 = break_stmt_label_len(stmt);
        var entry *u8 = loop_stack_find(label, label_len);
        if entry == nil {
            print("error: break outside of loop");
            if label != nil {
                print(" (label not found)");
            }
            print("\n");
            exit(1);
        }
        emit_str("    jmp ");
        emit_label(loop_entry_break_label(entry));
        emit_char(10);
        return;
    }

    if k == NODE_CONTINUE_STMT {
        var label *u8 = continue_stmt_label(stmt);
        var label_len i64 = continue_stmt_label_len(stmt);
        var entry *u8 = loop_stack_find(label, label_len);
        if entry == nil {
            print("error: continue outside of loop");
            if label != nil {
                print(" (label not found)");
            }
            print("\n");
            exit(1);
        }
        emit_str("    jmp ");
        emit_label(loop_entry_continue_label(entry));
        emit_char(10);
        return;
    }
}

func gen_block(block *u8) void {
    var stmts *u8 = block_stmt_stmts(block);
    var count i64 = block_stmt_count(block);

    var i i64 = 0;
    while i < count {
        var p **u8 = stmts + (i * 8);
        gen_stmt(*p);
        i = i + 1;
    }
}

// ============================================================
// Function code generation
// ============================================================

func gen_func(func_node *u8) void {
    // Reset locals
    cg_local_count = 0;
    cg_stack_size = 0;

    var name *u8 = func_decl_name(func_node);
    var name_len i64 = func_decl_name_len(func_node);

    // Emit function label to main buffer
    emit_str(".globl ");
    emit_n(name, name_len);
    emit_char(10);
    emit_n(name, name_len);
    emit_line(":");

    // Generate params and body to temp buffer (to calculate stack size)
    cg_in_func_body = 1;
    cg_func_len = 0;

    // Store parameters
    var params *u8 = func_decl_params(func_node);
    var param_count i64 = func_decl_param_count(func_node);

    var i i64 = 0;
    while i < param_count {
        cg_stack_size = cg_stack_size + 8;
        var offset i64 = 0 - cg_stack_size;

        var p *u8 = params + (i * 24);
        add_local(param_name(p), param_name_len(p), offset, param_type(p));

        // Move from arg register or stack to local stack slot
        if i == 0 {
            emit_str("    mov %rdi, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if i == 1 {
            emit_str("    mov %rsi, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if i == 2 {
            emit_str("    mov %rdx, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if i == 3 {
            emit_str("    mov %rcx, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if i == 4 {
            emit_str("    mov %r8, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if i == 5 {
            emit_str("    mov %r9, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else {
            // Args 7+ are on caller's stack: 16(%rbp), 24(%rbp), ...
            var stack_offset i64 = 16 + (i - 6) * 8;
            emit_str("    mov ");
            emit_int(stack_offset);
            emit_str("(%rbp), %rax");
            emit_char(10);
            emit_str("    mov %rax, ");
            emit_int(offset);
            emit_line("(%rbp)");
        }

        i = i + 1;
    }

    // Generate body (still to temp buffer)
    gen_block(func_decl_body(func_node));

    // Switch back to main buffer
    cg_in_func_body = 0;

    // Calculate aligned stack size (16-byte alignment, minimum 16)
    var aligned_size i64 = cg_stack_size;
    if aligned_size < 16 {
        aligned_size = 16;
    }
    // Round up to 16-byte boundary
    aligned_size = ((aligned_size + 15) / 16) * 16;

    // Emit prologue with actual stack size
    emit_line("    push %rbp");
    emit_line("    mov %rsp, %rbp");
    emit_str("    sub $");
    emit_int(aligned_size);
    emit_line(", %rsp");

    // Copy function body from temp buffer
    flush_func_body();

    // Default return if void
    var ret_type *u8 = func_decl_ret_type(func_node);
    if is_void_type(ret_type) {
        emit_line("    xor %rax, %rax");
        emit_line("    leave");
        emit_line("    ret");
    }

    emit_char(10);
}

// Generate a lambda function (similar to gen_func but with generated name)
func gen_lambda(lambda_node *u8, lambda_id i64, captures *u8, capture_count i64) void {
    // Reset locals
    cg_local_count = 0;
    cg_stack_size = 0;

    // Emit function label
    emit_str("__lambda_");
    emit_int(lambda_id);
    emit_line(":");

    // Generate params and body to temp buffer
    cg_in_func_body = 1;
    cg_func_len = 0;

    // Set up closure context if this lambda has captures
    if capture_count > 0 {
        cg_in_closure = 1;
        cg_closure_captures = captures;
        cg_closure_capture_count = capture_count;

        // First argument (%rdi) is the closure pointer
        cg_stack_size = cg_stack_size + 8;
        cg_closure_ptr_offset = 0 - cg_stack_size;
        emit_str("    mov %rdi, ");
        emit_int(cg_closure_ptr_offset);
        emit_line("(%rbp)");
    } else {
        cg_in_closure = 0;
    }

    // Store parameters
    var params *u8 = lambda_expr_params(lambda_node);
    var param_count i64 = lambda_expr_param_count(lambda_node);

    // Registers shift by 1 if this is a closure (first arg is closure ptr)
    var reg_offset i64 = 0;
    if capture_count > 0 {
        reg_offset = 1;
    }

    var i i64 = 0;
    while i < param_count {
        cg_stack_size = cg_stack_size + 8;
        var offset i64 = 0 - cg_stack_size;

        var p *u8 = params + (i * 24);
        add_local(param_name(p), param_name_len(p), offset, param_type(p));

        // Move from arg register to local stack slot
        // Register index is i + reg_offset
        var reg_idx i64 = i + reg_offset;
        if reg_idx == 0 {
            emit_str("    mov %rdi, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if reg_idx == 1 {
            emit_str("    mov %rsi, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if reg_idx == 2 {
            emit_str("    mov %rdx, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if reg_idx == 3 {
            emit_str("    mov %rcx, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if reg_idx == 4 {
            emit_str("    mov %r8, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else if reg_idx == 5 {
            emit_str("    mov %r9, ");
            emit_int(offset);
            emit_line("(%rbp)");
        } else {
            // Args 7+ are on caller's stack
            var stack_offset i64 = 16 + (reg_idx - 6) * 8;
            emit_str("    mov ");
            emit_int(stack_offset);
            emit_str("(%rbp), %rax");
            emit_char(10);
            emit_str("    mov %rax, ");
            emit_int(offset);
            emit_line("(%rbp)");
        }

        i = i + 1;
    }

    // Generate body
    gen_block(lambda_expr_body(lambda_node));

    // Switch back to main buffer
    cg_in_func_body = 0;

    // Clear closure context
    cg_in_closure = 0;
    cg_closure_captures = nil;
    cg_closure_capture_count = 0;

    // Calculate aligned stack size
    var aligned_size i64 = cg_stack_size;
    if aligned_size < 16 {
        aligned_size = 16;
    }
    aligned_size = ((aligned_size + 15) / 16) * 16;

    // Emit prologue
    emit_line("    push %rbp");
    emit_line("    mov %rsp, %rbp");
    emit_str("    sub $");
    emit_int(aligned_size);
    emit_line(", %rsp");

    // Copy function body from temp buffer
    flush_func_body();

    // Default return if void
    var ret_type *u8 = lambda_expr_ret_type(lambda_node);
    if is_void_type(ret_type) {
        emit_line("    xor %rax, %rax");
        emit_line("    leave");
        emit_line("    ret");
    }

    emit_char(10);
}

// Generate all collected lambdas
func gen_all_lambdas() void {
    var i i64 = 0;
    while i < cg_lambda_count {
        var entry *u8 = cg_lambdas + (i * 32);
        var p_node **u8 = entry;
        var lambda_node *u8 = *p_node;
        var p_id *i64 = entry + 8;
        var lambda_id i64 = *p_id;
        var p_captures **u8 = entry + 16;
        var captures *u8 = *p_captures;
        var p_cap_count *i64 = entry + 24;
        var capture_count i64 = *p_cap_count;
        gen_lambda(lambda_node, lambda_id, captures, capture_count);
        i = i + 1;
    }
}

// Generate reader as a callable function (for standalone compilers)
func gen_reader_func(reader_node *u8) void {
    // Reset locals
    cg_local_count = 0;
    cg_stack_size = 0;

    var name *u8 = reader_decl_name(reader_node);
    var name_len i64 = reader_decl_name_len(reader_node);

    // Emit function label to main buffer
    emit_str(".globl ");
    emit_n(name, name_len);
    emit_char(10);
    emit_n(name, name_len);
    emit_line(":");

    // Generate params and body to temp buffer
    cg_in_func_body = 1;
    cg_func_len = 0;

    // Store the single parameter (text *u8)
    cg_stack_size = cg_stack_size + 8;
    var offset i64 = 0 - cg_stack_size;

    var pname *u8 = reader_decl_param_name(reader_node);
    var param_len i64 = reader_decl_param_len(reader_node);

    // Create a *u8 type for the parameter
    var ptype *u8 = alloc(16);
    *(ptype) = '*';
    *(ptype + 1) = 'u';
    *(ptype + 2) = '8';
    *(ptype + 3) = 0;

    add_local(pname, param_len, offset, ptype);

    emit_str("    mov %rdi, ");
    emit_int(offset);
    emit_line("(%rbp)");

    // Generate body
    gen_block(reader_decl_body(reader_node));

    // Switch back to main buffer
    cg_in_func_body = 0;

    // Calculate aligned stack size
    var aligned_size i64 = cg_stack_size;
    if aligned_size < 16 {
        aligned_size = 16;
    }
    aligned_size = ((aligned_size + 15) / 16) * 16;

    // Emit prologue with actual stack size
    emit_line("    push %rbp");
    emit_line("    mov %rsp, %rbp");
    emit_str("    sub $");
    emit_int(aligned_size);
    emit_line(", %rsp");

    // Copy function body from temp buffer
    flush_func_body();

    emit_char(10);
}

// ============================================================
// Declaration code generation
// ============================================================

func gen_decl(decl *u8) void {
    if decl == nil {
        return;
    }

    var k i64 = node_kind(decl);

    if k == NODE_FUNC_DECL {
        gen_func(decl);
        return;
    }

    if k == NODE_VAR_DECL {
        // Global variable - already registered
        return;
    }

    if k == NODE_IMPORT {
        // Import declaration - file loading not yet implemented
        eprint("warning: import not yet implemented: ");
        eprint_buf(import_decl_path(decl), import_decl_path_len(decl));
        eprintln("");
        return;
    }

    if k == NODE_READER_DECL {
        // Generate reader as callable function (for standalone compilers)
        gen_reader_func(decl);
        return;
    }

    if k == NODE_INCLUDE_DECL {
        // Generate code for included declarations (inline to avoid forward decl)
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Skip if already included (idempotent includes)
        if map_has(cg_included_files, str_dup_n(path, path_len)) {
            return;
        }
        map_set(cg_included_files, str_dup_n(path, path_len), 1);

        // Check for circular include (same check as first pass)
        if include_stack_contains(path, path_len) {
            // Already detected in first pass, just skip silently
            return;
        }

        // Push onto include stack
        include_stack_push(path, path_len);

        // Re-read and re-parse file
        var buf *u8 = alloc(1048576);
        var n i64 = read_file_contents(path, path_len, buf, 1048576);
        if n < 0 {
            include_stack_pop();
            return;
        }

        var prog *u8 = parse_program_from_string(buf);
        if prog == nil {
            include_stack_pop();
            return;
        }

        // Generate code for included declarations
        var inc_decls *u8 = program_decls(prog);
        var inc_count i64 = program_decl_count(prog);
        var i i64 = 0;
        while i < inc_count {
            gen_decl(get_decl(inc_decls, i));
            i = i + 1;
        }

        include_stack_pop();
        return;
    }

    if k == NODE_READER_EXPR {
        // Reader macro at declaration level - expand and generate code
        var name *u8 = reader_expr_name(decl);
        var name_len i64 = reader_expr_name_len(decl);
        var content *u8 = reader_expr_content(decl);
        var content_len i64 = reader_expr_content_len(decl);

        // Look up the reader
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            // Error already reported in first pass
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = build_reader_cache_path(name, name_len);

        // Execute reader with content as input
        var output *u8 = alloc(131072);  // 128KB
        var n i64 = exec_capture(exe_path, content, content_len, output, 131072);

        if n <= 0 {
            // Error already reported in first pass
            return;
        }

        // Parse the output as S-expr AST (readers MUST output AST)
        var prog *u8 = parse_ast_from_string(output);
        if prog == nil {
            // Error already reported in first pass
            return;
        }

        // Generate code for each declaration
        var gen_decls *u8 = program_decls(prog);
        var gen_count i64 = program_decl_count(prog);
        i = 0;
        while i < gen_count {
            gen_decl(get_decl(gen_decls, i));
            i = i + 1;
        }
        return;
    }
}

// ============================================================
// Compile-time interpreter for macros
// ============================================================

// Interpreter state
// Macro parameter bindings: [name_ptr:8][name_len:8][value:8] = 24 bytes
// Max 16 params
var interp_bindings *u8 = nil;
var interp_binding_count i64 = 0;

// Return value from macro (set by return statement)
var interp_return_value i64 = 0;
var interp_has_returned i64 = 0;

func interp_init() void {
    if interp_bindings == nil {
        interp_bindings = alloc(384);  // 16 * 24
    }
    interp_binding_count = 0;
    interp_return_value = 0;
    interp_has_returned = 0;
}

func interp_add_binding(name *u8, name_len i64, value i64) void {
    var entry *u8 = interp_bindings + (interp_binding_count * 24);

    var np **u8 = entry;
    *np = name;

    var nl *i64 = entry + 8;
    *nl = name_len;

    var vp *i64 = entry + 16;
    *vp = value;

    interp_binding_count = interp_binding_count + 1;
}

func interp_find_binding(name *u8, name_len i64) i64 {
    var i i64 = interp_binding_count - 1;
    while i >= 0 {
        var entry *u8 = interp_bindings + (i * 24);

        var np **u8 = entry;
        var bname *u8 = *np;

        var nl *i64 = entry + 8;
        var blen i64 = *nl;

        if blen == name_len {
            if memcmp(bname, name, name_len) {
                var vp *i64 = entry + 16;
                return *vp;
            }
        }
        i = i - 1;
    }
    return 0;  // Not found
}

func interp_set_binding(name *u8, name_len i64, value i64) void {
    var i i64 = interp_binding_count - 1;
    while i >= 0 {
        var entry *u8 = interp_bindings + (i * 24);

        var np **u8 = entry;
        var bname *u8 = *np;

        var nl *i64 = entry + 8;
        var blen i64 = *nl;

        if blen == name_len {
            if memcmp(bname, name, name_len) {
                var vp *i64 = entry + 16;
                *vp = value;
                return;
            }
        }
        i = i - 1;
    }
}

// Expand unquotes in a quoted expression
// Walks the AST and replaces NODE_UNQUOTE_EXPR with the bound AST
func expand_quote(expr *u8) *u8 {
    if expr == nil {
        return nil;
    }

    var k i64 = node_kind(expr);

    // Unquote: look up binding and return the bound AST
    if k == NODE_UNQUOTE_EXPR {
        var name *u8 = unquote_expr_name(expr);
        var name_len i64 = unquote_expr_name_len(expr);
        return interp_find_binding(name, name_len);
    }

    // Unquote string: look up binding (string), create STRING_EXPR node
    // Note: STRING_EXPR values must include quotes for write_ascii_string
    if k == NODE_UNQUOTE_STRING_EXPR {
        var name *u8 = unquote_string_expr_name(expr);
        var name_len i64 = unquote_string_expr_name_len(expr);
        var str_ptr *u8 = interp_find_binding(name, name_len);
        var str_len i64 = strlen(str_ptr);

        // Wrap in quotes: allocate space for " + content + "
        var quoted *u8 = alloc(str_len + 3);  // quote + content + quote + null
        *quoted = 34;  // opening quote
        var i i64 = 0;
        while i < str_len {
            *(quoted + 1 + i) = *(str_ptr + i);
            i = i + 1;
        }
        *(quoted + 1 + str_len) = 34;  // closing quote
        *(quoted + 2 + str_len) = 0;   // null terminator

        var new_node *u8 = string_expr_alloc();
        string_expr_set_value(new_node, quoted);
        string_expr_set_value_len(new_node, str_len + 2);
        return new_node;
    }

    // Binary expression: expand both children
    if k == NODE_BINARY_EXPR {
        var left *u8 = expand_quote(binary_expr_left(expr));
        var right *u8 = expand_quote(binary_expr_right(expr));

        var new_node *u8 = binary_expr_alloc();
        binary_expr_set_op(new_node, binary_expr_op(expr));
        binary_expr_set_left(new_node, left);
        binary_expr_set_right(new_node, right);
        return new_node;
    }

    // Unary expression: expand child
    if k == NODE_UNARY_EXPR {
        var child *u8 = expand_quote(unary_expr_expr(expr));

        var new_node *u8 = unary_expr_alloc();
        unary_expr_set_op(new_node, unary_expr_op(expr));
        unary_expr_set_expr(new_node, child);
        return new_node;
    }

    // Group expression: expand child
    if k == NODE_GROUP_EXPR {
        var child *u8 = expand_quote(group_expr_expr(expr));

        var new_node *u8 = group_expr_alloc();
        group_expr_set_expr(new_node, child);
        return new_node;
    }

    // Call expression: expand function and args
    if k == NODE_CALL_EXPR {
        var func_node *u8 = expand_quote(call_expr_func(expr));
        var old_args *u8 = call_expr_args(expr);
        var num_args i64 = call_expr_arg_count(expr);

        var new_args *u8 = alloc(num_args * 8);
        var ai i64 = 0;
        while ai < num_args {
            var old_arg_ptr **u8 = old_args + (ai * 8);
            var expanded_arg *u8 = expand_quote(*old_arg_ptr);
            var new_arg_ptr **u8 = new_args + (ai * 8);
            *new_arg_ptr = expanded_arg;
            ai = ai + 1;
        }

        var new_node *u8 = call_expr_alloc();
        call_expr_set_func(new_node, func_node);
        call_expr_set_args(new_node, new_args);
        call_expr_set_arg_count(new_node, num_args);
        return new_node;
    }

    // Literals and identifiers: return as-is (they don't contain unquotes)
    return expr;
}

func interp_expr(expr *u8) i64 {
    if expr == nil {
        return 0;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        // Parse the number string
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        var val i64 = 0;
        var ii i64 = 0;
        while ii < len {
            val = val * 10 + (*(ptr + ii) - 48);
            ii = ii + 1;
        }
        return val;
    }

    if k == NODE_BOOL_EXPR {
        return bool_expr_value(expr);
    }

    if k == NODE_NIL_EXPR {
        return 0;
    }

    if k == NODE_STRING_EXPR {
        // Return pointer to string value (for use in macros)
        return string_expr_value(expr);
    }

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        return interp_find_binding(name, name_len);
    }

    if k == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);
        var left i64 = interp_expr(binary_expr_left(expr));
        var right i64 = interp_expr(binary_expr_right(expr));

        if op == TOKEN_PLUS { return left + right; }
        if op == TOKEN_MINUS { return left - right; }
        if op == TOKEN_STAR { return left * right; }
        if op == TOKEN_SLASH { return left / right; }
        if op == TOKEN_PERCENT { return left % right; }
        if op == TOKEN_EQEQ { if left == right { return 1; } return 0; }
        if op == TOKEN_BANGEQ { if left != right { return 1; } return 0; }
        if op == TOKEN_LT { if left < right { return 1; } return 0; }
        if op == TOKEN_GT { if left > right { return 1; } return 0; }
        if op == TOKEN_LTEQ { if left <= right { return 1; } return 0; }
        if op == TOKEN_GTEQ { if left >= right { return 1; } return 0; }
        if op == TOKEN_AMPAMP { if left != 0 && right != 0 { return 1; } return 0; }
        if op == TOKEN_PIPEPIPE { if left != 0 || right != 0 { return 1; } return 0; }
        if op == TOKEN_EQ {
            // Assignment
            var left_node *u8 = binary_expr_left(expr);
            if node_kind(left_node) == NODE_IDENT_EXPR {
                interp_set_binding(
                    ident_expr_name(left_node),
                    ident_expr_name_len(left_node),
                    right
                );
            }
            return right;
        }
        return 0;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        var val i64 = interp_expr(unary_expr_expr(expr));

        if op == TOKEN_MINUS { return 0 - val; }
        if op == TOKEN_BANG { if val == 0 { return 1; } return 0; }
        return 0;
    }

    if k == NODE_GROUP_EXPR {
        return interp_expr(group_expr_expr(expr));
    }

    // Quote expression: expand unquotes and return the resulting AST
    if k == NODE_QUOTE_EXPR {
        var inner *u8 = quote_expr_expr(expr);
        // Expand any unquotes inside the quote
        var expanded *u8 = expand_quote(inner);
        return expanded;
    }

    // Unquote expression: look up the binding and return the AST pointer
    if k == NODE_UNQUOTE_EXPR {
        var name *u8 = unquote_expr_name(expr);
        var name_len i64 = unquote_expr_name_len(expr);
        return interp_find_binding(name, name_len);
    }

    // Call expression: check for compile-time builtins
    if k == NODE_CALL_EXPR {
        var func_node *u8 = call_expr_func(expr);
        if node_kind(func_node) == NODE_IDENT_EXPR {
            var fname *u8 = ident_expr_name(func_node);
            var fname_len i64 = ident_expr_name_len(func_node);

            // Check for ast_to_string builtin
            if fname_len == 13 && memcmp(fname, "ast_to_string", 13) {
                var args *u8 = call_expr_args(expr);
                var arg_count i64 = call_expr_arg_count(expr);
                if arg_count >= 1 {
                    var arg_ptr **u8 = args;
                    var arg_ast *u8 = interp_expr(*arg_ptr);
                    return ast_to_string(arg_ast);
                }
                return 0;
            }

        }
        return 0;
    }

    // Let expression: bind name, evaluate body, restore scope
    if k == NODE_LET_EXPR {
        var name *u8 = let_expr_name(expr);
        var name_len i64 = let_expr_name_len(expr);
        var init_val i64 = interp_expr(let_expr_init(expr));

        // Save binding count for scope restoration
        var saved_binding_count i64 = interp_binding_count;

        // Add the binding
        interp_add_binding(name, name_len, init_val);

        // Evaluate body
        var result i64 = interp_expr(let_expr_body(expr));

        // Restore scope
        interp_binding_count = saved_binding_count;

        return result;
    }

    return 0;
}

func interp_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }
    if interp_has_returned {
        return;
    }

    var k i64 = node_kind(stmt);

    if k == NODE_EXPR_STMT {
        interp_expr(expr_stmt_expr(stmt));
        return;
    }

    // Explicit assignment statement (AST 2.0)
    if k == NODE_ASSIGN_STMT {
        var target *u8 = assign_stmt_target(stmt);
        var value i64 = interp_expr(assign_stmt_value(stmt));
        if node_kind(target) == NODE_IDENT_EXPR {
            interp_set_binding(
                ident_expr_name(target),
                ident_expr_name_len(target),
                value
            );
        }
        return;
    }

    if k == NODE_VAR_DECL {
        var name *u8 = var_decl_name(stmt);
        var name_len i64 = var_decl_name_len(stmt);
        var init *u8 = var_decl_init(stmt);
        var value i64 = 0;
        if init != nil {
            value = interp_expr(init);
        }
        interp_add_binding(name, name_len, value);
        return;
    }

    if k == NODE_RETURN_STMT {
        var value *u8 = return_stmt_value(stmt);
        if value != nil {
            interp_return_value = interp_expr(value);
        }
        interp_has_returned = 1;
        return;
    }

    if k == NODE_IF_STMT {
        var cond i64 = interp_expr(if_stmt_cond(stmt));
        if cond != 0 {
            interp_stmt(if_stmt_then(stmt));
        } else {
            var else_branch *u8 = if_stmt_else(stmt);
            if else_branch != nil {
                interp_stmt(else_branch);
            }
        }
        return;
    }

    if k == NODE_WHILE_STMT {
        while !interp_has_returned {
            var cond i64 = interp_expr(while_stmt_cond(stmt));
            if cond == 0 {
                return;
            }
            interp_stmt(while_stmt_body(stmt));
        }
        return;
    }

    if k == NODE_BLOCK_STMT {
        var stmts *u8 = block_stmt_stmts(stmt);
        var count i64 = block_stmt_count(stmt);
        var saved_count i64 = interp_binding_count;

        var i i64 = 0;
        while i < count && !interp_has_returned {
            var s **u8 = stmts + (i * 8);
            interp_stmt(*s);
            i = i + 1;
        }

        // Restore binding count (pop local vars)
        interp_binding_count = saved_count;
        return;
    }
}

// ============================================================
// ast_to_string - convert AST to string (compile-time builtin)
// ============================================================

// Buffer for building AST string
var ast_str_buf *u8 = nil;
var ast_str_pos i64 = 0;
var ast_str_cap i64 = 0;

func ast_str_init() void {
    if ast_str_buf == nil {
        ast_str_cap = 65536;
        ast_str_buf = alloc(ast_str_cap);
    }
    ast_str_pos = 0;
}

func ast_str_append_char(c u8) void {
    if ast_str_pos < ast_str_cap - 1 {
        *(ast_str_buf + ast_str_pos) = c;
        ast_str_pos = ast_str_pos + 1;
    }
}

func ast_str_append(s *u8, len i64) void {
    var i i64 = 0;
    while i < len {
        ast_str_append_char(*(s + i));
        i = i + 1;
    }
}

func ast_str_append_cstr(s *u8) void {
    while *s != 0 {
        ast_str_append_char(*s);
        s = s + 1;
    }
}

func ast_str_finish() *u8 {
    *(ast_str_buf + ast_str_pos) = 0;
    // Duplicate the string so caller owns it
    var result *u8 = str_dup(ast_str_buf);
    return result;
}

func ast_to_string_expr(expr *u8) void {
    if expr == nil {
        ast_str_append_cstr("nil");
        return;
    }

    var kind i64 = node_kind(expr);

    if kind == NODE_NUMBER_EXPR {
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        ast_str_append(ptr, len);
        return;
    }

    if kind == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        ast_str_append(name, name_len);
        return;
    }

    if kind == NODE_STRING_EXPR {
        // String value already includes quotes from lexer
        var s *u8 = string_expr_value(expr);
        var s_len i64 = string_expr_value_len(expr);
        ast_str_append(s, s_len);
        return;
    }

    if kind == NODE_BOOL_EXPR {
        if bool_expr_value(expr) != 0 {
            ast_str_append_cstr("true");
        } else {
            ast_str_append_cstr("false");
        }
        return;
    }

    if kind == NODE_NIL_EXPR {
        ast_str_append_cstr("nil");
        return;
    }

    if kind == NODE_GROUP_EXPR {
        ast_str_append_char(40);  // (
        ast_to_string_expr(group_expr_expr(expr));
        ast_str_append_char(41);  // )
        return;
    }

    if kind == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);
        // Assignment doesn't need parens
        if op == TOKEN_EQ {
            ast_to_string_expr(binary_expr_left(expr));
            ast_str_append_cstr(" = ");
            ast_to_string_expr(binary_expr_right(expr));
            return;
        }
        ast_str_append_char(40);  // (
        ast_to_string_expr(binary_expr_left(expr));
        ast_str_append_char(32);  // space
        if op == TOKEN_PLUS { ast_str_append_cstr("+"); }
        else if op == TOKEN_MINUS { ast_str_append_cstr("-"); }
        else if op == TOKEN_STAR { ast_str_append_cstr("*"); }
        else if op == TOKEN_SLASH { ast_str_append_cstr("/"); }
        else if op == TOKEN_PERCENT { ast_str_append_cstr("%"); }
        else if op == TOKEN_EQEQ { ast_str_append_cstr("=="); }
        else if op == TOKEN_BANGEQ { ast_str_append_cstr("!="); }
        else if op == TOKEN_LT { ast_str_append_cstr("<"); }
        else if op == TOKEN_GT { ast_str_append_cstr(">"); }
        else if op == TOKEN_LTEQ { ast_str_append_cstr("<="); }
        else if op == TOKEN_GTEQ { ast_str_append_cstr(">="); }
        else if op == TOKEN_AMPAMP { ast_str_append_cstr("&&"); }
        else if op == TOKEN_PIPEPIPE { ast_str_append_cstr("||"); }
        else if op == TOKEN_AMP { ast_str_append_cstr("&"); }
        else if op == TOKEN_PIPE { ast_str_append_cstr("|"); }
        else if op == TOKEN_CARET { ast_str_append_cstr("^"); }
        else if op == TOKEN_LTLT { ast_str_append_cstr("<<"); }
        else if op == TOKEN_GTGT { ast_str_append_cstr(">>"); }
        else { ast_str_append_cstr("?op?"); }
        ast_str_append_char(32);  // space
        ast_to_string_expr(binary_expr_right(expr));
        ast_str_append_char(41);  // )
        return;
    }

    if kind == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_MINUS { ast_str_append_cstr("-"); }
        else if op == TOKEN_BANG { ast_str_append_cstr("!"); }
        else if op == TOKEN_STAR { ast_str_append_cstr("*"); }
        else if op == TOKEN_AMP { ast_str_append_cstr("&"); }
        ast_to_string_expr(unary_expr_expr(expr));
        return;
    }

    if kind == NODE_CALL_EXPR {
        ast_to_string_expr(call_expr_func(expr));
        ast_str_append_char(40);  // (
        var args *u8 = call_expr_args(expr);
        var count i64 = call_expr_arg_count(expr);
        var i i64 = 0;
        while i < count {
            if i > 0 { ast_str_append_cstr(", "); }
            var arg_ptr **u8 = args + (i * 8);
            ast_to_string_expr(*arg_ptr);
            i = i + 1;
        }
        ast_str_append_char(41);  // )
        return;
    }

    if kind == NODE_FIELD_EXPR {
        ast_to_string_expr(field_expr_expr(expr));
        ast_str_append_char(46);  // .
        var fname *u8 = field_expr_field(expr);
        var fname_len i64 = field_expr_field_len(expr);
        ast_str_append(fname, fname_len);
        return;
    }

    ast_str_append_cstr("<expr>");
}

func ast_to_string_type(type_node *u8) void {
    if type_node == nil {
        ast_str_append_cstr("void");
        return;
    }
    var kind i64 = type_kind(type_node);
    if kind == TYPE_PTR {
        ast_str_append_char(42);  // *
        ast_to_string_type(ptr_type_elem(type_node));
        return;
    }
    // Primitive type - get the name
    var name *u8 = base_type_name(type_node);
    var name_len i64 = base_type_name_len(type_node);
    ast_str_append(name, name_len);
}

func ast_to_string_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }

    var kind i64 = node_kind(stmt);

    if kind == NODE_BLOCK_STMT {
        ast_str_append_cstr("{\n");
        var stmts *u8 = block_stmt_stmts(stmt);
        var count i64 = block_stmt_count(stmt);
        var i i64 = 0;
        while i < count {
            var s_ptr **u8 = stmts + (i * 8);
            ast_str_append_cstr("    ");
            ast_to_string_stmt(*s_ptr);
            i = i + 1;
        }
        ast_str_append_cstr("}\n");
        return;
    }

    if kind == NODE_VAR_DECL {
        ast_str_append_cstr("var ");
        var name *u8 = var_decl_name(stmt);
        var name_len i64 = var_decl_name_len(stmt);
        ast_str_append(name, name_len);
        ast_str_append_char(32);  // space
        ast_to_string_type(var_decl_type(stmt));
        var init *u8 = var_decl_init(stmt);
        if init != nil {
            ast_str_append_cstr(" = ");
            ast_to_string_expr(init);
        }
        ast_str_append_cstr(";\n");
        return;
    }

    if kind == NODE_RETURN_STMT {
        ast_str_append_cstr("return");
        var value *u8 = return_stmt_value(stmt);
        if value != nil {
            ast_str_append_char(32);
            ast_to_string_expr(value);
        }
        ast_str_append_cstr(";\n");
        return;
    }

    if kind == NODE_EXPR_STMT {
        ast_to_string_expr(expr_stmt_expr(stmt));
        ast_str_append_cstr(";\n");
        return;
    }

    // Explicit assignment statement (AST 2.0)
    if kind == NODE_ASSIGN_STMT {
        ast_to_string_expr(assign_stmt_target(stmt));
        ast_str_append_cstr(" = ");
        ast_to_string_expr(assign_stmt_value(stmt));
        ast_str_append_cstr(";\n");
        return;
    }

    if kind == NODE_IF_STMT {
        ast_str_append_cstr("if ");
        ast_to_string_expr(if_stmt_cond(stmt));
        ast_str_append_char(32);
        ast_to_string_stmt(if_stmt_then(stmt));
        var else_branch *u8 = if_stmt_else(stmt);
        if else_branch != nil {
            ast_str_append_cstr(" else ");
            ast_to_string_stmt(else_branch);
        }
        return;
    }

    if kind == NODE_WHILE_STMT {
        ast_str_append_cstr("while ");
        ast_to_string_expr(while_stmt_cond(stmt));
        ast_str_append_char(32);
        ast_to_string_stmt(while_stmt_body(stmt));
        return;
    }

    ast_str_append_cstr("/* unknown stmt */\n");
}

func ast_to_string_block(block *u8) *u8 {
    ast_str_init();
    ast_to_string_stmt(block);
    return ast_str_finish();
}

func ast_to_string(expr *u8) *u8 {
    ast_str_init();
    ast_to_string_expr(expr);
    return ast_str_finish();
}

// ============================================================
// AST-to-string for declarations (for reader includes)
// ============================================================

func ast_to_string_func_decl(decl *u8) void {
    ast_str_append_cstr("func ");
    var name *u8 = func_decl_name(decl);
    var name_len i64 = func_decl_name_len(decl);
    ast_str_append(name, name_len);
    ast_str_append_char(40);  // (

    // Parameters
    var params *u8 = func_decl_params(decl);
    var param_count i64 = func_decl_param_count(decl);
    var i i64 = 0;
    while i < param_count {
        if i > 0 { ast_str_append_cstr(", "); }
        var p *u8 = params + (i * 24);
        ast_str_append(param_name(p), param_name_len(p));
        ast_str_append_char(32);  // space
        ast_to_string_type(param_type(p));
        i = i + 1;
    }

    ast_str_append_cstr(") ");
    ast_to_string_type(func_decl_ret_type(decl));
    ast_str_append_char(32);  // space
    ast_to_string_stmt(func_decl_body(decl));
}

func ast_to_string_struct_decl(decl *u8) void {
    ast_str_append_cstr("struct ");
    ast_str_append(struct_decl_name(decl), struct_decl_name_len(decl));
    ast_str_append_cstr(" {\n");

    var fields *u8 = struct_decl_fields(decl);
    var field_count i64 = struct_decl_field_count(decl);
    var i i64 = 0;
    while i < field_count {
        var f *u8 = fields + (i * 24);
        ast_str_append_cstr("    ");
        ast_str_append(param_name(f), param_name_len(f));
        ast_str_append_char(32);  // space
        ast_to_string_type(param_type(f));
        ast_str_append_cstr(";\n");
        i = i + 1;
    }

    ast_str_append_cstr("}\n");
}

func ast_to_string_include_decl(decl *u8) void {
    ast_str_append_cstr("include \"");
    var path *u8 = include_decl_path(decl);
    var path_len i64 = include_decl_path_len(decl);
    ast_str_append(path, path_len);
    ast_str_append_cstr("\"\n");
}

// ============================================================
// AST printing (for --expand-macros debug flag)
// ============================================================

func print_expr_ast(expr *u8) void {
    if expr == nil {
        eprint("nil");
        return;
    }

    var kind i64 = node_kind(expr);

    if kind == NODE_NUMBER_EXPR {
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        eprint_buf(ptr, len);
        return;
    }

    if kind == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        eprint_buf(name, name_len);
        return;
    }

    if kind == NODE_STRING_EXPR {
        eprint("\"");
        var s *u8 = string_expr_value(expr);
        var s_len i64 = string_expr_value_len(expr);
        eprint_buf(s, s_len);
        eprint("\"");
        return;
    }

    if kind == NODE_BOOL_EXPR {
        if bool_expr_value(expr) != 0 {
            eprint("true");
        } else {
            eprint("false");
        }
        return;
    }

    if kind == NODE_NIL_EXPR {
        eprint("nil");
        return;
    }

    if kind == NODE_GROUP_EXPR {
        eprint("(");
        print_expr_ast(group_expr_expr(expr));
        eprint(")");
        return;
    }

    if kind == NODE_BINARY_EXPR {
        eprint("(");
        print_expr_ast(binary_expr_left(expr));
        eprint(" ");
        var op i64 = binary_expr_op(expr);
        if op == TOKEN_PLUS { eprint("+"); }
        else if op == TOKEN_MINUS { eprint("-"); }
        else if op == TOKEN_STAR { eprint("*"); }
        else if op == TOKEN_SLASH { eprint("/"); }
        else if op == TOKEN_PERCENT { eprint("%"); }
        else if op == TOKEN_EQEQ { eprint("=="); }
        else if op == TOKEN_BANGEQ { eprint("!="); }
        else if op == TOKEN_LT { eprint("<"); }
        else if op == TOKEN_GT { eprint(">"); }
        else if op == TOKEN_LTEQ { eprint("<="); }
        else if op == TOKEN_GTEQ { eprint(">="); }
        else if op == TOKEN_AMPAMP { eprint("&&"); }
        else if op == TOKEN_PIPEPIPE { eprint("||"); }
        else if op == TOKEN_AMP { eprint("&"); }
        else if op == TOKEN_PIPE { eprint("|"); }
        else if op == TOKEN_CARET { eprint("^"); }
        else if op == TOKEN_LTLT { eprint("<<"); }
        else if op == TOKEN_GTGT { eprint(">>"); }
        else { eprint("?op?"); }
        eprint(" ");
        print_expr_ast(binary_expr_right(expr));
        eprint(")");
        return;
    }

    if kind == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_MINUS { eprint("-"); }
        else if op == TOKEN_BANG { eprint("!"); }
        else if op == TOKEN_STAR { eprint("*"); }
        else if op == TOKEN_AMP { eprint("&"); }
        print_expr_ast(unary_expr_expr(expr));
        return;
    }

    if kind == NODE_CALL_EXPR {
        print_expr_ast(call_expr_func(expr));
        eprint("(");
        var args *u8 = call_expr_args(expr);
        var count i64 = call_expr_arg_count(expr);
        var i i64 = 0;
        while i < count {
            if i > 0 { eprint(", "); }
            var arg_ptr **u8 = args + (i * 8);
            print_expr_ast(*arg_ptr);
            i = i + 1;
        }
        eprint(")");
        return;
    }

    if kind == NODE_INDEX_EXPR {
        eprint("<index-expr>");
        return;
    }

    if kind == NODE_FIELD_EXPR {
        print_expr_ast(field_expr_expr(expr));
        eprint(".");
        var fname *u8 = field_expr_field(expr);
        var fname_len i64 = field_expr_field_len(expr);
        eprint_buf(fname, fname_len);
        return;
    }

    eprint("<unknown-expr>");
}

// Call a macro with arguments (AST nodes)
// Returns the resulting AST
func interp_call_macro(macro_decl *u8, args *u8, arg_count i64) *u8 {
    interp_init();

    // Bind parameters to arguments
    var macro_params *u8 = macro_decl_params(macro_decl);
    var num_params i64 = macro_decl_param_count(macro_decl);

    var i i64 = 0;
    while i < num_params && i < arg_count {
        var p *u8 = macro_params + (i * 24);
        var pname *u8 = param_name(p);
        var pname_len i64 = param_name_len(p);

        // Get the argument AST pointer
        var arg_ptr **u8 = args + (i * 8);
        var arg *u8 = *arg_ptr;

        // Bind parameter to argument AST (as pointer value)
        interp_add_binding(pname, pname_len, arg);
        i = i + 1;
    }

    // Execute macro body
    var macro_body *u8 = macro_decl_body(macro_decl);
    interp_stmt(macro_body);

    // Return the result (should be an AST pointer)
    return interp_return_value;
}

// ============================================================
// Process execution for V2 reader macros
// ============================================================

// Execute a program with input, capture stdout
// Returns: bytes written to output buffer (-1 on error)
func exec_capture(program *u8, input *u8, input_len i64, output *u8, output_cap i64) i64 {
    // Create pipes - pipe() writes two i32 file descriptors
    var stdin_pipe *u8 = alloc(8);
    var stdout_pipe *u8 = alloc(8);

    if syscall(22, stdin_pipe) < 0 {
        return 0 - 1;
    }
    if syscall(22, stdout_pipe) < 0 {
        return 0 - 1;
    }

    // Read fds as i32 (pipe returns int, not int64)
    var p1 *i32 = stdin_pipe;
    var p2 *i32 = stdin_pipe + 4;
    var p3 *i32 = stdout_pipe;
    var p4 *i32 = stdout_pipe + 4;
    var stdin_read i64 = *p1;
    var stdin_write i64 = *p2;
    var stdout_read i64 = *p3;
    var stdout_write i64 = *p4;

    // syscall 57 = fork
    var pid i64 = syscall(57);

    if pid < 0 {
        return 0 - 1;
    }

    if pid == 0 {
        // Child process
        // Redirect stdin: dup2(stdin_read, 0)
        syscall(33, stdin_read, 0);
        // Redirect stdout: dup2(stdout_write, 1)
        syscall(33, stdout_write, 1);
        // Close all pipe fds
        syscall(3, stdin_read);
        syscall(3, stdin_write);
        syscall(3, stdout_read);
        syscall(3, stdout_write);

        // Build argv: [program, NULL]
        var argv *u8 = alloc(16);
        var ap **u8 = argv;
        *ap = program;
        var ap2 **u8 = argv + 8;
        *ap2 = nil;

        // Build envp: [NULL]
        var envp *u8 = alloc(8);
        var ep **u8 = envp;
        *ep = nil;

        // syscall 59 = execve
        syscall(59, program, argv, envp);
        // If execve fails, exit
        syscall(60, 127);
    }

    // Parent process
    // Close child's ends of pipes
    syscall(3, stdin_read);
    syscall(3, stdout_write);

    // Write input to child's stdin, then close
    if input_len > 0 {
        syscall(1, stdin_write, input, input_len);
    }
    syscall(3, stdin_write);

    // Read output from child's stdout
    var total i64 = 0;
    var n i64 = syscall(0, stdout_read, output, output_cap - 1);
    while n > 0 {
        total = total + n;
        if total >= output_cap - 1 {
            n = 0;
        } else {
            n = syscall(0, stdout_read, output + total, output_cap - 1 - total);
        }
    }
    syscall(3, stdout_read);

    // Null-terminate output
    *(output + total) = 0;

    // Wait for child
    var status *i64 = alloc(8);
    syscall(61, pid, status, 0, 0);

    return total;
}

func interp_call_reader(reader_decl *u8, content *u8, content_len i64) *u8 {
    interp_init();

    // Bind the text content to the reader's parameter
    var param_name *u8 = reader_decl_param_name(reader_decl);
    var param_len i64 = reader_decl_param_len(reader_decl);

    // The parameter is a pointer to the raw text content
    interp_add_binding(param_name, param_len, content);

    // Also bind the content length (param_name + "_len")
    // For now, readers just get the pointer - they can scan for delimiters

    // Execute reader body
    var reader_body *u8 = reader_decl_body(reader_decl);
    interp_stmt(reader_body);

    // Return the result (should be an AST pointer)
    return interp_return_value;
}

// ============================================================
// Program code generation
// ============================================================

func generate(prog *u8, out_path *u8) void {
    codegen_init();

    var decls *u8 = program_decls(prog);
    var decl_count i64 = program_decl_count(prog);

    // Store for interpreter function calls
    cg_decls = decls;
    cg_decl_count = decl_count;

    // Set current file context (for reader compilation)
    cg_current_file_decls = decls;
    cg_current_file_decl_count = decl_count;

    // First pass: collect structs, macros, readers, globals, and process includes
    var i i64 = 0;
    while i < decl_count {
        process_decl_first_pass(get_decl(decls, i));
        i = i + 1;
    }

    // Reset included files map for second pass
    cg_included_files = map_new();

    // Second pass: generate code (into buffer)
    i = 0;
    while i < decl_count {
        gen_decl(get_decl(decls, i));
        i = i + 1;
    }

    // Third pass: generate collected lambdas
    gen_all_lambdas();

    // Open output file (O_WRONLY | O_CREAT | O_TRUNC = 577, mode 0644 = 420)
    cg_out_fd = syscall(2, out_path, 577, 420);
    if cg_out_fd < 0 {
        eprintln("Error: cannot open output file");
        return;
    }

    // Data section
    out_line(".section .data");

    // String literals
    i = 0;
    while i < cg_string_count {
        out_str(".str");
        out_int(i);
        out_line(":");
        out_str("    .ascii ");
        write_ascii_string(string_get_ptr(i), string_get_len(i));
        out_char(10);
        i = i + 1;
    }

    // Global variables
    i = 0;
    while i < cg_global_count {
        out_n(global_get_name(i), global_get_name_len(i));
        out_line(":");
        out_str("    .quad ");
        out_int(eval_constant(global_get_init(i)));
        out_char(10);
        i = i + 1;
    }

    // Effect handler runtime globals
    if cg_effect_count > 0 {
        out_line("__handler_set:");
        out_line("    .quad 0");
        out_line("__handler_rbp:");
        out_line("    .quad 0");
        out_line("__handler_rsp:");
        out_line("    .quad 0");
        out_line("__handler_addr:");
        out_line("    .quad 0");
        out_line("__effect_value:");
        out_line("    .quad 0");
        out_line("__continuation_ptr:");
        out_line("    .quad 0");
        out_line("__effect_name_ptr:");
        out_line("    .quad 0");
        out_line("__effect_name_len:");
        out_line("    .quad 0");
    }

    // Text section
    out_char(10);
    out_line(".section .text");
    out_line(".globl _start");
    out_line("_start:");
    // Get argc and argv from stack
    out_line("    mov (%rsp), %rdi");     // argc
    out_line("    lea 8(%rsp), %rsi");    // argv
    out_line("    call ___main");
    out_line("    mov %rax, %rdi");
    out_line("    mov $60, %rax");
    out_line("    syscall");
    out_char(10);

    // Write code buffer
    file_write(cg_out_fd, cg_code_buf, cg_code_len);

    file_close(cg_out_fd);
}

func write_ascii_string(ptr *u8, len i64) void {
    // Skip quotes in original string
    var start *u8 = ptr + 1;
    var end i64 = len - 2;

    out_char(34);  // opening quote

    var i i64 = 0;
    while i < end {
        var c u8 = *(start + i);

        if c == 92 && i + 1 < end {  // backslash escape
            i = i + 1;
            var next u8 = *(start + i);
            if next == 110 {  // 'n'
                out_str("\\012");
            } else if next == 116 {  // 't'
                out_str("\\011");
            } else if next == 114 {  // 'r'
                out_str("\\015");
            } else if next == 92 {  // '\'
                out_str("\\\\");
            } else if next == 34 {  // '"'
                out_str("\\\"");
            } else if next == 48 {  // '0'
                out_str("\\000");
            } else {
                out_char(next);
            }
        } else if c >= 32 && c < 127 && c != 34 && c != 92 {
            out_char(c);
        } else {
            // Octal escape
            out_char(92);  // '\'
            out_char(48 + (c / 64));
            out_char(48 + ((c / 8) % 8));
            out_char(48 + (c % 8));
        }
        i = i + 1;
    }

    out_str("\\000");  // null terminator
    out_char(34);  // closing quote
}
