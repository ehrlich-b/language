// src/codegen.lang - x86-64 code generator for self-hosting compiler
// Emits GNU as compatible assembly

// ============================================================
// Codegen state (global)
// ============================================================

var cg_out_fd i64 = 0;           // output file descriptor
var cg_label_num i64 = 0;        // for generating unique labels

// Locals array: each entry is [name_ptr:8][name_len:8][offset:8][type_ptr:8] = 32 bytes
// Max 256 locals
var cg_locals *u8 = nil;
var cg_local_count i64 = 0;
var cg_stack_size i64 = 0;

// Globals array: each entry is [name_ptr:8][name_len:8][type_ptr:8][init_ptr:8] = 32 bytes
// Max 1000 globals
var cg_globals *u8 = nil;
var cg_global_count i64 = 0;

// Strings array: each entry is [str_ptr:8][str_len:8] = 16 bytes
// Max 1000 strings
var cg_strings *u8 = nil;
var cg_string_count i64 = 0;

// Output buffer for code (collect code first, emit strings/globals first)
var cg_code_buf *u8 = nil;
var cg_code_len i64 = 0;
var cg_code_cap i64 = 0;

// Struct registry: simple array of struct decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 structs
var cg_structs *u8 = nil;
var cg_struct_count i64 = 0;

// Macro registry: simple array of macro decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 macros
var cg_macros *u8 = nil;
var cg_macro_count i64 = 0;

// Reader registry: simple array of reader decls
// Each entry: [name_ptr:8][name_len:8][decl_ptr:8] = 24 bytes
// Max 100 readers
var cg_readers *u8 = nil;
var cg_reader_count i64 = 0;

// Include stack for loop detection
// Each entry: [path_ptr:8][path_len:8] = 16 bytes
// Max 32 nested includes
var cg_include_stack *u8 = nil;
var cg_include_count i64 = 0;

// Debug flag: print macro expansions
var cg_expand_macros i64 = 0;

// Program declarations (for interpreter function calls)
var cg_decls *u8 = nil;
var cg_decl_count i64 = 0;

// Workaround for codegen bug - temp storage
var cg_temp_struct_decl *u8 = nil;

// Current file context (for reader compilation)
var cg_current_file_decls *u8 = nil;
var cg_current_file_decl_count i64 = 0;
var cg_in_scoped_context i64 = 0;  // 1 when processing included files

// ============================================================
// Initialization
// ============================================================

func codegen_init() void {
    cg_locals = alloc(8192);    // 256 * 32
    cg_local_count = 0;
    cg_stack_size = 0;

    cg_globals = alloc(32000);  // 1000 * 32
    cg_global_count = 0;

    cg_strings = alloc(16000);  // 1000 * 16
    cg_string_count = 0;

    cg_code_buf = alloc(1048576);  // 1MB code buffer
    cg_code_len = 0;
    cg_code_cap = 1048576;

    cg_label_num = 0;

    cg_structs = alloc(2400);  // 100 * 24
    cg_struct_count = 0;

    cg_macros = alloc(2400);   // 100 * 24
    cg_macro_count = 0;

    cg_readers = alloc(2400);  // 100 * 24
    cg_reader_count = 0;

    cg_include_stack = alloc(512);  // 32 * 16
    cg_include_count = 0;
}

// ============================================================
// Local variable accessors
// ============================================================

func local_get_name(index i64) *u8 {
    var p **u8 = cg_locals + (index * 32);
    return *p;
}

func local_set_name(index i64, ptr *u8) void {
    var p **u8 = cg_locals + (index * 32);
    *p = ptr;
}

func local_get_name_len(index i64) i64 {
    var p *i64 = cg_locals + (index * 32) + 8;
    return *p;
}

func local_set_name_len(index i64, len i64) void {
    var p *i64 = cg_locals + (index * 32) + 8;
    *p = len;
}

func local_get_offset(index i64) i64 {
    var p *i64 = cg_locals + (index * 32) + 16;
    return *p;
}

func local_set_offset(index i64, off i64) void {
    var p *i64 = cg_locals + (index * 32) + 16;
    *p = off;
}

func local_get_type(index i64) *u8 {
    var p **u8 = cg_locals + (index * 32) + 24;
    return *p;
}

func local_set_type(index i64, t *u8) void {
    var p **u8 = cg_locals + (index * 32) + 24;
    *p = t;
}

func find_local(name *u8, name_len i64) i64 {
    // Search from end (most recent) to find correct variable in shadowing cases
    var i i64 = cg_local_count - 1;
    while i >= 0 {
        if local_get_name_len(i) == name_len {
            if memcmp(local_get_name(i), name, name_len) {
                return i;
            }
        }
        i = i - 1;
    }
    return 0 - 1;  // -1 not found
}

func add_local(name *u8, name_len i64, offset i64, t *u8) void {
    local_set_name(cg_local_count, name);
    local_set_name_len(cg_local_count, name_len);
    local_set_offset(cg_local_count, offset);
    local_set_type(cg_local_count, t);
    cg_local_count = cg_local_count + 1;
}

// ============================================================
// Global variable accessors
// ============================================================

func global_get_name(index i64) *u8 {
    var p **u8 = cg_globals + (index * 32);
    return *p;
}

func global_set_name(index i64, ptr *u8) void {
    var p **u8 = cg_globals + (index * 32);
    *p = ptr;
}

func global_get_name_len(index i64) i64 {
    var p *i64 = cg_globals + (index * 32) + 8;
    return *p;
}

func global_set_name_len(index i64, len i64) void {
    var p *i64 = cg_globals + (index * 32) + 8;
    *p = len;
}

func global_get_type(index i64) *u8 {
    var p **u8 = cg_globals + (index * 32) + 16;
    return *p;
}

func global_set_type(index i64, t *u8) void {
    var p **u8 = cg_globals + (index * 32) + 16;
    *p = t;
}

func global_get_init(index i64) *u8 {
    var p **u8 = cg_globals + (index * 32) + 24;
    return *p;
}

func global_set_init(index i64, init *u8) void {
    var p **u8 = cg_globals + (index * 32) + 24;
    *p = init;
}

func find_global(name *u8, name_len i64) i64 {
    var i i64 = 0;
    while i < cg_global_count {
        if global_get_name_len(i) == name_len {
            if memcmp(global_get_name(i), name, name_len) {
                return i;
            }
        }
        i = i + 1;
    }
    return 0 - 1;  // -1 not found
}

func add_global(name *u8, name_len i64, t *u8, init *u8) void {
    global_set_name(cg_global_count, name);
    global_set_name_len(cg_global_count, name_len);
    global_set_type(cg_global_count, t);
    global_set_init(cg_global_count, init);
    cg_global_count = cg_global_count + 1;
}

// ============================================================
// Struct registry helpers
// ============================================================

func add_struct(decl *u8) void {
    var name *u8 = struct_decl_name(decl);
    var name_len i64 = struct_decl_name_len(decl);

    var entry *u8 = cg_structs + (cg_struct_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_struct_count = cg_struct_count + 1;
}

func find_struct(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_struct_count {
        var entry *u8 = cg_structs + (i * 24);

        var np **u8 = entry;
        var sname *u8 = *np;

        var nl *i64 = entry + 8;
        var slen i64 = *nl;

        if slen == name_len {
            if memcmp(sname, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Macro registry
// ============================================================

func add_macro(decl *u8) void {
    var name *u8 = macro_decl_name(decl);
    var name_len i64 = macro_decl_name_len(decl);

    var entry *u8 = cg_macros + (cg_macro_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_macro_count = cg_macro_count + 1;
}

func find_macro(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_macro_count {
        var entry *u8 = cg_macros + (i * 24);

        var np **u8 = entry;
        var mname *u8 = *np;

        var nl *i64 = entry + 8;
        var mlen i64 = *nl;

        if mlen == name_len {
            if memcmp(mname, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Reader registry functions
// ============================================================

// Execute a program, wait for completion (no stdin/stdout capture)
func exec_run(program *u8, arg1 *u8, arg2 *u8, arg3 *u8, arg4 *u8, arg5 *u8) i64 {
    var argv *u8 = alloc(56);  // 7 pointers
    var a0 **u8 = argv;      *a0 = program;
    var a1 **u8 = argv + 8;  *a1 = arg1;
    var a2 **u8 = argv + 16; *a2 = arg2;
    var a3 **u8 = argv + 24; *a3 = arg3;
    var a4 **u8 = argv + 32; *a4 = arg4;
    var a5 **u8 = argv + 40; *a5 = arg5;
    var a6 **u8 = argv + 48; *a6 = nil;

    var envp *u8 = alloc(8);
    var e0 **u8 = envp;
    *e0 = nil;

    var pid i64 = syscall(57);
    if pid == 0 {
        syscall(59, program, argv, envp);
        syscall(60, 127);
    }

    var status *i64 = alloc(8);
    syscall(61, pid, status, 0, 0);
    return (*status / 256) % 256;  // extract exit code
}

// Generate and compile reader to executable
func compile_reader_to_executable(decl *u8) void {
    var name *u8 = reader_decl_name(decl);
    var name_len i64 = reader_decl_name_len(decl);
    var param_name *u8 = reader_decl_param_name(decl);
    var param_len i64 = reader_decl_param_len(decl);
    var body *u8 = reader_decl_body(decl);

    // Create .lang-cache/readers/ directories
    syscall(83, ".lang-cache", 493);  // mkdir
    syscall(83, ".lang-cache/readers", 493);

    // Build paths
    var base_path *u8 = alloc(256);
    var i i64 = 0;
    var src *u8 = ".lang-cache/readers/";
    while *src != 0 {
        *(base_path + i) = *src;
        src = src + 1;
        i = i + 1;
    }
    var j i64 = 0;
    while j < name_len {
        *(base_path + i) = *(name + j);
        i = i + 1;
        j = j + 1;
    }
    *(base_path + i) = 0;

    var src_path *u8 = str_concat(base_path, ".lang");
    var asm_path *u8 = str_concat(base_path, ".s");
    var obj_path *u8 = str_concat(base_path, ".o");
    var exe_path *u8 = str_dup(base_path);

    // Build wrapper source with sibling declarations from current file
    var wrapper *u8 = alloc(262144);  // 256KB for larger reader files
    var wp *u8 = wrapper;

    // Serialize sibling declarations from the reader's immediate context.
    // We only include declarations that are BETWEEN the file start and
    // the reader declaration, to avoid including stdlib functions.
    // For now, we only serialize include statements (user must explicitly
    // include helper files), and we find the reader in the decl list to
    // only include declarations that come BEFORE it in the same file.

    ast_str_init();

    // Find the reader's position in the declaration list
    var reader_pos i64 = -1;
    i = 0;
    while i < cg_current_file_decl_count {
        var sibling *u8 = get_decl(cg_current_file_decls, i);
        if sibling == decl {
            reader_pos = i;
        }
        i = i + 1;
    }

    // Only emit sibling declarations if we're in a scoped context (included file)
    // For command-line files, stdlib is already included, so we skip sibling inclusion
    if cg_in_scoped_context == 1 && reader_pos > 0 {
        // Emit include statements before the reader
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_INCLUDE_DECL {
                ast_to_string_include_decl(sibling);
            }
            i = i + 1;
        }

        // Emit reader macro expansions (e.g., #parser{} generates code)
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_READER_EXPR {
                // Get reader name and content
                var rname *u8 = reader_expr_name(sibling);
                var rname_len i64 = reader_expr_name_len(sibling);
                var rcontent *u8 = reader_expr_content(sibling);
                var rcontent_len i64 = reader_expr_content_len(sibling);

                // Build executable path
                var rexe_path *u8 = alloc(256);
                var ri i64 = 0;
                var rbase *u8 = ".lang-cache/readers/";
                while *rbase != 0 { *(rexe_path + ri) = *rbase; ri = ri + 1; rbase = rbase + 1; }
                var rj i64 = 0;
                while rj < rname_len { *(rexe_path + ri) = *(rname + rj); ri = ri + 1; rj = rj + 1; }
                *(rexe_path + ri) = 0;

                // Execute reader and get output
                var rout *u8 = alloc(131072);
                var rn i64 = exec_capture(rexe_path, rcontent, rcontent_len, rout, 131072);
                if rn > 0 {
                    // Append reader output directly (it's lang source code)
                    ast_str_append(rout, rn);
                    ast_str_append_char(10);
                }
            }
            i = i + 1;
        }

        // Emit struct declarations before the reader
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_STRUCT_DECL {
                ast_to_string_struct_decl(sibling);
            }
            i = i + 1;
        }

        // Emit function declarations before the reader (skip main)
        i = 0;
        while i < reader_pos {
            var sibling *u8 = get_decl(cg_current_file_decls, i);
            var k i64 = node_kind(sibling);
            if k == NODE_FUNC_DECL {
                // Skip main() to avoid conflict with wrapper main
                var fname *u8 = func_decl_name(sibling);
                var flen i64 = func_decl_name_len(sibling);
                if flen != 4 || !memcmp(fname, "main", 4) {
                    ast_to_string_func_decl(sibling);
                }
            }
            i = i + 1;
        }
    }

    var siblings_src *u8 = ast_str_finish();

    // Copy sibling declarations to wrapper
    while *siblings_src != 0 { *wp = *siblings_src; wp = wp + 1; siblings_src = siblings_src + 1; }

    // Generate reader body source
    var body_src *u8 = ast_to_string_block(body);

    // func <name>(<param> *u8) *u8
    var fn *u8 = "func ";
    while *fn != 0 { *wp = *fn; wp = wp + 1; fn = fn + 1; }
    j = 0;
    while j < name_len { *wp = *(name + j); wp = wp + 1; j = j + 1; }
    *wp = 40; wp = wp + 1;  // (
    j = 0;
    while j < param_len { *wp = *(param_name + j); wp = wp + 1; j = j + 1; }
    var sig *u8 = " *u8) *u8 ";
    while *sig != 0 { *wp = *sig; wp = wp + 1; sig = sig + 1; }
    while *body_src != 0 { *wp = *body_src; wp = wp + 1; body_src = body_src + 1; }
    *wp = 10; wp = wp + 1;  // newline

    // main() wrapper - use the reader's parameter name
    var main_src *u8 = "func main() i64 {\n    var buf *u8 = alloc(65536);\n    var n i64 = file_read(0, buf, 65536);\n    *(buf + n) = 0;\n    var result *u8 = ";
    while *main_src != 0 { *wp = *main_src; wp = wp + 1; main_src = main_src + 1; }
    j = 0;
    while j < name_len { *wp = *(name + j); wp = wp + 1; j = j + 1; }
    var main_end *u8 = "(buf);\n    print(result);\n    return 0;\n}\n";
    while *main_end != 0 { *wp = *main_end; wp = wp + 1; main_end = main_end + 1; }
    *wp = 0;

    // Write wrapper source to file
    var fd i64 = syscall(2, src_path, 577, 420);  // open with O_CREAT|O_TRUNC|O_WRONLY
    var wlen i64 = 0;
    var ws *u8 = wrapper;
    while *ws != 0 { wlen = wlen + 1; ws = ws + 1; }
    syscall(1, fd, wrapper, wlen);
    syscall(3, fd);

    // Compile: ./out/lang std/core.lang <src> -o <asm>
    // Reader source files should include their own dependencies
    exec_run("./out/lang", "std/core.lang", src_path, "-o", asm_path, nil);

    // Assemble: as <asm> -o <obj>
    exec_run("/usr/bin/as", asm_path, "-o", obj_path, nil, nil);

    // Link: ld <obj> -o <exe>
    exec_run("/usr/bin/ld", obj_path, "-o", exe_path, nil, nil);
}

func add_reader(decl *u8) void {
    var name *u8 = reader_decl_name(decl);
    var name_len i64 = reader_decl_name_len(decl);

    var entry *u8 = cg_readers + (cg_reader_count * 24);

    // Store name_ptr
    var np **u8 = entry;
    *np = name;

    // Store name_len
    var nl *i64 = entry + 8;
    *nl = name_len;

    // Store decl_ptr
    var dp **u8 = entry + 16;
    *dp = decl;

    cg_reader_count = cg_reader_count + 1;

    // V2: Compile reader to executable
    compile_reader_to_executable(decl);
}

func find_reader(name *u8, name_len i64) *u8 {
    // First check registered readers
    var i i64 = 0;
    while i < cg_reader_count {
        var entry *u8 = cg_readers + (i * 24);

        var np **u8 = entry;
        var rname *u8 = *np;

        var nl *i64 = entry + 8;
        var rlen i64 = *nl;

        if rlen == name_len {
            if memcmp(rname, name, name_len) {
                var dp **u8 = entry + 16;
                return *dp;
            }
        }
        i = i + 1;
    }

    // Fall back to checking for pre-compiled reader in .lang-cache/readers/
    var exe_path *u8 = alloc(256);
    i = 0;
    var base *u8 = ".lang-cache/readers/";
    while *base != 0 { *(exe_path + i) = *base; i = i + 1; base = base + 1; }
    var j i64 = 0;
    while j < name_len { *(exe_path + i) = *(name + j); i = i + 1; j = j + 1; }
    *(exe_path + i) = 0;

    // Check if file exists by trying to open it
    var fd i64 = file_open(exe_path, 0);  // O_RDONLY = 0
    if fd >= 0 {
        file_close(fd);
        // Return non-nil sentinel to indicate reader found
        return exe_path;
    }

    return nil;
}

// Look up a function by name in program declarations
func find_func(name *u8, name_len i64) *u8 {
    var i i64 = 0;
    while i < cg_decl_count {
        var decl *u8 = get_decl(cg_decls, i);
        if node_kind(decl) == NODE_FUNC_DECL {
            var fname *u8 = func_decl_name(decl);
            var flen i64 = func_decl_name_len(decl);
            if flen == name_len && memcmp(fname, name, name_len) {
                return decl;
            }
        }
        i = i + 1;
    }
    return nil;
}

// ============================================================
// Include stack operations (for loop detection)
// ============================================================

func include_stack_push(path *u8, path_len i64) void {
    var entry *u8 = cg_include_stack + (cg_include_count * 16);
    var pp **u8 = entry;
    *pp = path;
    var pl *i64 = entry + 8;
    *pl = path_len;
    cg_include_count = cg_include_count + 1;
}

func include_stack_pop() void {
    if cg_include_count > 0 {
        cg_include_count = cg_include_count - 1;
    }
}

func include_stack_contains(path *u8, path_len i64) bool {
    var i i64 = 0;
    while i < cg_include_count {
        var entry *u8 = cg_include_stack + (i * 16);
        var pp **u8 = entry;
        var stack_path *u8 = *pp;
        var pl *i64 = entry + 8;
        var stack_len i64 = *pl;

        if stack_len == path_len && memcmp(stack_path, path, path_len) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Read a file into a buffer (returns length, or -1 on error)
func read_file_contents(path *u8, path_len i64, buf *u8, buf_cap i64) i64 {
    // Null-terminate path
    var path_z *u8 = alloc(path_len + 1);
    var j i64 = 0;
    while j < path_len {
        *(path_z + j) = *(path + j);
        j = j + 1;
    }
    *(path_z + path_len) = 0;

    // Open file (O_RDONLY = 0)
    var fd i64 = syscall(2, path_z, 0, 0);
    if fd < 0 {
        return -1;
    }

    // Read contents
    var n i64 = syscall(0, fd, buf, buf_cap);
    syscall(3, fd);  // close

    if n >= 0 {
        *(buf + n) = 0;  // null-terminate
    }
    return n;
}

// Process a single declaration (first pass) - handles includes recursively
// Note: This function must be defined before process_include_first_pass uses it
func process_decl_first_pass(decl *u8) void {
    var k i64 = node_kind(decl);
    if k == NODE_STRUCT_DECL {
        add_struct(decl);
        return;
    }
    if k == NODE_MACRO_DECL {
        add_macro(decl);
        return;
    }
    if k == NODE_READER_DECL {
        add_reader(decl);
        return;
    }
    // Reader macro at declaration level - expand to declarations
    if k == NODE_READER_EXPR {
        var name *u8 = reader_expr_name(decl);
        var name_len i64 = reader_expr_name_len(decl);
        var content *u8 = reader_expr_content(decl);
        var content_len i64 = reader_expr_content_len(decl);

        // Look up the reader
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            eprint("error: reader macro '");
            eprint_buf(name, name_len);
            eprintln("' not found");
            cg_had_error = 1;
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = alloc(256);
        var i i64 = 0;
        var base *u8 = ".lang-cache/readers/";
        while *base != 0 { *(exe_path + i) = *base; i = i + 1; base = base + 1; }
        var j i64 = 0;
        while j < name_len { *(exe_path + i) = *(name + j); i = i + 1; j = j + 1; }
        *(exe_path + i) = 0;

        // Execute reader with content as input
        var output *u8 = alloc(131072);  // 128KB
        var n i64 = exec_capture(exe_path, content, content_len, output, 131072);

        if n <= 0 {
            eprint("error: reader '");
            eprint_buf(name, name_len);
            eprintln("' returned no output");
            cg_had_error = 1;
            return;
        }

        // Parse the output as declarations
        var prog *u8 = parse_program_from_string(output);
        if prog == nil {
            eprint("error: failed to parse reader output from '");
            eprint_buf(name, name_len);
            eprintln("'");
            cg_had_error = 1;
            return;
        }

        // Process each generated declaration
        var gen_decls *u8 = program_decls(prog);
        var gen_count i64 = program_decl_count(prog);
        i = 0;
        while i < gen_count {
            process_decl_first_pass(get_decl(gen_decls, i));
            i = i + 1;
        }
        return;
    }
    if k == NODE_VAR_DECL {
        add_global(
            var_decl_name(decl),
            var_decl_name_len(decl),
            var_decl_type(decl),
            var_decl_init(decl)
        );
        return;
    }
    if k == NODE_INCLUDE_DECL {
        // Inline include processing to avoid forward declaration
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Check for circular include
        if include_stack_contains(path, path_len) {
            eprint("error: circular include detected: ");
            eprint_buf(path, path_len);
            eprintln("");
            return;
        }

        // Push onto include stack
        include_stack_push(path, path_len);

        // Read file
        var buf *u8 = alloc(1048576);  // 1MB max
        var n i64 = read_file_contents(path, path_len, buf, 1048576);
        if n < 0 {
            eprint("error: cannot open include file: ");
            eprint_buf(path, path_len);
            eprintln("");
            include_stack_pop();
            return;
        }

        // Parse file
        var prog *u8 = parse_program_from_string(buf);
        if prog == nil {
            eprint("error: failed to parse include file: ");
            eprint_buf(path, path_len);
            eprintln("");
            include_stack_pop();
            return;
        }

        // Process declarations from included file (first pass)
        var inc_decls *u8 = program_decls(prog);
        var inc_count i64 = program_decl_count(prog);

        // Save and set current file context (for reader compilation)
        var saved_file_decls *u8 = cg_current_file_decls;
        var saved_file_count i64 = cg_current_file_decl_count;
        var saved_scoped i64 = cg_in_scoped_context;
        cg_current_file_decls = inc_decls;
        cg_current_file_decl_count = inc_count;
        cg_in_scoped_context = 1;  // Mark that we're in an included file

        var i i64 = 0;
        while i < inc_count {
            process_decl_first_pass(get_decl(inc_decls, i));
            i = i + 1;
        }

        // Restore current file context
        cg_current_file_decls = saved_file_decls;
        cg_current_file_decl_count = saved_file_count;
        cg_in_scoped_context = saved_scoped;

        // Pop from include stack
        include_stack_pop();
        return;
    }
}

// ============================================================
// String literal accessors
// ============================================================

func string_get_ptr(index i64) *u8 {
    var p **u8 = cg_strings + (index * 16);
    return *p;
}

func string_set_ptr(index i64, ptr *u8) void {
    var p **u8 = cg_strings + (index * 16);
    *p = ptr;
}

func string_get_len(index i64) i64 {
    var p *i64 = cg_strings + (index * 16) + 8;
    return *p;
}

func string_set_len(index i64, len i64) void {
    var p *i64 = cg_strings + (index * 16) + 8;
    *p = len;
}

func add_string(ptr *u8, len i64) i64 {
    var idx i64 = cg_string_count;
    string_set_ptr(idx, ptr);
    string_set_len(idx, len);
    cg_string_count = cg_string_count + 1;
    return idx;
}

// ============================================================
// Memory comparison
// ============================================================

func memcmp(a *u8, b *u8, len i64) bool {
    var i i64 = 0;
    while i < len {
        if *(a + i) != *(b + i) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// ============================================================
// Output helpers
// ============================================================

func emit_char(c u8) void {
    *(cg_code_buf + cg_code_len) = c;
    cg_code_len = cg_code_len + 1;
}

func emit_str(s *u8) void {
    var i i64 = 0;
    while *(s + i) != 0 {
        emit_char(*(s + i));
        i = i + 1;
    }
}

func emit_n(s *u8, n i64) void {
    var i i64 = 0;
    while i < n {
        emit_char(*(s + i));
        i = i + 1;
    }
}

func emit_int(n i64) void {
    if n < 0 {
        emit_char(45);  // '-'
        n = 0 - n;
    }
    if n == 0 {
        emit_char(48);  // '0'
        return;
    }

    // Find highest power of 10
    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    // Print each digit
    while divisor > 0 {
        var digit i64 = n / divisor;
        emit_char(48 + digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

func emit_line(s *u8) void {
    emit_str(s);
    emit_char(10);  // newline
}

func emit_label(label i64) void {
    emit_str(".L");
    emit_int(label);
}

func new_label() i64 {
    cg_label_num = cg_label_num + 1;
    return cg_label_num;
}

// ============================================================
// Direct file output (for final assembly)
// ============================================================

func out_char(c u8) void {
    file_write(cg_out_fd, &c, 1);
}

func out_str(s *u8) void {
    file_write(cg_out_fd, s, strlen(s));
}

func out_n(s *u8, n i64) void {
    file_write(cg_out_fd, s, n);
}

func out_int(n i64) void {
    if n < 0 {
        out_char(45);  // '-'
        n = 0 - n;
    }
    if n == 0 {
        out_char(48);  // '0'
        return;
    }

    var divisor i64 = 1;
    var temp i64 = n;
    while temp >= 10 {
        temp = temp / 10;
        divisor = divisor * 10;
    }

    while divisor > 0 {
        var digit i64 = n / divisor;
        out_char(48 + digit);
        n = n % divisor;
        divisor = divisor / 10;
    }
}

func out_line(s *u8) void {
    out_str(s);
    out_char(10);
}

// ============================================================
// Type helpers
// ============================================================

// Get field offset within a struct
// Simplified: all fields are 8 bytes for now
func get_field_offset(struct_decl *u8, field_name *u8, field_len i64) i64 {
    if struct_decl == nil {
        return 0 - 1;
    }
    var fields *u8 = struct_decl_fields(struct_decl);
    var count i64 = struct_decl_field_count(struct_decl);
    var offset i64 = 0;
    var i i64 = 0;
    while i < count {
        var f *u8 = get_struct_field(fields, i);
        var fname *u8 = struct_field_name(f);
        var fname_len i64 = struct_field_name_len(f);

        if fname_len == field_len {
            if memcmp(fname, field_name, field_len) {
                return offset;
            }
        }
        offset = offset + 8;  // All fields 8 bytes
        i = i + 1;
    }
    return 0 - 1;
}

// Calculate struct size by summing field sizes (with alignment)
func get_struct_size(decl *u8) i64 {
    var fields *u8 = struct_decl_fields(decl);
    var count i64 = struct_decl_field_count(decl);
    var size i64 = 0;
    var i i64 = 0;
    while i < count {
        var f *u8 = get_struct_field(fields, i);
        var field_type *u8 = struct_field_type(f);
        var field_size i64 = get_type_size(field_type);
        // Align to field size (simplistic: align to 8 for now)
        if field_size > 1 {
            var rem i64 = size % 8;
            if rem != 0 {
                size = size + 8 - rem;
            }
        }
        size = size + field_size;
        i = i + 1;
    }
    // Align total size to 8
    var rem i64 = size % 8;
    if rem != 0 {
        size = size + 8 - rem;
    }
    return size;
}

func get_type_size(t *u8) i64 {
    if t == nil {
        return 8;
    }
    var k i64 = type_kind(t);
    if k == TYPE_PTR {
        return 8;
    }
    if k == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);

        // Check for 1-byte types
        if len == 2 {
            if memcmp(name, "u8", 2) || memcmp(name, "i8", 2) {
                return 1;
            }
        }
        // Check for 2-byte types
        if len == 3 {
            if memcmp(name, "u16", 3) || memcmp(name, "i16", 3) {
                return 2;
            }
            if memcmp(name, "u32", 3) || memcmp(name, "i32", 3) {
                return 4;
            }
            if memcmp(name, "u64", 3) || memcmp(name, "i64", 3) {
                return 8;
            }
        }
        if len == 4 {
            if memcmp(name, "bool", 4) {
                return 1;
            }
            if memcmp(name, "void", 4) {
                return 0;
            }
        }
        // Check if it's a struct type
        var struct_decl *u8 = find_struct(name, len);
        if struct_decl != nil {
            return get_struct_size(struct_decl);
        }
    }
    return 8;  // default
}

func get_pointed_type(t *u8) *u8 {
    if t == nil {
        return nil;
    }
    if type_kind(t) == TYPE_PTR {
        return ptr_type_elem(t);
    }
    return nil;
}

func is_void_type(t *u8) bool {
    if t == nil {
        return true;
    }
    if type_kind(t) == TYPE_BASE {
        var name *u8 = base_type_name(t);
        var len i64 = base_type_name_len(t);
        if len == 4 {
            return memcmp(name, "void", 4);
        }
    }
    return false;
}

// ============================================================
// Expression type inference
// ============================================================

func get_expr_type(expr *u8) *u8 {
    if expr == nil {
        return nil;
    }

    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check locals first
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            return local_get_type(local_idx);
        }

        // Check globals
        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            return global_get_type(global_idx);
        }

        return nil;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_STAR {  // dereference
            var inner_type *u8 = get_expr_type(unary_expr_expr(expr));
            return get_pointed_type(inner_type);
        }
        if op == TOKEN_AMP {  // address-of
            // Should return pointer type, but we'd need to create it
            return nil;
        }
        return get_expr_type(unary_expr_expr(expr));
    }

    if k == NODE_BINARY_EXPR {
        return get_expr_type(binary_expr_left(expr));
    }

    if k == NODE_GROUP_EXPR {
        return get_expr_type(group_expr_expr(expr));
    }

    // Default: i64
    return nil;
}

// ============================================================
// Constant evaluation (for global initializers)
// ============================================================

func eval_constant(expr *u8) i64 {
    if expr == nil {
        return 0;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        // Parse the number string
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        var val i64 = 0;
        var i i64 = 0;
        while i < len {
            val = val * 10 + (*(ptr + i) - 48);
            i = i + 1;
        }
        return val;
    }

    if k == NODE_BOOL_EXPR {
        return bool_expr_value(expr);
    }

    if k == NODE_NIL_EXPR {
        return 0;
    }

    if k == NODE_IDENT_EXPR {
        // Look up global constant
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check for "nil"
        if name_len == 3 {
            if memcmp(name, "nil", 3) {
                return 0;
            }
        }

        var idx i64 = find_global(name, name_len);
        if idx >= 0 {
            var init *u8 = global_get_init(idx);
            if init != nil {
                return eval_constant(init);
            }
        }
        return 0;
    }

    if k == NODE_UNARY_EXPR {
        var val i64 = eval_constant(unary_expr_expr(expr));
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_MINUS {
            return 0 - val;
        }
        if op == TOKEN_BANG {
            if val == 0 {
                return 1;
            }
            return 0;
        }
        return val;
    }

    if k == NODE_BINARY_EXPR {
        var left i64 = eval_constant(binary_expr_left(expr));
        var right i64 = eval_constant(binary_expr_right(expr));
        var op i64 = binary_expr_op(expr);

        if op == TOKEN_PLUS { return left + right; }
        if op == TOKEN_MINUS { return left - right; }
        if op == TOKEN_STAR { return left * right; }
        if op == TOKEN_SLASH {
            if right != 0 { return left / right; }
            return 0;
        }
        if op == TOKEN_PERCENT {
            if right != 0 { return left % right; }
            return 0;
        }
        if op == TOKEN_EQEQ {
            if left == right { return 1; }
            return 0;
        }
        if op == TOKEN_BANGEQ {
            if left != right { return 1; }
            return 0;
        }
        if op == TOKEN_LT {
            if left < right { return 1; }
            return 0;
        }
        if op == TOKEN_GT {
            if left > right { return 1; }
            return 0;
        }
        if op == TOKEN_LTEQ {
            if left <= right { return 1; }
            return 0;
        }
        if op == TOKEN_GTEQ {
            if left >= right { return 1; }
            return 0;
        }
        return 0;
    }

    if k == NODE_GROUP_EXPR {
        return eval_constant(group_expr_expr(expr));
    }

    return 0;
}

// ============================================================
// String formatting for .ascii directive
// ============================================================

func emit_ascii_string(ptr *u8, len i64) void {
    // Skip quotes in original string
    var start *u8 = ptr + 1;
    var end i64 = len - 2;

    emit_char(34);  // opening quote

    var i i64 = 0;
    while i < end {
        var c u8 = *(start + i);

        if c == 92 && i + 1 < end {  // backslash escape
            i = i + 1;
            var next u8 = *(start + i);
            if next == 110 {  // 'n'
                emit_str("\\012");
            } else if next == 116 {  // 't'
                emit_str("\\011");
            } else if next == 114 {  // 'r'
                emit_str("\\015");
            } else if next == 92 {  // '\'
                emit_str("\\\\");
            } else if next == 34 {  // '"'
                emit_str("\\\"");
            } else if next == 48 {  // '0'
                emit_str("\\000");
            } else {
                emit_char(next);
            }
        } else if c >= 32 && c < 127 && c != 34 && c != 92 {
            emit_char(c);
        } else {
            // Octal escape
            emit_char(92);  // '\'
            emit_char(48 + (c / 64));
            emit_char(48 + ((c / 8) % 8));
            emit_char(48 + (c % 8));
        }
        i = i + 1;
    }

    emit_str("\\000");  // null terminator
    emit_char(34);  // closing quote
}

// ============================================================
// Expression code generation
// ============================================================

func gen_expr(expr *u8) void {
    if expr == nil {
        return;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        emit_str("    mov $");
        emit_n(number_expr_value(expr), number_expr_value_len(expr));
        emit_line(", %rax");
        return;
    }

    if k == NODE_STRING_EXPR {
        var idx i64 = add_string(string_expr_value(expr), string_expr_value_len(expr));
        emit_str("    lea .str");
        emit_int(idx);
        emit_line("(%rip), %rax");
        return;
    }

    if k == NODE_BOOL_EXPR {
        if bool_expr_value(expr) != 0 {
            emit_line("    mov $1, %rax");
        } else {
            emit_line("    xor %rax, %rax");
        }
        return;
    }

    if k == NODE_NIL_EXPR {
        emit_line("    xor %rax, %rax");
        return;
    }

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        // Check locals
        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            emit_str("    mov ");
            emit_int(local_get_offset(local_idx));
            emit_line("(%rbp), %rax");
            return;
        }

        // Check globals
        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            emit_str("    mov ");
            emit_n(name, name_len);
            emit_line("(%rip), %rax");
            return;
        }

        // Function reference
        emit_str("    lea ");
        emit_n(name, name_len);
        emit_line("(%rip), %rax");
        return;
    }

    if k == NODE_GROUP_EXPR {
        gen_expr(group_expr_expr(expr));
        return;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);

        if op == TOKEN_AMP {  // address-of
            var inner *u8 = unary_expr_expr(expr);
            if node_kind(inner) == NODE_IDENT_EXPR {
                var name *u8 = ident_expr_name(inner);
                var name_len i64 = ident_expr_name_len(inner);

                var local_idx i64 = find_local(name, name_len);
                if local_idx >= 0 {
                    emit_str("    lea ");
                    emit_int(local_get_offset(local_idx));
                    emit_line("(%rbp), %rax");
                    return;
                }

                var global_idx i64 = find_global(name, name_len);
                if global_idx >= 0 {
                    emit_str("    lea ");
                    emit_n(name, name_len);
                    emit_line("(%rip), %rax");
                    return;
                }
            }
            return;
        }

        gen_expr(unary_expr_expr(expr));

        if op == TOKEN_MINUS {
            emit_line("    neg %rax");
            return;
        }

        if op == TOKEN_BANG {
            emit_line("    test %rax, %rax");
            emit_line("    setz %al");
            emit_line("    movzx %al, %rax");
            return;
        }

        if op == TOKEN_STAR {  // dereference
            var ptr_type *u8 = get_expr_type(unary_expr_expr(expr));
            var elem_type *u8 = get_pointed_type(ptr_type);
            var size i64 = 8;
            if elem_type != nil {
                size = get_type_size(elem_type);
            }

            if size == 1 {
                emit_line("    movzbl (%rax), %eax");
            } else if size == 2 {
                emit_line("    movzwl (%rax), %eax");
            } else if size == 4 {
                emit_line("    mov (%rax), %eax");
            } else {
                emit_line("    mov (%rax), %rax");
            }
            return;
        }

        return;
    }

    if k == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);

        // Assignment
        if op == TOKEN_EQ {
            gen_expr(binary_expr_right(expr));
            gen_lvalue_store(binary_expr_left(expr));
            return;
        }

        // Short-circuit &&
        if op == TOKEN_AMPAMP {
            var end_label i64 = new_label();
            gen_expr(binary_expr_left(expr));
            emit_line("    test %rax, %rax");
            emit_str("    jz ");
            emit_label(end_label);
            emit_char(10);
            gen_expr(binary_expr_right(expr));
            emit_label(end_label);
            emit_line(":");
            return;
        }

        // Short-circuit ||
        if op == TOKEN_PIPEPIPE {
            var end_label i64 = new_label();
            gen_expr(binary_expr_left(expr));
            emit_line("    test %rax, %rax");
            emit_str("    jnz ");
            emit_label(end_label);
            emit_char(10);
            gen_expr(binary_expr_right(expr));
            emit_label(end_label);
            emit_line(":");
            return;
        }

        // General binary: left in rax, push, right in rcx
        gen_expr(binary_expr_left(expr));
        emit_line("    push %rax");
        gen_expr(binary_expr_right(expr));
        emit_line("    mov %rax, %rcx");
        emit_line("    pop %rax");

        if op == TOKEN_PLUS {
            emit_line("    add %rcx, %rax");
        } else if op == TOKEN_MINUS {
            emit_line("    sub %rcx, %rax");
        } else if op == TOKEN_STAR {
            emit_line("    imul %rcx, %rax");
        } else if op == TOKEN_SLASH {
            emit_line("    cqo");
            emit_line("    idiv %rcx");
        } else if op == TOKEN_PERCENT {
            emit_line("    cqo");
            emit_line("    idiv %rcx");
            emit_line("    mov %rdx, %rax");
        } else if op == TOKEN_EQEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    sete %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_BANGEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setne %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_LT {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setl %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_GT {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setg %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_LTEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setle %al");
            emit_line("    movzx %al, %rax");
        } else if op == TOKEN_GTEQ {
            emit_line("    cmp %rcx, %rax");
            emit_line("    setge %al");
            emit_line("    movzx %al, %rax");
        }
        return;
    }

    if k == NODE_CALL_EXPR {
        var func_expr *u8 = call_expr_func(expr);
        var args *u8 = call_expr_args(expr);
        var arg_count i64 = call_expr_arg_count(expr);

        // Check for syscall
        if node_kind(func_expr) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(func_expr);
            var name_len i64 = ident_expr_name_len(func_expr);
            if name_len == 7 {
                if memcmp(name, "syscall", 7) {
                    gen_syscall(args, arg_count);
                    return;
                }
            }

            // Check for macro call
            var macro_def *u8 = find_macro(name, name_len);
            if macro_def != nil {
                // Call the macro interpreter
                var expanded *u8 = interp_call_macro(macro_def, args, arg_count);
                // Print expansion if --expand-macros flag is set
                if cg_expand_macros != 0 && expanded != nil {
                    eprint("[macro ");
                    eprint_buf(name, name_len);
                    eprint("] => ");
                    print_expr_ast(expanded);
                    eprintln("");
                }
                // Generate code for the expanded AST
                if expanded != nil {
                    gen_expr(expanded);
                }
                return;
            }
        }

        // Push args in reverse order
        var i i64 = arg_count - 1;
        while i >= 0 {
            var p **u8 = args + (i * 8);
            gen_expr(*p);
            emit_line("    push %rax");
            i = i - 1;
        }

        // Pop into arg registers: rdi, rsi, rdx, rcx, r8, r9
        i = 0;
        while i < arg_count && i < 6 {
            if i == 0 { emit_line("    pop %rdi"); }
            else if i == 1 { emit_line("    pop %rsi"); }
            else if i == 2 { emit_line("    pop %rdx"); }
            else if i == 3 { emit_line("    pop %rcx"); }
            else if i == 4 { emit_line("    pop %r8"); }
            else if i == 5 { emit_line("    pop %r9"); }
            i = i + 1;
        }

        // Call function
        if node_kind(func_expr) == NODE_IDENT_EXPR {
            emit_str("    call ");
            emit_n(ident_expr_name(func_expr), ident_expr_name_len(func_expr));
            emit_char(10);
        } else {
            gen_expr(func_expr);
            emit_line("    call *%rax");
        }
        return;
    }

    if k == NODE_INDEX_EXPR {
        // Not implemented for now
        return;
    }

    if k == NODE_FIELD_EXPR {
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Get type of base expression
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            return;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;
        var is_pointer i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            // Pointer to struct: get the pointed-to type
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
                is_pointer = 1;
            }
        }

        if struct_name == nil {
            return;
        }

        // Look up struct
        cg_temp_struct_decl = find_struct(struct_name, struct_name_len);
        if cg_temp_struct_decl == nil {
            return;
        }

        // Get field offset
        var field_offset i64 = get_field_offset(cg_temp_struct_decl, field_name, field_len);
        if field_offset < 0 {
            return;
        }

        // Generate code to load field value
        if is_pointer != 0 {
            // Pointer to struct: load pointer, then access field
            gen_expr(base_expr);
            if field_offset == 0 {
                emit_line("    mov (%rax), %rax");
            } else {
                emit_str("    mov ");
                emit_int(field_offset);
                emit_line("(%rax), %rax");
            }
            return;
        }

        // Direct struct variable: load from (base_offset + field_offset)(%rbp)
        if node_kind(base_expr) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(base_expr);
            var name_len i64 = ident_expr_name_len(base_expr);
            var local_idx i64 = find_local(name, name_len);
            if local_idx >= 0 {
                var base_offset i64 = local_get_offset(local_idx);
                emit_str("    mov ");
                emit_int(base_offset + field_offset);
                emit_line("(%rbp), %rax");
                return;
            }
        }
        return;
    }

    if k == NODE_READER_EXPR {
        // Reader macro invocation - V2: run compiled executable
        var name *u8 = reader_expr_name(expr);
        var name_len i64 = reader_expr_name_len(expr);
        var content *u8 = reader_expr_content(expr);
        var content_len i64 = reader_expr_content_len(expr);

        // Look up the reader
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            eprint("error: reader macro '");
            eprint_buf(name, name_len);
            eprintln("' not found");
            cg_had_error = 1;
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = alloc(256);
        var i i64 = 0;
        var base *u8 = ".lang-cache/readers/";
        while *base != 0 { *(exe_path + i) = *base; i = i + 1; base = base + 1; }
        var j i64 = 0;
        while j < name_len { *(exe_path + i) = *(name + j); i = i + 1; j = j + 1; }
        *(exe_path + i) = 0;

        // Execute reader with content as input
        var output *u8 = alloc(65536);
        var n i64 = exec_capture(exe_path, content, content_len, output, 65536);

        if n <= 0 {
            eprint("error: reader '");
            eprint_buf(name, name_len);
            eprintln("' returned no output");
            cg_had_error = 1;
            return;
        }

        // Parse the output as a lang expression
        var expanded *u8 = parse_expression_from_string(output);

        // Generate code for the expanded AST
        if expanded != nil {
            gen_expr(expanded);
        }
        return;
    }
}

func gen_syscall(args *u8, arg_count i64) void {
    if arg_count == 0 {
        return;
    }

    // Push all args in reverse
    var i i64 = arg_count - 1;
    while i >= 0 {
        var p **u8 = args + (i * 8);
        gen_expr(*p);
        emit_line("    push %rax");
        i = i - 1;
    }

    // Pop syscall number into rax
    emit_line("    pop %rax");

    // Pop args into syscall registers: rdi, rsi, rdx, r10, r8, r9
    i = 1;
    while i < arg_count && i <= 6 {
        if i == 1 { emit_line("    pop %rdi"); }
        else if i == 2 { emit_line("    pop %rsi"); }
        else if i == 3 { emit_line("    pop %rdx"); }
        else if i == 4 { emit_line("    pop %r10"); }
        else if i == 5 { emit_line("    pop %r8"); }
        else if i == 6 { emit_line("    pop %r9"); }
        i = i + 1;
    }

    emit_line("    syscall");
}

func gen_lvalue_store(expr *u8) void {
    var k i64 = node_kind(expr);

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);

        var local_idx i64 = find_local(name, name_len);
        if local_idx >= 0 {
            emit_str("    mov %rax, ");
            emit_int(local_get_offset(local_idx));
            emit_line("(%rbp)");
            return;
        }

        var global_idx i64 = find_global(name, name_len);
        if global_idx >= 0 {
            emit_str("    mov %rax, ");
            emit_n(name, name_len);
            emit_line("(%rip)");
            return;
        }
        return;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_STAR {
            // *ptr = value
            emit_line("    push %rax");
            gen_expr(unary_expr_expr(expr));
            emit_line("    mov %rax, %rcx");
            emit_line("    pop %rax");
            emit_line("    mov %rax, (%rcx)");
            return;
        }
    }

    if k == NODE_FIELD_EXPR {
        // p.x = value - store to struct field
        var base_expr *u8 = field_expr_expr(expr);
        var field_name *u8 = field_expr_field(expr);
        var field_len i64 = field_expr_field_len(expr);

        // Get type of base expression
        var base_type *u8 = get_expr_type(base_expr);
        if base_type == nil {
            return;
        }

        var struct_name *u8 = nil;
        var struct_name_len i64 = 0;
        var is_pointer i64 = 0;

        // Check if base is a direct struct or pointer to struct
        if type_kind(base_type) == TYPE_BASE {
            struct_name = base_type_name(base_type);
            struct_name_len = base_type_name_len(base_type);
        } else if type_kind(base_type) == TYPE_PTR {
            var pointed_type *u8 = ptr_type_elem(base_type);
            if pointed_type != nil && type_kind(pointed_type) == TYPE_BASE {
                struct_name = base_type_name(pointed_type);
                struct_name_len = base_type_name_len(pointed_type);
                is_pointer = 1;
            }
        }

        if struct_name == nil {
            return;
        }

        // Look up struct
        cg_temp_struct_decl = find_struct(struct_name, struct_name_len);
        if cg_temp_struct_decl == nil {
            return;
        }

        // Get field offset
        var field_offset i64 = get_field_offset(cg_temp_struct_decl, field_name, field_len);
        if field_offset < 0 {
            return;
        }

        // Generate code to store to field
        if is_pointer != 0 {
            // Pointer to struct: save value, load pointer, store to field
            emit_line("    push %rax");
            gen_expr(base_expr);
            emit_line("    mov %rax, %rcx");
            emit_line("    pop %rax");
            if field_offset == 0 {
                emit_line("    mov %rax, (%rcx)");
            } else {
                emit_str("    mov %rax, ");
                emit_int(field_offset);
                emit_line("(%rcx)");
            }
            return;
        }

        // Direct struct variable: store to (base_offset + field_offset)(%rbp)
        if node_kind(base_expr) == NODE_IDENT_EXPR {
            var name *u8 = ident_expr_name(base_expr);
            var name_len i64 = ident_expr_name_len(base_expr);
            var local_idx i64 = find_local(name, name_len);
            if local_idx >= 0 {
                var base_offset i64 = local_get_offset(local_idx);
                emit_str("    mov %rax, ");
                emit_int(base_offset + field_offset);
                emit_line("(%rbp)");
                return;
            }
        }
        return;
    }
}

// ============================================================
// Statement code generation
// ============================================================

func gen_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }

    var k i64 = node_kind(stmt);

    if k == NODE_VAR_DECL {
        var var_type *u8 = var_decl_type(stmt);
        var var_size i64 = get_type_size(var_type);
        if var_size < 8 {
            var_size = 8;  // Minimum 8 bytes for alignment
        }
        cg_stack_size = cg_stack_size + var_size;
        var offset i64 = 0 - cg_stack_size;

        add_local(var_decl_name(stmt), var_decl_name_len(stmt), offset, var_decl_type(stmt));

        var init *u8 = var_decl_init(stmt);
        if init != nil {
            gen_expr(init);
            emit_str("    mov %rax, ");
            emit_int(offset);
            emit_line("(%rbp)");
        }
        return;
    }

    if k == NODE_EXPR_STMT {
        gen_expr(expr_stmt_expr(stmt));
        return;
    }

    if k == NODE_RETURN_STMT {
        var value *u8 = return_stmt_value(stmt);
        if value != nil {
            gen_expr(value);
        } else {
            emit_line("    xor %rax, %rax");
        }
        emit_line("    leave");
        emit_line("    ret");
        return;
    }

    if k == NODE_IF_STMT {
        var else_label i64 = new_label();
        var end_label i64 = new_label();

        gen_expr(if_stmt_cond(stmt));
        emit_line("    test %rax, %rax");

        if if_stmt_else(stmt) != nil {
            emit_str("    jz ");
            emit_label(else_label);
            emit_char(10);
        } else {
            emit_str("    jz ");
            emit_label(end_label);
            emit_char(10);
        }

        gen_block(if_stmt_then(stmt));

        if if_stmt_else(stmt) != nil {
            emit_str("    jmp ");
            emit_label(end_label);
            emit_char(10);

            emit_label(else_label);
            emit_line(":");

            var els *u8 = if_stmt_else(stmt);
            if node_kind(els) == NODE_BLOCK_STMT {
                gen_block(els);
            } else {
                gen_stmt(els);
            }
        }

        emit_label(end_label);
        emit_line(":");
        return;
    }

    if k == NODE_WHILE_STMT {
        var start_label i64 = new_label();
        var end_label i64 = new_label();

        emit_label(start_label);
        emit_line(":");

        gen_expr(while_stmt_cond(stmt));
        emit_line("    test %rax, %rax");
        emit_str("    jz ");
        emit_label(end_label);
        emit_char(10);

        gen_block(while_stmt_body(stmt));

        emit_str("    jmp ");
        emit_label(start_label);
        emit_char(10);

        emit_label(end_label);
        emit_line(":");
        return;
    }

    if k == NODE_BLOCK_STMT {
        gen_block(stmt);
        return;
    }
}

func gen_block(block *u8) void {
    var stmts *u8 = block_stmt_stmts(block);
    var count i64 = block_stmt_count(block);

    var i i64 = 0;
    while i < count {
        var p **u8 = stmts + (i * 8);
        gen_stmt(*p);
        i = i + 1;
    }
}

// ============================================================
// Function code generation
// ============================================================

func gen_func(func_node *u8) void {
    // Reset locals
    cg_local_count = 0;
    cg_stack_size = 0;

    var name *u8 = func_decl_name(func_node);
    var name_len i64 = func_decl_name_len(func_node);

    emit_str(".globl ");
    emit_n(name, name_len);
    emit_char(10);

    emit_n(name, name_len);
    emit_line(":");

    // Prologue
    emit_line("    push %rbp");
    emit_line("    mov %rsp, %rbp");
    // SAFETY: Use 4KB stack frame to avoid silent overflow corruption
    // The compiler itself has functions with 50+ local variables (gen_expr)
    // TODO: calculate actual size from cg_stack_size after generating body
    emit_line("    sub $4096, %rsp");

    // Store parameters
    var params *u8 = func_decl_params(func_node);
    var param_count i64 = func_decl_param_count(func_node);

    var i i64 = 0;
    while i < param_count {
        cg_stack_size = cg_stack_size + 8;
        var offset i64 = 0 - cg_stack_size;

        var p *u8 = params + (i * 24);
        add_local(param_name(p), param_name_len(p), offset, param_type(p));

        // Move from arg register to stack
        if i == 0 {
            emit_str("    mov %rdi, ");
        } else if i == 1 {
            emit_str("    mov %rsi, ");
        } else if i == 2 {
            emit_str("    mov %rdx, ");
        } else if i == 3 {
            emit_str("    mov %rcx, ");
        } else if i == 4 {
            emit_str("    mov %r8, ");
        } else if i == 5 {
            emit_str("    mov %r9, ");
        }
        emit_int(offset);
        emit_line("(%rbp)");

        i = i + 1;
    }

    // Generate body
    gen_block(func_decl_body(func_node));

    // Default return if void
    var ret_type *u8 = func_decl_ret_type(func_node);
    if is_void_type(ret_type) {
        emit_line("    xor %rax, %rax");
        emit_line("    leave");
        emit_line("    ret");
    }

    emit_char(10);
}

func patch_stack_size(pos i64, size i64) void {
    // Find "STACKSIZE" starting at pos and replace with the actual number
    // The string "    sub $STACKSIZE, %rsp\n" is 26 chars
    // We need to replace STACKSIZE (9 chars) with the actual number

    // For simplicity, we'll rebuild the instruction
    // Actually, let's just find and replace in place

    // Scan from pos looking for 'S' (start of STACKSIZE)
    var i i64 = pos;
    while i < cg_code_len {
        if *(cg_code_buf + i) == 83 {  // 'S'
            // Check if it's STACKSIZE
            if memcmp(cg_code_buf + i, "STACKSIZE", 9) {
                // Calculate how many digits we need
                var num_len i64 = 1;
                var temp i64 = size;
                while temp >= 10 {
                    temp = temp / 10;
                    num_len = num_len + 1;
                }

                // Shift the rest of the buffer if needed
                var diff i64 = num_len - 9;
                if diff != 0 {
                    // Move rest of buffer
                    var j i64 = cg_code_len - 1;
                    if diff > 0 {
                        // Expand
                        while j >= i + 9 {
                            *(cg_code_buf + j + diff) = *(cg_code_buf + j);
                            j = j - 1;
                        }
                    } else {
                        // Contract
                        j = i + 9;
                        while j < cg_code_len {
                            *(cg_code_buf + j + diff) = *(cg_code_buf + j);
                            j = j + 1;
                        }
                    }
                    cg_code_len = cg_code_len + diff;
                }

                // Write the number
                var divisor i64 = 1;
                temp = size;
                while temp >= 10 {
                    temp = temp / 10;
                    divisor = divisor * 10;
                }
                var k i64 = 0;
                while divisor > 0 {
                    *(cg_code_buf + i + k) = 48 + (size / divisor);
                    size = size % divisor;
                    divisor = divisor / 10;
                    k = k + 1;
                }

                return;
            }
        }
        i = i + 1;
    }
}

// ============================================================
// Declaration code generation
// ============================================================

func gen_decl(decl *u8) void {
    if decl == nil {
        return;
    }

    var k i64 = node_kind(decl);

    if k == NODE_FUNC_DECL {
        gen_func(decl);
        return;
    }

    if k == NODE_VAR_DECL {
        // Global variable - already registered
        return;
    }

    if k == NODE_IMPORT {
        // Import declaration - file loading not yet implemented
        eprint("warning: import not yet implemented: ");
        eprint_buf(import_decl_path(decl), import_decl_path_len(decl));
        eprintln("");
        return;
    }

    if k == NODE_READER_DECL {
        // Already registered in first pass
        return;
    }

    if k == NODE_INCLUDE_DECL {
        // Generate code for included declarations (inline to avoid forward decl)
        var path *u8 = include_decl_path(decl);
        var path_len i64 = include_decl_path_len(decl);

        // Check for circular include (same check as first pass)
        if include_stack_contains(path, path_len) {
            // Already detected in first pass, just skip silently
            return;
        }

        // Push onto include stack
        include_stack_push(path, path_len);

        // Re-read and re-parse file
        var buf *u8 = alloc(1048576);
        var n i64 = read_file_contents(path, path_len, buf, 1048576);
        if n < 0 {
            include_stack_pop();
            return;
        }

        var prog *u8 = parse_program_from_string(buf);
        if prog == nil {
            include_stack_pop();
            return;
        }

        // Generate code for included declarations
        var inc_decls *u8 = program_decls(prog);
        var inc_count i64 = program_decl_count(prog);
        var i i64 = 0;
        while i < inc_count {
            gen_decl(get_decl(inc_decls, i));
            i = i + 1;
        }

        include_stack_pop();
        return;
    }

    if k == NODE_READER_EXPR {
        // Reader macro at declaration level - expand and generate code
        var name *u8 = reader_expr_name(decl);
        var name_len i64 = reader_expr_name_len(decl);
        var content *u8 = reader_expr_content(decl);
        var content_len i64 = reader_expr_content_len(decl);

        // Look up the reader
        var reader_decl *u8 = find_reader(name, name_len);
        if reader_decl == nil {
            // Error already reported in first pass
            return;
        }

        // Build path to reader executable
        var exe_path *u8 = alloc(256);
        var i i64 = 0;
        var base *u8 = ".lang-cache/readers/";
        while *base != 0 { *(exe_path + i) = *base; i = i + 1; base = base + 1; }
        var j i64 = 0;
        while j < name_len { *(exe_path + i) = *(name + j); i = i + 1; j = j + 1; }
        *(exe_path + i) = 0;

        // Execute reader with content as input
        var output *u8 = alloc(131072);  // 128KB
        var n i64 = exec_capture(exe_path, content, content_len, output, 131072);

        if n <= 0 {
            // Error already reported in first pass
            return;
        }

        // Parse the output as declarations
        var prog *u8 = parse_program_from_string(output);
        if prog == nil {
            // Error already reported in first pass
            return;
        }

        // Generate code for each declaration
        var gen_decls *u8 = program_decls(prog);
        var gen_count i64 = program_decl_count(prog);
        i = 0;
        while i < gen_count {
            gen_decl(get_decl(gen_decls, i));
            i = i + 1;
        }
        return;
    }
}

// ============================================================
// Compile-time interpreter for macros
// ============================================================

// Interpreter state
// Macro parameter bindings: [name_ptr:8][name_len:8][value:8] = 24 bytes
// Max 16 params
var interp_bindings *u8 = nil;
var interp_binding_count i64 = 0;

// Return value from macro (set by return statement)
var interp_return_value i64 = 0;
var interp_has_returned i64 = 0;

func interp_init() void {
    if interp_bindings == nil {
        interp_bindings = alloc(384);  // 16 * 24
    }
    interp_binding_count = 0;
    interp_return_value = 0;
    interp_has_returned = 0;
}

func interp_add_binding(name *u8, name_len i64, value i64) void {
    var entry *u8 = interp_bindings + (interp_binding_count * 24);

    var np **u8 = entry;
    *np = name;

    var nl *i64 = entry + 8;
    *nl = name_len;

    var vp *i64 = entry + 16;
    *vp = value;

    interp_binding_count = interp_binding_count + 1;
}

func interp_find_binding(name *u8, name_len i64) i64 {
    var i i64 = interp_binding_count - 1;
    while i >= 0 {
        var entry *u8 = interp_bindings + (i * 24);

        var np **u8 = entry;
        var bname *u8 = *np;

        var nl *i64 = entry + 8;
        var blen i64 = *nl;

        if blen == name_len {
            if memcmp(bname, name, name_len) {
                var vp *i64 = entry + 16;
                return *vp;
            }
        }
        i = i - 1;
    }
    return 0;  // Not found
}

func interp_set_binding(name *u8, name_len i64, value i64) void {
    var i i64 = interp_binding_count - 1;
    while i >= 0 {
        var entry *u8 = interp_bindings + (i * 24);

        var np **u8 = entry;
        var bname *u8 = *np;

        var nl *i64 = entry + 8;
        var blen i64 = *nl;

        if blen == name_len {
            if memcmp(bname, name, name_len) {
                var vp *i64 = entry + 16;
                *vp = value;
                return;
            }
        }
        i = i - 1;
    }
}

// Expand unquotes in a quoted expression
// Walks the AST and replaces NODE_UNQUOTE_EXPR with the bound AST
func expand_quote(expr *u8) *u8 {
    if expr == nil {
        return nil;
    }

    var k i64 = node_kind(expr);

    // Unquote: look up binding and return the bound AST
    if k == NODE_UNQUOTE_EXPR {
        var name *u8 = unquote_expr_name(expr);
        var name_len i64 = unquote_expr_name_len(expr);
        return interp_find_binding(name, name_len);
    }

    // Unquote string: look up binding (string), create STRING_EXPR node
    // Note: STRING_EXPR values must include quotes for write_ascii_string
    if k == NODE_UNQUOTE_STRING_EXPR {
        var name *u8 = unquote_string_expr_name(expr);
        var name_len i64 = unquote_string_expr_name_len(expr);
        var str_ptr *u8 = interp_find_binding(name, name_len);
        var str_len i64 = strlen(str_ptr);

        // Wrap in quotes: allocate space for " + content + "
        var quoted *u8 = alloc(str_len + 3);  // quote + content + quote + null
        *quoted = 34;  // opening quote
        var i i64 = 0;
        while i < str_len {
            *(quoted + 1 + i) = *(str_ptr + i);
            i = i + 1;
        }
        *(quoted + 1 + str_len) = 34;  // closing quote
        *(quoted + 2 + str_len) = 0;   // null terminator

        var new_node *u8 = string_expr_alloc();
        string_expr_set_value(new_node, quoted);
        string_expr_set_value_len(new_node, str_len + 2);
        return new_node;
    }

    // Binary expression: expand both children
    if k == NODE_BINARY_EXPR {
        var left *u8 = expand_quote(binary_expr_left(expr));
        var right *u8 = expand_quote(binary_expr_right(expr));

        var new_node *u8 = binary_expr_alloc();
        binary_expr_set_op(new_node, binary_expr_op(expr));
        binary_expr_set_left(new_node, left);
        binary_expr_set_right(new_node, right);
        return new_node;
    }

    // Unary expression: expand child
    if k == NODE_UNARY_EXPR {
        var child *u8 = expand_quote(unary_expr_expr(expr));

        var new_node *u8 = unary_expr_alloc();
        unary_expr_set_op(new_node, unary_expr_op(expr));
        unary_expr_set_expr(new_node, child);
        return new_node;
    }

    // Group expression: expand child
    if k == NODE_GROUP_EXPR {
        var child *u8 = expand_quote(group_expr_expr(expr));

        var new_node *u8 = group_expr_alloc();
        group_expr_set_expr(new_node, child);
        return new_node;
    }

    // Call expression: expand function and args
    if k == NODE_CALL_EXPR {
        var func_node *u8 = expand_quote(call_expr_func(expr));
        var old_args *u8 = call_expr_args(expr);
        var num_args i64 = call_expr_arg_count(expr);

        var new_args *u8 = alloc(num_args * 8);
        var ai i64 = 0;
        while ai < num_args {
            var old_arg_ptr **u8 = old_args + (ai * 8);
            var expanded_arg *u8 = expand_quote(*old_arg_ptr);
            var new_arg_ptr **u8 = new_args + (ai * 8);
            *new_arg_ptr = expanded_arg;
            ai = ai + 1;
        }

        var new_node *u8 = call_expr_alloc();
        call_expr_set_func(new_node, func_node);
        call_expr_set_args(new_node, new_args);
        call_expr_set_arg_count(new_node, num_args);
        return new_node;
    }

    // Literals and identifiers: return as-is (they don't contain unquotes)
    return expr;
}

func interp_expr(expr *u8) i64 {
    if expr == nil {
        return 0;
    }

    var k i64 = node_kind(expr);

    if k == NODE_NUMBER_EXPR {
        // Parse the number string
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        var val i64 = 0;
        var ii i64 = 0;
        while ii < len {
            val = val * 10 + (*(ptr + ii) - 48);
            ii = ii + 1;
        }
        return val;
    }

    if k == NODE_BOOL_EXPR {
        return bool_expr_value(expr);
    }

    if k == NODE_NIL_EXPR {
        return 0;
    }

    if k == NODE_STRING_EXPR {
        // Return pointer to string value (for use in macros)
        return string_expr_value(expr);
    }

    if k == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        return interp_find_binding(name, name_len);
    }

    if k == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);
        var left i64 = interp_expr(binary_expr_left(expr));
        var right i64 = interp_expr(binary_expr_right(expr));

        if op == TOKEN_PLUS { return left + right; }
        if op == TOKEN_MINUS { return left - right; }
        if op == TOKEN_STAR { return left * right; }
        if op == TOKEN_SLASH { return left / right; }
        if op == TOKEN_PERCENT { return left % right; }
        if op == TOKEN_EQEQ { if left == right { return 1; } return 0; }
        if op == TOKEN_BANGEQ { if left != right { return 1; } return 0; }
        if op == TOKEN_LT { if left < right { return 1; } return 0; }
        if op == TOKEN_GT { if left > right { return 1; } return 0; }
        if op == TOKEN_LTEQ { if left <= right { return 1; } return 0; }
        if op == TOKEN_GTEQ { if left >= right { return 1; } return 0; }
        if op == TOKEN_AMPAMP { if left != 0 && right != 0 { return 1; } return 0; }
        if op == TOKEN_PIPEPIPE { if left != 0 || right != 0 { return 1; } return 0; }
        if op == TOKEN_EQ {
            // Assignment
            var left_node *u8 = binary_expr_left(expr);
            if node_kind(left_node) == NODE_IDENT_EXPR {
                interp_set_binding(
                    ident_expr_name(left_node),
                    ident_expr_name_len(left_node),
                    right
                );
            }
            return right;
        }
        return 0;
    }

    if k == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        var val i64 = interp_expr(unary_expr_expr(expr));

        if op == TOKEN_MINUS { return 0 - val; }
        if op == TOKEN_BANG { if val == 0 { return 1; } return 0; }
        return 0;
    }

    if k == NODE_GROUP_EXPR {
        return interp_expr(group_expr_expr(expr));
    }

    // Quote expression: expand unquotes and return the resulting AST
    if k == NODE_QUOTE_EXPR {
        var inner *u8 = quote_expr_expr(expr);
        // Expand any unquotes inside the quote
        var expanded *u8 = expand_quote(inner);
        return expanded;
    }

    // Unquote expression: look up the binding and return the AST pointer
    if k == NODE_UNQUOTE_EXPR {
        var name *u8 = unquote_expr_name(expr);
        var name_len i64 = unquote_expr_name_len(expr);
        return interp_find_binding(name, name_len);
    }

    // Call expression: check for compile-time builtins
    if k == NODE_CALL_EXPR {
        var func_node *u8 = call_expr_func(expr);
        if node_kind(func_node) == NODE_IDENT_EXPR {
            var fname *u8 = ident_expr_name(func_node);
            var fname_len i64 = ident_expr_name_len(func_node);

            // Check for ast_to_string builtin
            if fname_len == 13 && memcmp(fname, "ast_to_string", 13) {
                var args *u8 = call_expr_args(expr);
                var arg_count i64 = call_expr_arg_count(expr);
                if arg_count >= 1 {
                    var arg_ptr **u8 = args;
                    var arg_ast *u8 = interp_expr(*arg_ptr);
                    return ast_to_string(arg_ast);
                }
                return 0;
            }

        }
        return 0;
    }

    return 0;
}

func interp_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }
    if interp_has_returned {
        return;
    }

    var k i64 = node_kind(stmt);

    if k == NODE_EXPR_STMT {
        interp_expr(expr_stmt_expr(stmt));
        return;
    }

    if k == NODE_VAR_DECL {
        var name *u8 = var_decl_name(stmt);
        var name_len i64 = var_decl_name_len(stmt);
        var init *u8 = var_decl_init(stmt);
        var value i64 = 0;
        if init != nil {
            value = interp_expr(init);
        }
        interp_add_binding(name, name_len, value);
        return;
    }

    if k == NODE_RETURN_STMT {
        var value *u8 = return_stmt_value(stmt);
        if value != nil {
            interp_return_value = interp_expr(value);
        }
        interp_has_returned = 1;
        return;
    }

    if k == NODE_IF_STMT {
        var cond i64 = interp_expr(if_stmt_cond(stmt));
        if cond != 0 {
            interp_stmt(if_stmt_then(stmt));
        } else {
            var else_branch *u8 = if_stmt_else(stmt);
            if else_branch != nil {
                interp_stmt(else_branch);
            }
        }
        return;
    }

    if k == NODE_WHILE_STMT {
        while !interp_has_returned {
            var cond i64 = interp_expr(while_stmt_cond(stmt));
            if cond == 0 {
                return;
            }
            interp_stmt(while_stmt_body(stmt));
        }
        return;
    }

    if k == NODE_BLOCK_STMT {
        var stmts *u8 = block_stmt_stmts(stmt);
        var count i64 = block_stmt_count(stmt);
        var saved_count i64 = interp_binding_count;

        var i i64 = 0;
        while i < count && !interp_has_returned {
            var s **u8 = stmts + (i * 8);
            interp_stmt(*s);
            i = i + 1;
        }

        // Restore binding count (pop local vars)
        interp_binding_count = saved_count;
        return;
    }
}

// ============================================================
// ast_to_string - convert AST to string (compile-time builtin)
// ============================================================

// Buffer for building AST string
var ast_str_buf *u8 = nil;
var ast_str_pos i64 = 0;
var ast_str_cap i64 = 0;

func ast_str_init() void {
    if ast_str_buf == nil {
        ast_str_cap = 65536;
        ast_str_buf = alloc(ast_str_cap);
    }
    ast_str_pos = 0;
}

func ast_str_append_char(c u8) void {
    if ast_str_pos < ast_str_cap - 1 {
        *(ast_str_buf + ast_str_pos) = c;
        ast_str_pos = ast_str_pos + 1;
    }
}

func ast_str_append(s *u8, len i64) void {
    var i i64 = 0;
    while i < len {
        ast_str_append_char(*(s + i));
        i = i + 1;
    }
}

func ast_str_append_cstr(s *u8) void {
    while *s != 0 {
        ast_str_append_char(*s);
        s = s + 1;
    }
}

func ast_str_finish() *u8 {
    *(ast_str_buf + ast_str_pos) = 0;
    // Duplicate the string so caller owns it
    var result *u8 = str_dup(ast_str_buf);
    return result;
}

func ast_to_string_expr(expr *u8) void {
    if expr == nil {
        ast_str_append_cstr("nil");
        return;
    }

    var kind i64 = node_kind(expr);

    if kind == NODE_NUMBER_EXPR {
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        ast_str_append(ptr, len);
        return;
    }

    if kind == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        ast_str_append(name, name_len);
        return;
    }

    if kind == NODE_STRING_EXPR {
        // String value already includes quotes from lexer
        var s *u8 = string_expr_value(expr);
        var s_len i64 = string_expr_value_len(expr);
        ast_str_append(s, s_len);
        return;
    }

    if kind == NODE_BOOL_EXPR {
        if bool_expr_value(expr) != 0 {
            ast_str_append_cstr("true");
        } else {
            ast_str_append_cstr("false");
        }
        return;
    }

    if kind == NODE_NIL_EXPR {
        ast_str_append_cstr("nil");
        return;
    }

    if kind == NODE_GROUP_EXPR {
        ast_str_append_char(40);  // (
        ast_to_string_expr(group_expr_expr(expr));
        ast_str_append_char(41);  // )
        return;
    }

    if kind == NODE_BINARY_EXPR {
        var op i64 = binary_expr_op(expr);
        // Assignment doesn't need parens
        if op == TOKEN_EQ {
            ast_to_string_expr(binary_expr_left(expr));
            ast_str_append_cstr(" = ");
            ast_to_string_expr(binary_expr_right(expr));
            return;
        }
        ast_str_append_char(40);  // (
        ast_to_string_expr(binary_expr_left(expr));
        ast_str_append_char(32);  // space
        if op == TOKEN_PLUS { ast_str_append_cstr("+"); }
        else if op == TOKEN_MINUS { ast_str_append_cstr("-"); }
        else if op == TOKEN_STAR { ast_str_append_cstr("*"); }
        else if op == TOKEN_SLASH { ast_str_append_cstr("/"); }
        else if op == TOKEN_PERCENT { ast_str_append_cstr("%"); }
        else if op == TOKEN_EQEQ { ast_str_append_cstr("=="); }
        else if op == TOKEN_BANGEQ { ast_str_append_cstr("!="); }
        else if op == TOKEN_LT { ast_str_append_cstr("<"); }
        else if op == TOKEN_GT { ast_str_append_cstr(">"); }
        else if op == TOKEN_LTEQ { ast_str_append_cstr("<="); }
        else if op == TOKEN_GTEQ { ast_str_append_cstr(">="); }
        else if op == TOKEN_AMPAMP { ast_str_append_cstr("&&"); }
        else if op == TOKEN_PIPEPIPE { ast_str_append_cstr("||"); }
        else { ast_str_append_cstr("?op?"); }
        ast_str_append_char(32);  // space
        ast_to_string_expr(binary_expr_right(expr));
        ast_str_append_char(41);  // )
        return;
    }

    if kind == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_MINUS { ast_str_append_cstr("-"); }
        else if op == TOKEN_BANG { ast_str_append_cstr("!"); }
        else if op == TOKEN_STAR { ast_str_append_cstr("*"); }
        else if op == TOKEN_AMP { ast_str_append_cstr("&"); }
        ast_to_string_expr(unary_expr_expr(expr));
        return;
    }

    if kind == NODE_CALL_EXPR {
        ast_to_string_expr(call_expr_func(expr));
        ast_str_append_char(40);  // (
        var args *u8 = call_expr_args(expr);
        var count i64 = call_expr_arg_count(expr);
        var i i64 = 0;
        while i < count {
            if i > 0 { ast_str_append_cstr(", "); }
            var arg_ptr **u8 = args + (i * 8);
            ast_to_string_expr(*arg_ptr);
            i = i + 1;
        }
        ast_str_append_char(41);  // )
        return;
    }

    if kind == NODE_FIELD_EXPR {
        ast_to_string_expr(field_expr_expr(expr));
        ast_str_append_char(46);  // .
        var fname *u8 = field_expr_field(expr);
        var fname_len i64 = field_expr_field_len(expr);
        ast_str_append(fname, fname_len);
        return;
    }

    ast_str_append_cstr("<expr>");
}

func ast_to_string_type(type_node *u8) void {
    if type_node == nil {
        ast_str_append_cstr("void");
        return;
    }
    var kind i64 = type_kind(type_node);
    if kind == TYPE_PTR {
        ast_str_append_char(42);  // *
        ast_to_string_type(ptr_type_elem(type_node));
        return;
    }
    // Primitive type - get the name
    var name *u8 = base_type_name(type_node);
    var name_len i64 = base_type_name_len(type_node);
    ast_str_append(name, name_len);
}

func ast_to_string_stmt(stmt *u8) void {
    if stmt == nil {
        return;
    }

    var kind i64 = node_kind(stmt);

    if kind == NODE_BLOCK_STMT {
        ast_str_append_cstr("{\n");
        var stmts *u8 = block_stmt_stmts(stmt);
        var count i64 = block_stmt_count(stmt);
        var i i64 = 0;
        while i < count {
            var s_ptr **u8 = stmts + (i * 8);
            ast_str_append_cstr("    ");
            ast_to_string_stmt(*s_ptr);
            i = i + 1;
        }
        ast_str_append_cstr("}\n");
        return;
    }

    if kind == NODE_VAR_DECL {
        ast_str_append_cstr("var ");
        var name *u8 = var_decl_name(stmt);
        var name_len i64 = var_decl_name_len(stmt);
        ast_str_append(name, name_len);
        ast_str_append_char(32);  // space
        ast_to_string_type(var_decl_type(stmt));
        var init *u8 = var_decl_init(stmt);
        if init != nil {
            ast_str_append_cstr(" = ");
            ast_to_string_expr(init);
        }
        ast_str_append_cstr(";\n");
        return;
    }

    if kind == NODE_RETURN_STMT {
        ast_str_append_cstr("return");
        var value *u8 = return_stmt_value(stmt);
        if value != nil {
            ast_str_append_char(32);
            ast_to_string_expr(value);
        }
        ast_str_append_cstr(";\n");
        return;
    }

    if kind == NODE_EXPR_STMT {
        ast_to_string_expr(expr_stmt_expr(stmt));
        ast_str_append_cstr(";\n");
        return;
    }

    if kind == NODE_IF_STMT {
        ast_str_append_cstr("if ");
        ast_to_string_expr(if_stmt_cond(stmt));
        ast_str_append_char(32);
        ast_to_string_stmt(if_stmt_then(stmt));
        var else_branch *u8 = if_stmt_else(stmt);
        if else_branch != nil {
            ast_str_append_cstr(" else ");
            ast_to_string_stmt(else_branch);
        }
        return;
    }

    if kind == NODE_WHILE_STMT {
        ast_str_append_cstr("while ");
        ast_to_string_expr(while_stmt_cond(stmt));
        ast_str_append_char(32);
        ast_to_string_stmt(while_stmt_body(stmt));
        return;
    }

    ast_str_append_cstr("/* unknown stmt */\n");
}

func ast_to_string_block(block *u8) *u8 {
    ast_str_init();
    ast_to_string_stmt(block);
    return ast_str_finish();
}

func ast_to_string(expr *u8) *u8 {
    ast_str_init();
    ast_to_string_expr(expr);
    return ast_str_finish();
}

// ============================================================
// AST-to-string for declarations (for reader includes)
// ============================================================

func ast_to_string_func_decl(decl *u8) void {
    ast_str_append_cstr("func ");
    var name *u8 = func_decl_name(decl);
    var name_len i64 = func_decl_name_len(decl);
    ast_str_append(name, name_len);
    ast_str_append_char(40);  // (

    // Parameters
    var params *u8 = func_decl_params(decl);
    var param_count i64 = func_decl_param_count(decl);
    var i i64 = 0;
    while i < param_count {
        if i > 0 { ast_str_append_cstr(", "); }
        var p *u8 = params + (i * 24);
        ast_str_append(param_name(p), param_name_len(p));
        ast_str_append_char(32);  // space
        ast_to_string_type(param_type(p));
        i = i + 1;
    }

    ast_str_append_cstr(") ");
    ast_to_string_type(func_decl_ret_type(decl));
    ast_str_append_char(32);  // space
    ast_to_string_stmt(func_decl_body(decl));
}

func ast_to_string_struct_decl(decl *u8) void {
    ast_str_append_cstr("struct ");
    ast_str_append(struct_decl_name(decl), struct_decl_name_len(decl));
    ast_str_append_cstr(" {\n");

    var fields *u8 = struct_decl_fields(decl);
    var field_count i64 = struct_decl_field_count(decl);
    var i i64 = 0;
    while i < field_count {
        var f *u8 = fields + (i * 24);
        ast_str_append_cstr("    ");
        ast_str_append(param_name(f), param_name_len(f));
        ast_str_append_char(32);  // space
        ast_to_string_type(param_type(f));
        ast_str_append_cstr(";\n");
        i = i + 1;
    }

    ast_str_append_cstr("}\n");
}

func ast_to_string_include_decl(decl *u8) void {
    ast_str_append_cstr("include \"");
    var path *u8 = include_decl_path(decl);
    var path_len i64 = include_decl_path_len(decl);
    ast_str_append(path, path_len);
    ast_str_append_cstr("\"\n");
}

// ============================================================
// AST printing (for --expand-macros debug flag)
// ============================================================

func print_expr_ast(expr *u8) void {
    if expr == nil {
        eprint("nil");
        return;
    }

    var kind i64 = node_kind(expr);

    if kind == NODE_NUMBER_EXPR {
        var ptr *u8 = number_expr_value(expr);
        var len i64 = number_expr_value_len(expr);
        eprint_buf(ptr, len);
        return;
    }

    if kind == NODE_IDENT_EXPR {
        var name *u8 = ident_expr_name(expr);
        var name_len i64 = ident_expr_name_len(expr);
        eprint_buf(name, name_len);
        return;
    }

    if kind == NODE_STRING_EXPR {
        eprint("\"");
        var s *u8 = string_expr_value(expr);
        var s_len i64 = string_expr_value_len(expr);
        eprint_buf(s, s_len);
        eprint("\"");
        return;
    }

    if kind == NODE_BOOL_EXPR {
        if bool_expr_value(expr) != 0 {
            eprint("true");
        } else {
            eprint("false");
        }
        return;
    }

    if kind == NODE_NIL_EXPR {
        eprint("nil");
        return;
    }

    if kind == NODE_GROUP_EXPR {
        eprint("(");
        print_expr_ast(group_expr_expr(expr));
        eprint(")");
        return;
    }

    if kind == NODE_BINARY_EXPR {
        eprint("(");
        print_expr_ast(binary_expr_left(expr));
        eprint(" ");
        var op i64 = binary_expr_op(expr);
        if op == TOKEN_PLUS { eprint("+"); }
        else if op == TOKEN_MINUS { eprint("-"); }
        else if op == TOKEN_STAR { eprint("*"); }
        else if op == TOKEN_SLASH { eprint("/"); }
        else if op == TOKEN_PERCENT { eprint("%"); }
        else if op == TOKEN_EQEQ { eprint("=="); }
        else if op == TOKEN_BANGEQ { eprint("!="); }
        else if op == TOKEN_LT { eprint("<"); }
        else if op == TOKEN_GT { eprint(">"); }
        else if op == TOKEN_LTEQ { eprint("<="); }
        else if op == TOKEN_GTEQ { eprint(">="); }
        else if op == TOKEN_AMPAMP { eprint("&&"); }
        else if op == TOKEN_PIPEPIPE { eprint("||"); }
        else { eprint("?op?"); }
        eprint(" ");
        print_expr_ast(binary_expr_right(expr));
        eprint(")");
        return;
    }

    if kind == NODE_UNARY_EXPR {
        var op i64 = unary_expr_op(expr);
        if op == TOKEN_MINUS { eprint("-"); }
        else if op == TOKEN_BANG { eprint("!"); }
        else if op == TOKEN_STAR { eprint("*"); }
        else if op == TOKEN_AMP { eprint("&"); }
        print_expr_ast(unary_expr_expr(expr));
        return;
    }

    if kind == NODE_CALL_EXPR {
        print_expr_ast(call_expr_func(expr));
        eprint("(");
        var args *u8 = call_expr_args(expr);
        var count i64 = call_expr_arg_count(expr);
        var i i64 = 0;
        while i < count {
            if i > 0 { eprint(", "); }
            var arg_ptr **u8 = args + (i * 8);
            print_expr_ast(*arg_ptr);
            i = i + 1;
        }
        eprint(")");
        return;
    }

    if kind == NODE_INDEX_EXPR {
        eprint("<index-expr>");
        return;
    }

    if kind == NODE_FIELD_EXPR {
        print_expr_ast(field_expr_expr(expr));
        eprint(".");
        var fname *u8 = field_expr_field(expr);
        var fname_len i64 = field_expr_field_len(expr);
        eprint_buf(fname, fname_len);
        return;
    }

    eprint("<unknown-expr>");
}

// Call a macro with arguments (AST nodes)
// Returns the resulting AST
func interp_call_macro(macro_decl *u8, args *u8, arg_count i64) *u8 {
    interp_init();

    // Bind parameters to arguments
    var macro_params *u8 = macro_decl_params(macro_decl);
    var num_params i64 = macro_decl_param_count(macro_decl);

    var i i64 = 0;
    while i < num_params && i < arg_count {
        var p *u8 = macro_params + (i * 24);
        var pname *u8 = param_name(p);
        var pname_len i64 = param_name_len(p);

        // Get the argument AST pointer
        var arg_ptr **u8 = args + (i * 8);
        var arg *u8 = *arg_ptr;

        // Bind parameter to argument AST (as pointer value)
        interp_add_binding(pname, pname_len, arg);
        i = i + 1;
    }

    // Execute macro body
    var macro_body *u8 = macro_decl_body(macro_decl);
    interp_stmt(macro_body);

    // Return the result (should be an AST pointer)
    return interp_return_value;
}

// ============================================================
// Process execution for V2 reader macros
// ============================================================

// Execute a program with input, capture stdout
// Returns: bytes written to output buffer (-1 on error)
func exec_capture(program *u8, input *u8, input_len i64, output *u8, output_cap i64) i64 {
    // Create pipes - pipe() writes two i32 file descriptors
    var stdin_pipe *u8 = alloc(8);
    var stdout_pipe *u8 = alloc(8);

    if syscall(22, stdin_pipe) < 0 {
        return 0 - 1;
    }
    if syscall(22, stdout_pipe) < 0 {
        return 0 - 1;
    }

    // Read fds as i32 (pipe returns int, not int64)
    var p1 *i32 = stdin_pipe;
    var p2 *i32 = stdin_pipe + 4;
    var p3 *i32 = stdout_pipe;
    var p4 *i32 = stdout_pipe + 4;
    var stdin_read i64 = *p1;
    var stdin_write i64 = *p2;
    var stdout_read i64 = *p3;
    var stdout_write i64 = *p4;

    // syscall 57 = fork
    var pid i64 = syscall(57);

    if pid < 0 {
        return 0 - 1;
    }

    if pid == 0 {
        // Child process
        // Redirect stdin: dup2(stdin_read, 0)
        syscall(33, stdin_read, 0);
        // Redirect stdout: dup2(stdout_write, 1)
        syscall(33, stdout_write, 1);
        // Close all pipe fds
        syscall(3, stdin_read);
        syscall(3, stdin_write);
        syscall(3, stdout_read);
        syscall(3, stdout_write);

        // Build argv: [program, NULL]
        var argv *u8 = alloc(16);
        var ap **u8 = argv;
        *ap = program;
        var ap2 **u8 = argv + 8;
        *ap2 = nil;

        // Build envp: [NULL]
        var envp *u8 = alloc(8);
        var ep **u8 = envp;
        *ep = nil;

        // syscall 59 = execve
        syscall(59, program, argv, envp);
        // If execve fails, exit
        syscall(60, 127);
    }

    // Parent process
    // Close child's ends of pipes
    syscall(3, stdin_read);
    syscall(3, stdout_write);

    // Write input to child's stdin, then close
    if input_len > 0 {
        syscall(1, stdin_write, input, input_len);
    }
    syscall(3, stdin_write);

    // Read output from child's stdout
    var total i64 = 0;
    var n i64 = syscall(0, stdout_read, output, output_cap - 1);
    while n > 0 {
        total = total + n;
        if total >= output_cap - 1 {
            n = 0;
        } else {
            n = syscall(0, stdout_read, output + total, output_cap - 1 - total);
        }
    }
    syscall(3, stdout_read);

    // Null-terminate output
    *(output + total) = 0;

    // Wait for child
    var status *i64 = alloc(8);
    syscall(61, pid, status, 0, 0);

    return total;
}

func interp_call_reader(reader_decl *u8, content *u8, content_len i64) *u8 {
    interp_init();

    // Bind the text content to the reader's parameter
    var param_name *u8 = reader_decl_param_name(reader_decl);
    var param_len i64 = reader_decl_param_len(reader_decl);

    // The parameter is a pointer to the raw text content
    interp_add_binding(param_name, param_len, content);

    // Also bind the content length (param_name + "_len")
    // For now, readers just get the pointer - they can scan for delimiters

    // Execute reader body
    var reader_body *u8 = reader_decl_body(reader_decl);
    interp_stmt(reader_body);

    // Return the result (should be an AST pointer)
    return interp_return_value;
}

// ============================================================
// Program code generation
// ============================================================

func generate(prog *u8, out_path *u8) void {
    codegen_init();

    var decls *u8 = program_decls(prog);
    var decl_count i64 = program_decl_count(prog);

    // Store for interpreter function calls
    cg_decls = decls;
    cg_decl_count = decl_count;

    // Set current file context (for reader compilation)
    cg_current_file_decls = decls;
    cg_current_file_decl_count = decl_count;

    // First pass: collect structs, macros, readers, globals, and process includes
    var i i64 = 0;
    while i < decl_count {
        process_decl_first_pass(get_decl(decls, i));
        i = i + 1;
    }

    // Second pass: generate code (into buffer)
    i = 0;
    while i < decl_count {
        gen_decl(get_decl(decls, i));
        i = i + 1;
    }

    // Open output file (O_WRONLY | O_CREAT | O_TRUNC = 577, mode 0644 = 420)
    cg_out_fd = syscall(2, out_path, 577, 420);
    if cg_out_fd < 0 {
        eprintln("Error: cannot open output file");
        return;
    }

    // Data section
    out_line(".section .data");

    // String literals
    i = 0;
    while i < cg_string_count {
        out_str(".str");
        out_int(i);
        out_line(":");
        out_str("    .ascii ");
        write_ascii_string(string_get_ptr(i), string_get_len(i));
        out_char(10);
        i = i + 1;
    }

    // Global variables
    i = 0;
    while i < cg_global_count {
        out_n(global_get_name(i), global_get_name_len(i));
        out_line(":");
        out_str("    .quad ");
        out_int(eval_constant(global_get_init(i)));
        out_char(10);
        i = i + 1;
    }

    // Text section
    out_char(10);
    out_line(".section .text");
    out_line(".globl _start");
    out_line("_start:");
    // Get argc and argv from stack
    out_line("    mov (%rsp), %rdi");     // argc
    out_line("    lea 8(%rsp), %rsi");    // argv
    out_line("    call main");
    out_line("    mov %rax, %rdi");
    out_line("    mov $60, %rax");
    out_line("    syscall");
    out_char(10);

    // Write code buffer
    file_write(cg_out_fd, cg_code_buf, cg_code_len);

    file_close(cg_out_fd);
}

func write_ascii_string(ptr *u8, len i64) void {
    // Skip quotes in original string
    var start *u8 = ptr + 1;
    var end i64 = len - 2;

    out_char(34);  // opening quote

    var i i64 = 0;
    while i < end {
        var c u8 = *(start + i);

        if c == 92 && i + 1 < end {  // backslash escape
            i = i + 1;
            var next u8 = *(start + i);
            if next == 110 {  // 'n'
                out_str("\\012");
            } else if next == 116 {  // 't'
                out_str("\\011");
            } else if next == 114 {  // 'r'
                out_str("\\015");
            } else if next == 92 {  // '\'
                out_str("\\\\");
            } else if next == 34 {  // '"'
                out_str("\\\"");
            } else if next == 48 {  // '0'
                out_str("\\000");
            } else {
                out_char(next);
            }
        } else if c >= 32 && c < 127 && c != 34 && c != 92 {
            out_char(c);
        } else {
            // Octal escape
            out_char(92);  // '\'
            out_char(48 + (c / 64));
            out_char(48 + ((c / 8) % 8));
            out_char(48 + (c % 8));
        }
        i = i + 1;
    }

    out_str("\\000");  // null terminator
    out_char(34);  // closing quote
}
