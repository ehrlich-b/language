// src/parser.lang - Parser for self-hosting compiler
// Recursive descent parser with precedence climbing for expressions

include "src/limits.lang"

// ============================================================
// AST Node Types (constants)
// ============================================================

// Node kinds
var NODE_FUNC_DECL i64 = 1;
var NODE_VAR_DECL i64 = 2;
var NODE_STRUCT_DECL i64 = 3;
var NODE_BLOCK_STMT i64 = 4;
var NODE_IF_STMT i64 = 5;
var NODE_WHILE_STMT i64 = 6;
var NODE_RETURN_STMT i64 = 7;
var NODE_EXPR_STMT i64 = 8;
var NODE_BINARY_EXPR i64 = 9;
var NODE_UNARY_EXPR i64 = 10;
var NODE_CALL_EXPR i64 = 11;
var NODE_INDEX_EXPR i64 = 12;
var NODE_FIELD_EXPR i64 = 13;
var NODE_IDENT_EXPR i64 = 14;
var NODE_NUMBER_EXPR i64 = 15;
var NODE_STRING_EXPR i64 = 16;
var NODE_BOOL_EXPR i64 = 17;
var NODE_NIL_EXPR i64 = 18;
var NODE_GROUP_EXPR i64 = 19;

// Macro-related nodes
var NODE_QUOTE_EXPR i64 = 20;     // ${ expr } - quoted expression
var NODE_UNQUOTE_EXPR i64 = 21;   // $name - unquote (splice AST)
var NODE_MACRO_DECL i64 = 22;     // macro definition
var NODE_UNQUOTE_STRING_EXPR i64 = 23;  // $@name - unquote string as string literal

// Reader macro nodes
var NODE_IMPORT i64 = 24;         // import "path"
var NODE_READER_DECL i64 = 25;    // reader name(text) { }
var NODE_READER_EXPR i64 = 26;    // #name{content} - reader macro invocation
var NODE_INCLUDE_DECL i64 = 27;   // include "path"
var NODE_BREAK_STMT i64 = 28;     // break
var NODE_CONTINUE_STMT i64 = 29;  // continue
var NODE_LET_EXPR i64 = 30;       // let x = init in body
var NODE_ASSIGN_STMT i64 = 31;    // target = value (explicit assignment)
var NODE_LAMBDA_EXPR i64 = 32;    // |params| { body } - lambda expression

// Sum type nodes
var NODE_ENUM_DECL i64 = 33;      // enum Name { Variant1, Variant2(Type) }
var NODE_MATCH_EXPR i64 = 34;     // match expr { Pattern => body, ... }
var NODE_PATTERN_VARIANT i64 = 35; // EnumName.Variant or EnumName.Variant(binding)
var NODE_PATTERN_WILDCARD i64 = 36; // _ (matches anything)

// Algebraic effect nodes
var NODE_EFFECT_DECL i64 = 37;    // effect Name(params) ReturnType
var NODE_PERFORM_EXPR i64 = 38;   // perform Effect(args)
var NODE_HANDLE_EXPR i64 = 39;    // handle { expr } with { cases }
var NODE_RESUME_EXPR i64 = 40;    // resume k(value) - for future use
var NODE_BLOCK_EXPR i64 = 41;     // { stmts; tail_expr } - block as expression

// Type kinds
var TYPE_BASE i64 = 1;
var TYPE_PTR i64 = 2;
var TYPE_ARRAY i64 = 3;
var TYPE_FUNC i64 = 4;    // fn(T1, T2) R
var TYPE_CLOSURE i64 = 5; // closure(T1, T2) R (can capture)

// ============================================================
// AST Node layouts (all nodes start with kind field)
// ============================================================

// Generic node header: [kind:8]
// All nodes start with this

// FuncDecl: [kind:8][name_ptr:8][name_len:8][params:8][param_count:8][ret_type:8][body:8] = 56 bytes
// VarDecl: [kind:8][name_ptr:8][name_len:8][type:8][init:8] = 40 bytes
// BlockStmt: [kind:8][stmts:8][stmt_count:8] = 24 bytes
// IfStmt: [kind:8][cond:8][then:8][else:8] = 32 bytes
// WhileStmt: [kind:8][cond:8][body:8][label_ptr:8][label_len:8] = 40 bytes
// BreakStmt: [kind:8][label_ptr:8][label_len:8] = 24 bytes
// ContinueStmt: [kind:8][label_ptr:8][label_len:8] = 24 bytes
// ReturnStmt: [kind:8][value:8] = 16 bytes
// ExprStmt: [kind:8][expr:8] = 16 bytes
// BinaryExpr: [kind:8][op:8][left:8][right:8] = 32 bytes
// UnaryExpr: [kind:8][op:8][expr:8] = 24 bytes
// CallExpr: [kind:8][func:8][args:8][arg_count:8] = 32 bytes
// IndexExpr: [kind:8][expr:8][index:8] = 24 bytes
// FieldExpr: [kind:8][expr:8][field_ptr:8][field_len:8] = 32 bytes
// IdentExpr: [kind:8][name_ptr:8][name_len:8] = 24 bytes
// NumberExpr: [kind:8][value_ptr:8][value_len:8] = 24 bytes
// StringExpr: [kind:8][value_ptr:8][value_len:8] = 24 bytes
// BoolExpr: [kind:8][value:8] = 16 bytes
// NilExpr: [kind:8] = 8 bytes
// GroupExpr: [kind:8][expr:8] = 16 bytes

// Macro-related:
// QuoteExpr: [kind:8][expr:8] = 16 bytes
// UnquoteExpr: [kind:8][name_ptr:8][name_len:8] = 24 bytes
// MacroDecl: [kind:8][name_ptr:8][name_len:8][params:8][param_count:8][body:8] = 48 bytes

// Let expression (2.0):
// LetExpr: [kind:8][name_ptr:8][name_len:8][type:8][init:8][body:8] = 48 bytes

// Lambda expression (2.0):
// LambdaExpr: [kind:8][params:8][param_count:8][ret_type:8][body:8] = 40 bytes

// Type layouts:
// BaseType: [kind:8][name_ptr:8][name_len:8] = 24 bytes
// PtrType: [kind:8][elem:8] = 16 bytes
// ArrayType: [kind:8][size:8][elem:8] = 24 bytes
// FuncType: [kind:8][params:8][param_count:8][ret:8] = 32 bytes
// ClosureType: [kind:8][params:8][param_count:8][ret:8] = 32 bytes (same layout)

// Param: [name_ptr:8][name_len:8][type:8] = 24 bytes

// ============================================================
// Helper functions
// ============================================================

// Compare buffer with length against null-terminated string
func buf_eq_str(buf *u8, len i64, str *u8) i64 {
    var i i64 = 0;
    while i < len {
        var c u8 = *(str + i);
        if c == 0 { return 0; }  // str is shorter than buf
        if *(buf + i) != c { return 0; }
        i = i + 1;
    }
    // Check that str has ended
    if *(str + i) != 0 { return 0; }
    return 1;
}

// ============================================================
// Node accessor functions
// ============================================================

func node_kind(node *u8) i64 {
    var p *i64 = node;
    return *p;
}

func node_set_kind(node *u8, k i64) void {
    var p *i64 = node;
    *p = k;
}

// ============================================================
// FuncDecl accessors
// ============================================================

func func_decl_alloc() *u8 {
    var node *u8 = alloc(64);
    node_set_kind(node, NODE_FUNC_DECL);
    return node;
}

func func_decl_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func func_decl_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func func_decl_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func func_decl_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func func_decl_params(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func func_decl_set_params(node *u8, params *u8) void {
    var p **u8 = node + 24;
    *p = params;
}

func func_decl_param_count(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func func_decl_set_param_count(node *u8, count i64) void {
    var p *i64 = node + 32;
    *p = count;
}

func func_decl_ret_type(node *u8) *u8 {
    var p **u8 = node + 40;
    return *p;
}

func func_decl_set_ret_type(node *u8, t *u8) void {
    var p **u8 = node + 40;
    *p = t;
}

func func_decl_body(node *u8) *u8 {
    var p **u8 = node + 48;
    return *p;
}

func func_decl_set_body(node *u8, body *u8) void {
    var p **u8 = node + 48;
    *p = body;
}

func func_decl_is_extern(node *u8) i64 {
    var p *i64 = node + 56;
    return *p;
}

func func_decl_set_is_extern(node *u8, is_extern i64) void {
    var p *i64 = node + 56;
    *p = is_extern;
}

// ============================================================
// VarDecl accessors
// ============================================================

func var_decl_alloc() *u8 {
    var node *u8 = alloc(48);
    node_set_kind(node, NODE_VAR_DECL);
    return node;
}

func var_decl_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func var_decl_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func var_decl_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func var_decl_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func var_decl_type(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func var_decl_set_type(node *u8, t *u8) void {
    var p **u8 = node + 24;
    *p = t;
}

func var_decl_init(node *u8) *u8 {
    var p **u8 = node + 32;
    return *p;
}

func var_decl_set_init(node *u8, init *u8) void {
    var p **u8 = node + 32;
    *p = init;
}

func var_decl_is_extern(node *u8) i64 {
    var p *i64 = node + 40;
    return *p;
}

func var_decl_set_is_extern(node *u8, is_extern i64) void {
    var p *i64 = node + 40;
    *p = is_extern;
}

// ============================================================
// StructDecl accessors
// ============================================================
// StructDecl: [kind:8][name_ptr:8][name_len:8][fields:8][field_count:8] = 40 bytes
// StructField: [name_ptr:8][name_len:8][type:8] = 24 bytes (same as Param)

func struct_decl_alloc() *u8 {
    var node *u8 = alloc(40);
    node_set_kind(node, NODE_STRUCT_DECL);
    return node;
}

func struct_decl_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func struct_decl_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func struct_decl_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func struct_decl_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func struct_decl_fields(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func struct_decl_set_fields(node *u8, fields *u8) void {
    var p **u8 = node + 24;
    *p = fields;
}

func struct_decl_field_count(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func struct_decl_set_field_count(node *u8, count i64) void {
    var p *i64 = node + 32;
    *p = count;
}

// StructField accessors (24-byte entries, same layout as Param)
func struct_field_name(field *u8) *u8 {
    var p **u8 = field;
    return *p;
}

func struct_field_set_name(field *u8, ptr *u8) void {
    var p **u8 = field;
    *p = ptr;
}

func struct_field_name_len(field *u8) i64 {
    var p *i64 = field + 8;
    return *p;
}

func struct_field_set_name_len(field *u8, len i64) void {
    var p *i64 = field + 8;
    *p = len;
}

func struct_field_type(field *u8) *u8 {
    var p **u8 = field + 16;
    return *p;
}

func struct_field_set_type(field *u8, t *u8) void {
    var p **u8 = field + 16;
    *p = t;
}

func get_struct_field(fields *u8, index i64) *u8 {
    return fields + (index * 24);
}

// ============================================================
// EnumDecl accessors
// ============================================================
// EnumDecl: [kind:8][name_ptr:8][name_len:8][variants:8][variant_count:8] = 40 bytes
// EnumVariant: [name_ptr:8][name_len:8][payload_type:8][tag:8] = 32 bytes

func enum_decl_alloc() *u8 {
    var node *u8 = alloc(40);
    node_set_kind(node, NODE_ENUM_DECL);
    return node;
}

func enum_decl_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func enum_decl_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func enum_decl_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func enum_decl_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func enum_decl_variants(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func enum_decl_set_variants(node *u8, variants *u8) void {
    var p **u8 = node + 24;
    *p = variants;
}

func enum_decl_variant_count(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func enum_decl_set_variant_count(node *u8, count i64) void {
    var p *i64 = node + 32;
    *p = count;
}

// EnumVariant accessors (32-byte entries)
func enum_variant_name(v *u8) *u8 {
    var p **u8 = v;
    return *p;
}

func enum_variant_set_name(v *u8, ptr *u8) void {
    var p **u8 = v;
    *p = ptr;
}

func enum_variant_name_len(v *u8) i64 {
    var p *i64 = v + 8;
    return *p;
}

func enum_variant_set_name_len(v *u8, len i64) void {
    var p *i64 = v + 8;
    *p = len;
}

func enum_variant_type(v *u8) *u8 {
    var p **u8 = v + 16;
    return *p;
}

func enum_variant_set_type(v *u8, t *u8) void {
    var p **u8 = v + 16;
    *p = t;
}

func enum_variant_tag(v *u8) i64 {
    var p *i64 = v + 24;
    return *p;
}

func enum_variant_set_tag(v *u8, tag i64) void {
    var p *i64 = v + 24;
    *p = tag;
}

func get_enum_variant(variants *u8, index i64) *u8 {
    return variants + (index * 32);
}

// ============================================================
// MatchExpr accessors
// Layout: [kind:8][scrutinee:8][arms:8][arm_count:8] = 32 bytes
// ============================================================

func match_expr_alloc() *u8 {
    var node *u8 = alloc(32);
    node_set_kind(node, NODE_MATCH_EXPR);
    return node;
}

func match_expr_scrutinee(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func match_expr_set_scrutinee(node *u8, expr *u8) void {
    var p **u8 = node + 8;
    *p = expr;
}

func match_expr_arms(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func match_expr_set_arms(node *u8, arms *u8) void {
    var p **u8 = node + 16;
    *p = arms;
}

func match_expr_arm_count(node *u8) i64 {
    var p *i64 = node + 24;
    return *p;
}

func match_expr_set_arm_count(node *u8, count i64) void {
    var p *i64 = node + 24;
    *p = count;
}

// MatchArm layout: [pattern:8][body:8] = 16 bytes
func get_match_arm(arms *u8, index i64) *u8 {
    return arms + (index * 16);
}

func match_arm_pattern(arm *u8) *u8 {
    var p **u8 = arm;
    return *p;
}

func match_arm_set_pattern(arm *u8, pattern *u8) void {
    var p **u8 = arm;
    *p = pattern;
}

func match_arm_body(arm *u8) *u8 {
    var p **u8 = arm + 8;
    return *p;
}

func match_arm_set_body(arm *u8, body *u8) void {
    var p **u8 = arm + 8;
    *p = body;
}

// ============================================================
// Pattern accessors
// PatternVariant: [kind:8][enum_name:8][enum_len:8][variant_name:8][variant_len:8][binding_name:8][binding_len:8] = 56 bytes
// PatternWildcard: [kind:8] = 8 bytes
// ============================================================

func pattern_variant_alloc() *u8 {
    var node *u8 = alloc(56);
    node_set_kind(node, NODE_PATTERN_VARIANT);
    return node;
}

func pattern_variant_enum_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func pattern_variant_set_enum_name(node *u8, name *u8) void {
    var p **u8 = node + 8;
    *p = name;
}

func pattern_variant_enum_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func pattern_variant_set_enum_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func pattern_variant_name(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func pattern_variant_set_name(node *u8, name *u8) void {
    var p **u8 = node + 24;
    *p = name;
}

func pattern_variant_name_len(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func pattern_variant_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 32;
    *p = len;
}

func pattern_variant_binding(node *u8) *u8 {
    var p **u8 = node + 40;
    return *p;
}

func pattern_variant_set_binding(node *u8, name *u8) void {
    var p **u8 = node + 40;
    *p = name;
}

func pattern_variant_binding_len(node *u8) i64 {
    var p *i64 = node + 48;
    return *p;
}

func pattern_variant_set_binding_len(node *u8, len i64) void {
    var p *i64 = node + 48;
    *p = len;
}

func pattern_wildcard_alloc() *u8 {
    var node *u8 = alloc(8);
    node_set_kind(node, NODE_PATTERN_WILDCARD);
    return node;
}

// ============================================================
// Effect node accessors
// ============================================================

// EffectDecl: [kind:8][name_ptr:8][name_len:8][param_types:8][param_type_count:8][return_type:8] = 48 bytes
// Example: effect Fail(i64) void

func effect_decl_alloc() *u8 {
    var node *u8 = alloc(48);
    node_set_kind(node, NODE_EFFECT_DECL);
    return node;
}

func effect_decl_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func effect_decl_set_name(node *u8, name *u8) void {
    var p **u8 = node + 8;
    *p = name;
}

func effect_decl_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func effect_decl_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func effect_decl_param_types(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func effect_decl_set_param_types(node *u8, params *u8) void {
    var p **u8 = node + 24;
    *p = params;
}

func effect_decl_param_type_count(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func effect_decl_set_param_type_count(node *u8, count i64) void {
    var p *i64 = node + 32;
    *p = count;
}

func effect_decl_return_type(node *u8) *u8 {
    var p **u8 = node + 40;
    return *p;
}

func effect_decl_set_return_type(node *u8, ret_type *u8) void {
    var p **u8 = node + 40;
    *p = ret_type;
}

// PerformExpr: [kind:8][effect_name_ptr:8][effect_name_len:8][args:8][arg_count:8] = 40 bytes
// Example: perform Fail(42)

func perform_expr_alloc() *u8 {
    var node *u8 = alloc(40);
    node_set_kind(node, NODE_PERFORM_EXPR);
    return node;
}

func perform_expr_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func perform_expr_set_name(node *u8, name *u8) void {
    var p **u8 = node + 8;
    *p = name;
}

func perform_expr_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func perform_expr_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func perform_expr_args(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func perform_expr_set_args(node *u8, args *u8) void {
    var p **u8 = node + 24;
    *p = args;
}

func perform_expr_arg_count(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func perform_expr_set_arg_count(node *u8, count i64) void {
    var p *i64 = node + 32;
    *p = count;
}

// HandleExpr: [kind:8][body:8][cases:8][case_count:8][ret_bind_ptr:8][ret_bind_len:8][ret_body:8] = 56 bytes
// Example: handle { expr } with { return(v) => v, Fail(e) => 0 }
// For exceptions (no resume), cases are [effect_name:8][effect_name_len:8][binding_ptr:8][binding_len:8][body:8] = 40 bytes

func handle_expr_alloc() *u8 {
    var node *u8 = alloc(56);
    node_set_kind(node, NODE_HANDLE_EXPR);
    return node;
}

func handle_expr_body(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func handle_expr_set_body(node *u8, body *u8) void {
    var p **u8 = node + 8;
    *p = body;
}

func handle_expr_cases(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func handle_expr_set_cases(node *u8, cases *u8) void {
    var p **u8 = node + 16;
    *p = cases;
}

func handle_expr_case_count(node *u8) i64 {
    var p *i64 = node + 24;
    return *p;
}

func handle_expr_set_case_count(node *u8, count i64) void {
    var p *i64 = node + 24;
    *p = count;
}

func handle_expr_ret_bind(node *u8) *u8 {
    var p **u8 = node + 32;
    return *p;
}

func handle_expr_set_ret_bind(node *u8, bind *u8) void {
    var p **u8 = node + 32;
    *p = bind;
}

func handle_expr_ret_bind_len(node *u8) i64 {
    var p *i64 = node + 40;
    return *p;
}

func handle_expr_set_ret_bind_len(node *u8, len i64) void {
    var p *i64 = node + 40;
    *p = len;
}

func handle_expr_ret_body(node *u8) *u8 {
    var p **u8 = node + 48;
    return *p;
}

func handle_expr_set_ret_body(node *u8, body *u8) void {
    var p **u8 = node + 48;
    *p = body;
}

// Effect case entry: [effect_name:8][effect_name_len:8][binding_ptr:8][binding_len:8][k_ptr:8][k_len:8][body:8] = 56 bytes
// Stored in a Vec
// Example: Fail(e, k) => body

func effect_case_name(entry *u8) *u8 {
    var p **u8 = entry;
    return *p;
}

func effect_case_name_len(entry *u8) i64 {
    var p *i64 = entry + 8;
    return *p;
}

func effect_case_binding(entry *u8) *u8 {
    var p **u8 = entry + 16;
    return *p;
}

func effect_case_binding_len(entry *u8) i64 {
    var p *i64 = entry + 24;
    return *p;
}

func effect_case_k(entry *u8) *u8 {
    var p **u8 = entry + 32;
    return *p;
}

func effect_case_k_len(entry *u8) i64 {
    var p *i64 = entry + 40;
    return *p;
}

func effect_case_body(entry *u8) *u8 {
    var p **u8 = entry + 48;
    return *p;
}

// ResumeExpr: [kind:8][k_expr:8][value:8] = 24 bytes
// Example: resume k(42)  (for future use)

func resume_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_RESUME_EXPR);
    return node;
}

func resume_expr_k(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func resume_expr_set_k(node *u8, k *u8) void {
    var p **u8 = node + 8;
    *p = k;
}

func resume_expr_value(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func resume_expr_set_value(node *u8, value *u8) void {
    var p **u8 = node + 16;
    *p = value;
}

// ============================================================
// BlockStmt accessors
// ============================================================

func block_stmt_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_BLOCK_STMT);
    return node;
}

func block_stmt_stmts(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func block_stmt_set_stmts(node *u8, stmts *u8) void {
    var p **u8 = node + 8;
    *p = stmts;
}

func block_stmt_count(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func block_stmt_set_count(node *u8, count i64) void {
    var p *i64 = node + 16;
    *p = count;
}

// ============================================================
// BlockExpr accessors (block as expression with tail value)
// Layout: [kind:8][stmts:8][stmt_count:8][tail_expr:8] = 32 bytes
// ============================================================

func block_expr_alloc() *u8 {
    var node *u8 = alloc(32);
    node_set_kind(node, NODE_BLOCK_EXPR);
    return node;
}

func block_expr_stmts(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func block_expr_set_stmts(node *u8, stmts *u8) void {
    var p **u8 = node + 8;
    *p = stmts;
}

func block_expr_count(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func block_expr_set_count(node *u8, count i64) void {
    var p *i64 = node + 16;
    *p = count;
}

func block_expr_tail(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func block_expr_set_tail(node *u8, tail *u8) void {
    var p **u8 = node + 24;
    *p = tail;
}

// ============================================================
// IfStmt accessors
// ============================================================

func if_stmt_alloc() *u8 {
    var node *u8 = alloc(32);
    node_set_kind(node, NODE_IF_STMT);
    return node;
}

func if_stmt_cond(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func if_stmt_set_cond(node *u8, cond *u8) void {
    var p **u8 = node + 8;
    *p = cond;
}

func if_stmt_then(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func if_stmt_set_then(node *u8, then *u8) void {
    var p **u8 = node + 16;
    *p = then;
}

func if_stmt_else(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func if_stmt_set_else(node *u8, els *u8) void {
    var p **u8 = node + 24;
    *p = els;
}

// ============================================================
// WhileStmt accessors
// ============================================================

func while_stmt_alloc() *u8 {
    var node *u8 = alloc(40);
    node_set_kind(node, NODE_WHILE_STMT);
    return node;
}

func while_stmt_cond(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func while_stmt_set_cond(node *u8, cond *u8) void {
    var p **u8 = node + 8;
    *p = cond;
}

func while_stmt_body(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func while_stmt_set_body(node *u8, body *u8) void {
    var p **u8 = node + 16;
    *p = body;
}

func while_stmt_label(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func while_stmt_set_label(node *u8, label *u8) void {
    var p **u8 = node + 24;
    *p = label;
}

func while_stmt_label_len(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func while_stmt_set_label_len(node *u8, len i64) void {
    var p *i64 = node + 32;
    *p = len;
}

// ============================================================
// BreakStmt accessors
// ============================================================

func break_stmt_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_BREAK_STMT);
    return node;
}

func break_stmt_label(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func break_stmt_set_label(node *u8, label *u8) void {
    var p **u8 = node + 8;
    *p = label;
}

func break_stmt_label_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func break_stmt_set_label_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// ContinueStmt accessors
// ============================================================

func continue_stmt_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_CONTINUE_STMT);
    return node;
}

func continue_stmt_label(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func continue_stmt_set_label(node *u8, label *u8) void {
    var p **u8 = node + 8;
    *p = label;
}

func continue_stmt_label_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func continue_stmt_set_label_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// ReturnStmt accessors
// ============================================================

func return_stmt_alloc() *u8 {
    var node *u8 = alloc(16);
    node_set_kind(node, NODE_RETURN_STMT);
    return node;
}

func return_stmt_value(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func return_stmt_set_value(node *u8, val *u8) void {
    var p **u8 = node + 8;
    *p = val;
}

// ============================================================
// ExprStmt accessors
// ============================================================

func expr_stmt_alloc() *u8 {
    var node *u8 = alloc(16);
    node_set_kind(node, NODE_EXPR_STMT);
    return node;
}

func expr_stmt_expr(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func expr_stmt_set_expr(node *u8, expr *u8) void {
    var p **u8 = node + 8;
    *p = expr;
}

// ============================================================
// AssignStmt accessors (AST 2.0)
// ============================================================
// AssignStmt: [kind:8][target:8][value:8] = 24 bytes

func assign_stmt_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_ASSIGN_STMT);
    return node;
}

func assign_stmt_target(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func assign_stmt_set_target(node *u8, target *u8) void {
    var p **u8 = node + 8;
    *p = target;
}

func assign_stmt_value(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func assign_stmt_set_value(node *u8, value *u8) void {
    var p **u8 = node + 16;
    *p = value;
}

// ============================================================
// BinaryExpr accessors
// ============================================================

func binary_expr_alloc() *u8 {
    var node *u8 = alloc(32);
    node_set_kind(node, NODE_BINARY_EXPR);
    return node;
}

func binary_expr_op(node *u8) i64 {
    var p *i64 = node + 8;
    return *p;
}

func binary_expr_set_op(node *u8, op i64) void {
    var p *i64 = node + 8;
    *p = op;
}

func binary_expr_left(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func binary_expr_set_left(node *u8, left *u8) void {
    var p **u8 = node + 16;
    *p = left;
}

func binary_expr_right(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func binary_expr_set_right(node *u8, right *u8) void {
    var p **u8 = node + 24;
    *p = right;
}

// ============================================================
// UnaryExpr accessors
// ============================================================

func unary_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_UNARY_EXPR);
    return node;
}

func unary_expr_op(node *u8) i64 {
    var p *i64 = node + 8;
    return *p;
}

func unary_expr_set_op(node *u8, op i64) void {
    var p *i64 = node + 8;
    *p = op;
}

func unary_expr_expr(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func unary_expr_set_expr(node *u8, expr *u8) void {
    var p **u8 = node + 16;
    *p = expr;
}

// ============================================================
// CallExpr accessors
// ============================================================

func call_expr_alloc() *u8 {
    var node *u8 = alloc(32);
    node_set_kind(node, NODE_CALL_EXPR);
    return node;
}

func call_expr_func(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func call_expr_set_func(node *u8, f *u8) void {
    var p **u8 = node + 8;
    *p = f;
}

func call_expr_args(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func call_expr_set_args(node *u8, args *u8) void {
    var p **u8 = node + 16;
    *p = args;
}

func call_expr_arg_count(node *u8) i64 {
    var p *i64 = node + 24;
    return *p;
}

func call_expr_set_arg_count(node *u8, count i64) void {
    var p *i64 = node + 24;
    *p = count;
}

// ============================================================
// IdentExpr accessors
// ============================================================

func ident_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_IDENT_EXPR);
    return node;
}

func ident_expr_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func ident_expr_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func ident_expr_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func ident_expr_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// FieldExpr accessors
// ============================================================
// FieldExpr: [kind:8][expr:8][field_ptr:8][field_len:8] = 32 bytes

func field_expr_expr(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func field_expr_field(node *u8) *u8 {
    var p **u8 = node + 16;
    return *p;
}

func field_expr_field_len(node *u8) i64 {
    var p *i64 = node + 24;
    return *p;
}

// ============================================================
// NumberExpr accessors
// ============================================================

func number_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_NUMBER_EXPR);
    return node;
}

func number_expr_value(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func number_expr_set_value(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func number_expr_value_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func number_expr_set_value_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// StringExpr accessors
// ============================================================

func string_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_STRING_EXPR);
    return node;
}

func string_expr_value(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func string_expr_set_value(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func string_expr_value_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func string_expr_set_value_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// BoolExpr accessors
// ============================================================

func bool_expr_alloc() *u8 {
    var node *u8 = alloc(16);
    node_set_kind(node, NODE_BOOL_EXPR);
    return node;
}

func bool_expr_value(node *u8) i64 {
    var p *i64 = node + 8;
    return *p;
}

func bool_expr_set_value(node *u8, val i64) void {
    var p *i64 = node + 8;
    *p = val;
}

// ============================================================
// NilExpr accessors
// ============================================================

func nil_expr_alloc() *u8 {
    var node *u8 = alloc(8);
    node_set_kind(node, NODE_NIL_EXPR);
    return node;
}

// ============================================================
// GroupExpr accessors
// ============================================================

func group_expr_alloc() *u8 {
    var node *u8 = alloc(16);
    node_set_kind(node, NODE_GROUP_EXPR);
    return node;
}

func group_expr_expr(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func group_expr_set_expr(node *u8, expr *u8) void {
    var p **u8 = node + 8;
    *p = expr;
}

// ============================================================
// QuoteExpr accessors: [kind:8][expr:8] = 16 bytes
// ============================================================

func quote_expr_alloc() *u8 {
    var node *u8 = alloc(16);
    node_set_kind(node, NODE_QUOTE_EXPR);
    return node;
}

func quote_expr_expr(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func quote_expr_set_expr(node *u8, expr *u8) void {
    var p **u8 = node + 8;
    *p = expr;
}

// ============================================================
// UnquoteExpr accessors: [kind:8][name_ptr:8][name_len:8] = 24 bytes
// ============================================================

func unquote_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_UNQUOTE_EXPR);
    return node;
}

func unquote_expr_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func unquote_expr_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func unquote_expr_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func unquote_expr_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// UnquoteStringExpr accessors: [kind:8][name_ptr:8][name_len:8] = 24 bytes
// ============================================================

func unquote_string_expr_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_UNQUOTE_STRING_EXPR);
    return node;
}

func unquote_string_expr_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func unquote_string_expr_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func unquote_string_expr_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func unquote_string_expr_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

// ============================================================
// MacroDecl accessors: [kind:8][name_ptr:8][name_len:8][params:8][param_count:8][body:8] = 48 bytes
// ============================================================

func macro_decl_alloc() *u8 {
    var node *u8 = alloc(48);
    node_set_kind(node, NODE_MACRO_DECL);
    return node;
}

func macro_decl_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func macro_decl_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func macro_decl_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func macro_decl_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func macro_decl_params(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func macro_decl_set_params(node *u8, params *u8) void {
    var p **u8 = node + 24;
    *p = params;
}

func macro_decl_param_count(node *u8) i64 {
    var p *i64 = node + 32;
    return *p;
}

func macro_decl_set_param_count(node *u8, count i64) void {
    var p *i64 = node + 32;
    *p = count;
}

func macro_decl_body(node *u8) *u8 {
    var p **u8 = node + 40;
    return *p;
}

func macro_decl_set_body(node *u8, body *u8) void {
    var p **u8 = node + 40;
    *p = body;
}

// ============================================================
// LetExpr accessors: [kind:8][name_ptr:8][name_len:8][type:8][init:8][body:8] = 48 bytes
// ============================================================

func let_expr_alloc() *u8 {
    var node *u8 = alloc(48);
    node_set_kind(node, NODE_LET_EXPR);
    return node;
}

func let_expr_name(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func let_expr_set_name(node *u8, ptr *u8) void {
    var p **u8 = node + 8;
    *p = ptr;
}

func let_expr_name_len(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func let_expr_set_name_len(node *u8, len i64) void {
    var p *i64 = node + 16;
    *p = len;
}

func let_expr_type(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func let_expr_set_type(node *u8, typ *u8) void {
    var p **u8 = node + 24;
    *p = typ;
}

func let_expr_init(node *u8) *u8 {
    var p **u8 = node + 32;
    return *p;
}

func let_expr_set_init(node *u8, init *u8) void {
    var p **u8 = node + 32;
    *p = init;
}

func let_expr_body(node *u8) *u8 {
    var p **u8 = node + 40;
    return *p;
}

func let_expr_set_body(node *u8, body *u8) void {
    var p **u8 = node + 40;
    *p = body;
}

// ============================================================
// LambdaExpr accessors (2.0)
// Layout: [kind:8][params:8][param_count:8][ret_type:8][body:8] = 40 bytes
// ============================================================

func lambda_expr_alloc() *u8 {
    var node *u8 = alloc(40);
    node_set_kind(node, NODE_LAMBDA_EXPR);
    return node;
}

func lambda_expr_params(node *u8) *u8 {
    var p **u8 = node + 8;
    return *p;
}

func lambda_expr_set_params(node *u8, params *u8) void {
    var p **u8 = node + 8;
    *p = params;
}

func lambda_expr_param_count(node *u8) i64 {
    var p *i64 = node + 16;
    return *p;
}

func lambda_expr_set_param_count(node *u8, count i64) void {
    var p *i64 = node + 16;
    *p = count;
}

func lambda_expr_ret_type(node *u8) *u8 {
    var p **u8 = node + 24;
    return *p;
}

func lambda_expr_set_ret_type(node *u8, typ *u8) void {
    var p **u8 = node + 24;
    *p = typ;
}

func lambda_expr_body(node *u8) *u8 {
    var p **u8 = node + 32;
    return *p;
}

func lambda_expr_set_body(node *u8, body *u8) void {
    var p **u8 = node + 32;
    *p = body;
}

// ============================================================
// ImportDecl struct
// ============================================================

struct ImportDecl {
    kind i64;
    path *u8;
    path_len i64;
}

func import_decl_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_IMPORT);
    return node;
}

func import_decl_path(node *u8) *u8 {
    var n *ImportDecl = node;
    return n.path;
}

func import_decl_set_path(node *u8, ptr *u8) void {
    var n *ImportDecl = node;
    n.path = ptr;
}

func import_decl_path_len(node *u8) i64 {
    var n *ImportDecl = node;
    return n.path_len;
}

func import_decl_set_path_len(node *u8, len i64) void {
    var n *ImportDecl = node;
    n.path_len = len;
}

// ============================================================
// ReaderDecl struct
// ============================================================

struct ReaderDecl {
    kind i64;
    name *u8;
    name_len i64;
    param_name *u8;
    param_len i64;
    body *u8;
}

func reader_decl_alloc() *u8 {
    var node *u8 = alloc(48);
    node_set_kind(node, NODE_READER_DECL);
    return node;
}

func reader_decl_name(node *u8) *u8 {
    var n *ReaderDecl = node;
    return n.name;
}

func reader_decl_set_name(node *u8, ptr *u8) void {
    var n *ReaderDecl = node;
    n.name = ptr;
}

func reader_decl_name_len(node *u8) i64 {
    var n *ReaderDecl = node;
    return n.name_len;
}

func reader_decl_set_name_len(node *u8, len i64) void {
    var n *ReaderDecl = node;
    n.name_len = len;
}

func reader_decl_param_name(node *u8) *u8 {
    var n *ReaderDecl = node;
    return n.param_name;
}

func reader_decl_set_param_name(node *u8, ptr *u8) void {
    var n *ReaderDecl = node;
    n.param_name = ptr;
}

func reader_decl_param_len(node *u8) i64 {
    var n *ReaderDecl = node;
    return n.param_len;
}

func reader_decl_set_param_len(node *u8, len i64) void {
    var n *ReaderDecl = node;
    n.param_len = len;
}

func reader_decl_body(node *u8) *u8 {
    var n *ReaderDecl = node;
    return n.body;
}

func reader_decl_set_body(node *u8, body *u8) void {
    var n *ReaderDecl = node;
    n.body = body;
}

// ============================================================
// ReaderExpr struct
// Stores the reader macro name and raw content
// ============================================================

struct ReaderExpr {
    kind i64;
    name *u8;
    name_len i64;
    content *u8;
    content_len i64;
}

func reader_expr_alloc() *u8 {
    var node *u8 = alloc(40);
    node_set_kind(node, NODE_READER_EXPR);
    return node;
}

func reader_expr_name(node *u8) *u8 {
    var n *ReaderExpr = node;
    return n.name;
}

func reader_expr_set_name(node *u8, ptr *u8) void {
    var n *ReaderExpr = node;
    n.name = ptr;
}

func reader_expr_name_len(node *u8) i64 {
    var n *ReaderExpr = node;
    return n.name_len;
}

func reader_expr_set_name_len(node *u8, len i64) void {
    var n *ReaderExpr = node;
    n.name_len = len;
}

func reader_expr_content(node *u8) *u8 {
    var n *ReaderExpr = node;
    return n.content;
}

func reader_expr_set_content(node *u8, ptr *u8) void {
    var n *ReaderExpr = node;
    n.content = ptr;
}

func reader_expr_content_len(node *u8) i64 {
    var n *ReaderExpr = node;
    return n.content_len;
}

func reader_expr_set_content_len(node *u8, len i64) void {
    var n *ReaderExpr = node;
    n.content_len = len;
}

// ============================================================
// IncludeDecl struct
// Stores path to included file
// ============================================================

struct IncludeDecl {
    kind i64;
    path *u8;
    path_len i64;
}

func include_decl_alloc() *u8 {
    var node *u8 = alloc(24);
    node_set_kind(node, NODE_INCLUDE_DECL);
    return node;
}

func include_decl_path(node *u8) *u8 {
    var n *IncludeDecl = node;
    return n.path;
}

func include_decl_set_path(node *u8, ptr *u8) void {
    var n *IncludeDecl = node;
    n.path = ptr;
}

func include_decl_path_len(node *u8) i64 {
    var n *IncludeDecl = node;
    return n.path_len;
}

func include_decl_set_path_len(node *u8, len i64) void {
    var n *IncludeDecl = node;
    n.path_len = len;
}

// ============================================================
// Type accessors
// ============================================================

func type_kind(t *u8) i64 {
    var p *i64 = t;
    return *p;
}

func type_set_kind(t *u8, k i64) void {
    var p *i64 = t;
    *p = k;
}

func base_type_alloc() *u8 {
    var t *u8 = alloc(24);
    type_set_kind(t, TYPE_BASE);
    return t;
}

func base_type_name(t *u8) *u8 {
    var p **u8 = t + 8;
    return *p;
}

func base_type_set_name(t *u8, ptr *u8) void {
    var p **u8 = t + 8;
    *p = ptr;
}

func base_type_name_len(t *u8) i64 {
    var p *i64 = t + 16;
    return *p;
}

func base_type_set_name_len(t *u8, len i64) void {
    var p *i64 = t + 16;
    *p = len;
}

func ptr_type_alloc() *u8 {
    var t *u8 = alloc(16);
    type_set_kind(t, TYPE_PTR);
    return t;
}

func ptr_type_elem(t *u8) *u8 {
    var p **u8 = t + 8;
    return *p;
}

func ptr_type_set_elem(t *u8, elem *u8) void {
    var p **u8 = t + 8;
    *p = elem;
}

// ============================================================
// FuncType accessors (AST 2.0)
// ============================================================
// FuncType: [kind:8][params:8][param_count:8][ret:8] = 32 bytes
// params is array of type pointers (8 bytes each)

func func_type_alloc() *u8 {
    var t *u8 = alloc(32);
    type_set_kind(t, TYPE_FUNC);
    return t;
}

func func_type_params(t *u8) *u8 {
    var p **u8 = t + 8;
    return *p;
}

func func_type_set_params(t *u8, params *u8) void {
    var p **u8 = t + 8;
    *p = params;
}

func func_type_param_count(t *u8) i64 {
    var p *i64 = t + 16;
    return *p;
}

func func_type_set_param_count(t *u8, count i64) void {
    var p *i64 = t + 16;
    *p = count;
}

func func_type_ret(t *u8) *u8 {
    var p **u8 = t + 24;
    return *p;
}

func func_type_set_ret(t *u8, ret *u8) void {
    var p **u8 = t + 24;
    *p = ret;
}

// ============================================================
// ClosureType accessors (AST 2.0 - Phase 3b)
// ============================================================
// ClosureType: [kind:8][params:8][param_count:8][ret:8] = 32 bytes
// Same layout as FuncType but with TYPE_CLOSURE kind

func closure_type_alloc() *u8 {
    var t *u8 = alloc(32);
    type_set_kind(t, TYPE_CLOSURE);
    return t;
}

func closure_type_params(t *u8) *u8 {
    var p **u8 = t + 8;
    return *p;
}

func closure_type_set_params(t *u8, params *u8) void {
    var p **u8 = t + 8;
    *p = params;
}

func closure_type_param_count(t *u8) i64 {
    var p *i64 = t + 16;
    return *p;
}

func closure_type_set_param_count(t *u8, count i64) void {
    var p *i64 = t + 16;
    *p = count;
}

func closure_type_ret(t *u8) *u8 {
    var p **u8 = t + 24;
    return *p;
}

func closure_type_set_ret(t *u8, ret *u8) void {
    var p **u8 = t + 24;
    *p = ret;
}

// ============================================================
// Param accessors (24 bytes each)
// ============================================================

func param_name(p *u8) *u8 {
    var ptr **u8 = p;
    return *ptr;
}

func param_set_name(p *u8, name *u8) void {
    var ptr **u8 = p;
    *ptr = name;
}

func param_name_len(p *u8) i64 {
    var ptr *i64 = p + 8;
    return *ptr;
}

func param_set_name_len(p *u8, len i64) void {
    var ptr *i64 = p + 8;
    *ptr = len;
}

func param_type(p *u8) *u8 {
    var ptr **u8 = p + 16;
    return *ptr;
}

func param_set_type(p *u8, t *u8) void {
    var ptr **u8 = p + 16;
    *ptr = t;
}

// ============================================================
// Parser state (global)
// ============================================================

var parse_tokens *u8 = nil;      // vec of token pointers
var parse_current i64 = 0;
var parse_error_count i64 = 0;  // v2
var parse_max_errors i64 = 10;   // Stop after this many errors

// ============================================================
// Token array helper (using vec)
// ============================================================

func get_token(index i64) *u8 {
    var ptr_as_int i64 = vec_get(parse_tokens, index);
    var p *i64 = &ptr_as_int;
    var pp **u8 = p;
    return *pp;
}

func parser_token_count() i64 {
    return vec_len(parse_tokens);
}

// ============================================================
// Parser initialization
// ============================================================

func parser_init() void {
    parse_tokens = vec_new(8);
    parse_current = 0;
    parse_error_count = 0;
}

func parser_add_token(tok *u8) void {
    // Store pointer as i64 in vec
    var p **u8 = &tok;
    var pi *i64 = p;
    vec_push(parse_tokens, *pi);
}

// Tokenize source and fill token array
func parser_tokenize(source *u8) void {
    parser_init();
    lexer_init(source);

    var done i64 = 0;
    while done == 0 {
        var tok *u8 = scan_token();
        parser_add_token(tok);
        if tok_type(tok) == TOKEN_EOF || tok_type(tok) == TOKEN_ERROR {
            done = 1;
        }
    }
}

// ============================================================
// Parser helpers
// ============================================================

func parse_is_at_end() bool {
    return tok_type(parse_peek()) == TOKEN_EOF;
}

func parse_peek() *u8 {
    return get_token(parse_current);
}

func parse_peek_next() *u8 {
    if parse_current + 1 >= parser_token_count() {
        return nil;
    }
    return get_token(parse_current + 1);
}

func parse_previous() *u8 {
    return get_token(parse_current - 1);
}

func parse_advance() *u8 {
    if !parse_is_at_end() {
        parse_current = parse_current + 1;
    }
    return parse_previous();
}

func parse_check(t i64) bool {
    if parse_is_at_end() {
        return false;
    }
    return tok_type(parse_peek()) == t;
}

func parse_match(t i64) bool {
    if parse_check(t) {
        parse_advance();
        return true;
    }
    return false;
}

func parse_error(msg *u8) void {
    var tok *u8 = parse_peek();
    eprint("Error at ");
    eprint_i64(tok_line(tok));
    eprint(":");
    eprint_i64(tok_col(tok));
    eprint(": ");
    eprintln(msg);
    parse_error_count = parse_error_count + 1;

    // Exit early if too many errors
    if parse_error_count >= parse_max_errors {
        eprintln("Too many errors, stopping.");
        exit(1);
    }
}

func parse_expect(t i64, msg *u8) *u8 {
    if parse_check(t) {
        return parse_advance();
    }
    parse_error(msg);
    return nil;
}

// ============================================================
// Type parsing
// ============================================================

func parse_type() *u8 {
    if parse_match(TOKEN_STAR) {
        var elem *u8 = parse_type();
        var t *u8 = ptr_type_alloc();
        ptr_type_set_elem(t, elem);
        return t;
    }

    // Function type: fn(T1, T2) R
    if parse_match(TOKEN_FN) {
        parse_expect(TOKEN_LPAREN, "expected '(' after 'fn'");

        // Parse parameter types
        var params *u8 = vec_new(8);
        if !parse_check(TOKEN_RPAREN) {
            var first i64 = 1;
            while first == 1 || parse_match(TOKEN_COMMA) {
                first = 0;
                var param_type *u8 = parse_type();
                vec_push(params, param_type);
            }
        }
        parse_expect(TOKEN_RPAREN, "expected ')' after parameter types");

        // Parse return type
        var ret *u8 = parse_type();

        var t *u8 = func_type_alloc();
        func_type_set_params(t, params);
        func_type_set_param_count(t, vec_len(params));
        func_type_set_ret(t, ret);
        return t;
    }

    // Closure type: closure(T1, T2) R (allows capturing lambdas)
    if parse_match(TOKEN_CLOSURE) {
        parse_expect(TOKEN_LPAREN, "expected '(' after 'closure'");

        // Parse parameter types
        var params *u8 = vec_new(8);
        if !parse_check(TOKEN_RPAREN) {
            var first i64 = 1;
            while first == 1 || parse_match(TOKEN_COMMA) {
                first = 0;
                var param_type *u8 = parse_type();
                vec_push(params, param_type);
            }
        }
        parse_expect(TOKEN_RPAREN, "expected ')' after parameter types");

        // Parse return type
        var ret *u8 = parse_type();

        var t *u8 = closure_type_alloc();
        closure_type_set_params(t, params);
        closure_type_set_param_count(t, vec_len(params));
        closure_type_set_ret(t, ret);
        return t;
    }

    // Base type
    var tok *u8 = parse_advance();
    var tt i64 = tok_type(tok);

    if tt == TOKEN_I8 || tt == TOKEN_I16 || tt == TOKEN_I32 || tt == TOKEN_I64 ||
       tt == TOKEN_U8 || tt == TOKEN_U16 || tt == TOKEN_U32 || tt == TOKEN_U64 ||
       tt == TOKEN_BOOL || tt == TOKEN_VOID || tt == TOKEN_IDENT {
        var t *u8 = base_type_alloc();
        base_type_set_name(t, tok_lexeme(tok));
        base_type_set_name_len(t, tok_lexeme_len(tok));
        return t;
    }

    parse_error("expected type");
    var t *u8 = base_type_alloc();
    base_type_set_name(t, "error");
    base_type_set_name_len(t, 5);
    return t;
}

// ============================================================
// Expression parsing (precedence climbing)
// ============================================================

// Forward declarations via recursive calls

func parse_expression() *u8 {
    return parse_assignment();
}

func parse_assignment() *u8 {
    var expr *u8 = parse_or();
    if parse_match(TOKEN_EQ) {
        var value *u8 = parse_assignment();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, TOKEN_EQ);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, value);
        return node;
    }
    // Compound assignment: x += y  =>  x = x + y
    var compound_op i64 = 0;
    if parse_match(TOKEN_PLUSEQ) { compound_op = TOKEN_PLUS; }
    else if parse_match(TOKEN_MINUSEQ) { compound_op = TOKEN_MINUS; }
    else if parse_match(TOKEN_STAREQ) { compound_op = TOKEN_STAR; }
    else if parse_match(TOKEN_SLASHEQ) { compound_op = TOKEN_SLASH; }
    else if parse_match(TOKEN_PERCENTEQ) { compound_op = TOKEN_PERCENT; }
    if compound_op != 0 {
        var value *u8 = parse_assignment();
        // Build: x + y
        var binop *u8 = binary_expr_alloc();
        binary_expr_set_op(binop, compound_op);
        binary_expr_set_left(binop, expr);
        binary_expr_set_right(binop, value);
        // Build: x = (x + y)
        var assign *u8 = binary_expr_alloc();
        binary_expr_set_op(assign, TOKEN_EQ);
        binary_expr_set_left(assign, expr);
        binary_expr_set_right(assign, binop);
        return assign;
    }
    return expr;
}

func parse_or() *u8 {
    var expr *u8 = parse_and();
    while parse_match(TOKEN_PIPEPIPE) {
        var right *u8 = parse_and();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, TOKEN_PIPEPIPE);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_and() *u8 {
    var expr *u8 = parse_bitor();
    while parse_match(TOKEN_AMPAMP) {
        var right *u8 = parse_bitor();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, TOKEN_AMPAMP);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_bitor() *u8 {
    var expr *u8 = parse_bitxor();
    while parse_match(TOKEN_PIPE) {
        var right *u8 = parse_bitxor();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, TOKEN_PIPE);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_bitxor() *u8 {
    var expr *u8 = parse_bitand();
    while parse_match(TOKEN_CARET) {
        var right *u8 = parse_bitand();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, TOKEN_CARET);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_bitand() *u8 {
    var expr *u8 = parse_equality();
    while parse_match(TOKEN_AMP) {
        var right *u8 = parse_equality();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, TOKEN_AMP);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_equality() *u8 {
    var expr *u8 = parse_comparison();
    while parse_check(TOKEN_EQEQ) || parse_check(TOKEN_BANGEQ) {
        var op i64 = tok_type(parse_advance());
        var right *u8 = parse_comparison();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, op);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_comparison() *u8 {
    var expr *u8 = parse_shift();
    while parse_check(TOKEN_LT) || parse_check(TOKEN_GT) ||
          parse_check(TOKEN_LTEQ) || parse_check(TOKEN_GTEQ) {
        var op i64 = tok_type(parse_advance());
        var right *u8 = parse_shift();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, op);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_shift() *u8 {
    var expr *u8 = parse_additive();
    while parse_check(TOKEN_LTLT) || parse_check(TOKEN_GTGT) {
        var op i64 = tok_type(parse_advance());
        var right *u8 = parse_additive();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, op);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_additive() *u8 {
    var expr *u8 = parse_mult();
    while parse_check(TOKEN_PLUS) || parse_check(TOKEN_MINUS) {
        var op i64 = tok_type(parse_advance());
        var right *u8 = parse_mult();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, op);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_mult() *u8 {
    var expr *u8 = parse_unary();
    while parse_check(TOKEN_STAR) || parse_check(TOKEN_SLASH) || parse_check(TOKEN_PERCENT) {
        var op i64 = tok_type(parse_advance());
        var right *u8 = parse_unary();
        var node *u8 = binary_expr_alloc();
        binary_expr_set_op(node, op);
        binary_expr_set_left(node, expr);
        binary_expr_set_right(node, right);
        expr = node;
    }
    return expr;
}

func parse_unary() *u8 {
    if parse_check(TOKEN_MINUS) || parse_check(TOKEN_BANG) ||
       parse_check(TOKEN_STAR) || parse_check(TOKEN_AMP) {
        var op i64 = tok_type(parse_advance());
        var expr *u8 = parse_unary();
        var node *u8 = unary_expr_alloc();
        unary_expr_set_op(node, op);
        unary_expr_set_expr(node, expr);
        return node;
    }
    return parse_postfix();
}

func parse_postfix() *u8 {
    var expr *u8 = parse_primary();

    var done i64 = 0;
    while done == 0 {
        if parse_match(TOKEN_LPAREN) {
            expr = parse_finish_call(expr);
        } else if parse_match(TOKEN_LBRACKET) {
            var index *u8 = parse_expression();
            parse_expect(TOKEN_RBRACKET, "expected ']' after index");
            var node *u8 = alloc(24);  // IndexExpr
            node_set_kind(node, NODE_INDEX_EXPR);
            var p **u8 = node + 8;
            *p = expr;
            p = node + 16;
            *p = index;
            expr = node;
        } else if parse_match(TOKEN_DOT) {
            var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected field name");
            var node *u8 = alloc(32);  // FieldExpr
            node_set_kind(node, NODE_FIELD_EXPR);
            var pe **u8 = node + 8;
            *pe = expr;
            var pn **u8 = node + 16;
            *pn = tok_lexeme(name_tok);
            var pl *i64 = node + 24;
            *pl = tok_lexeme_len(name_tok);
            expr = node;
        } else {
            done = 1;
        }
    }
    return expr;
}

func parse_finish_call(callee *u8) *u8 {
    // Allocate array for args (max 16)
    var args *u8 = alloc(LIMIT_CALL_ARGS * 8);
    var arg_count i64 = 0;

    if !parse_check(TOKEN_RPAREN) {
        var done i64 = 0;
        while done == 0 {
            var arg *u8 = parse_expression();
            var p **u8 = args + (arg_count * 8);
            *p = arg;
            arg_count = arg_count + 1;
            if !parse_match(TOKEN_COMMA) {
                done = 1;
            }
        }
    }
    parse_expect(TOKEN_RPAREN, "expected ')' after arguments");

    var node *u8 = call_expr_alloc();
    call_expr_set_func(node, callee);
    call_expr_set_args(node, args);
    call_expr_set_arg_count(node, arg_count);
    return node;
}

// Parse a pattern for match expressions
// Patterns: _ | EnumName.Variant | EnumName.Variant(binding)
func parse_pattern() *u8 {
    // Check for wildcard: _
    if parse_check(TOKEN_IDENT) {
        var tok *u8 = parse_peek();
        var name *u8 = tok_lexeme(tok);
        var len i64 = tok_lexeme_len(tok);
        if len == 1 && *name == 95 {  // '_'
            parse_advance();
            return pattern_wildcard_alloc();
        }
    }

    // Must be EnumName.Variant or EnumName.Variant(binding)
    var enum_tok *u8 = parse_expect(TOKEN_IDENT, "expected pattern");
    parse_expect(TOKEN_DOT, "expected '.' after enum name in pattern");
    var variant_tok *u8 = parse_expect(TOKEN_IDENT, "expected variant name after '.'");

    var node *u8 = pattern_variant_alloc();
    pattern_variant_set_enum_name(node, tok_lexeme(enum_tok));
    pattern_variant_set_enum_len(node, tok_lexeme_len(enum_tok));
    pattern_variant_set_name(node, tok_lexeme(variant_tok));
    pattern_variant_set_name_len(node, tok_lexeme_len(variant_tok));

    // Check for binding: Variant(x)
    if parse_match(TOKEN_LPAREN) {
        var binding_tok *u8 = parse_expect(TOKEN_IDENT, "expected binding name");
        pattern_variant_set_binding(node, tok_lexeme(binding_tok));
        pattern_variant_set_binding_len(node, tok_lexeme_len(binding_tok));
        parse_expect(TOKEN_RPAREN, "expected ')' after binding");
    } else {
        pattern_variant_set_binding(node, nil);
        pattern_variant_set_binding_len(node, 0);
    }

    return node;
}

func parse_primary() *u8 {
    if parse_match(TOKEN_NUMBER) {
        var tok *u8 = parse_previous();
        var node *u8 = number_expr_alloc();
        number_expr_set_value(node, tok_lexeme(tok));
        number_expr_set_value_len(node, tok_lexeme_len(tok));
        return node;
    }

    if parse_match(TOKEN_STRING) {
        var tok *u8 = parse_previous();
        var node *u8 = string_expr_alloc();
        string_expr_set_value(node, tok_lexeme(tok));
        string_expr_set_value_len(node, tok_lexeme_len(tok));
        return node;
    }

    if parse_match(TOKEN_TRUE) {
        var node *u8 = bool_expr_alloc();
        bool_expr_set_value(node, 1);
        return node;
    }

    if parse_match(TOKEN_FALSE) {
        var node *u8 = bool_expr_alloc();
        bool_expr_set_value(node, 0);
        return node;
    }

    if parse_match(TOKEN_NIL) {
        return nil_expr_alloc();
    }

    if parse_match(TOKEN_IDENT) {
        var tok *u8 = parse_previous();
        var node *u8 = ident_expr_alloc();
        ident_expr_set_name(node, tok_lexeme(tok));
        ident_expr_set_name_len(node, tok_lexeme_len(tok));
        return node;
    }

    if parse_match(TOKEN_LPAREN) {
        var expr *u8 = parse_expression();
        parse_expect(TOKEN_RPAREN, "expected ')' after expression");
        var node *u8 = group_expr_alloc();
        group_expr_set_expr(node, expr);
        return node;
    }

    // Quote: ${ expr }
    if parse_match(TOKEN_DOLLAR_LBRACE) {
        var expr *u8 = parse_expression();
        parse_expect(TOKEN_RBRACE, "expected '}' after quoted expression");
        var node *u8 = quote_expr_alloc();
        quote_expr_set_expr(node, expr);
        return node;
    }

    // Unquote: $name (splice AST variable)
    if parse_match(TOKEN_DOLLAR) {
        parse_expect(TOKEN_IDENT, "expected identifier after '$'");
        var tok *u8 = parse_previous();
        var node *u8 = unquote_expr_alloc();
        unquote_expr_set_name(node, tok_lexeme(tok));
        unquote_expr_set_name_len(node, tok_lexeme_len(tok));
        return node;
    }

    // Unquote string: $@name (splice string value as string literal)
    if parse_match(TOKEN_DOLLAR_AT) {
        parse_expect(TOKEN_IDENT, "expected identifier after '$@'");
        var tok *u8 = parse_previous();
        var node *u8 = unquote_string_expr_alloc();
        unquote_string_expr_set_name(node, tok_lexeme(tok));
        unquote_string_expr_set_name_len(node, tok_lexeme_len(tok));
        return node;
    }

    // Reader macro invocation: #name{content}
    if parse_match(TOKEN_READER_MACRO) {
        var tok *u8 = parse_previous();
        var node *u8 = reader_expr_alloc();
        reader_expr_set_name(node, tok_lexeme(tok));
        reader_expr_set_name_len(node, tok_lexeme_len(tok));
        reader_expr_set_content(node, tok_content(tok));
        reader_expr_set_content_len(node, tok_content_len(tok));
        return node;
    }

    // Let expression: let x = init in body
    // or with type: let x i64 = init in body
    if parse_match(TOKEN_LET) {
        var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected identifier after 'let'");

        // Optional type annotation
        var typ *u8 = nil;
        if !parse_check(TOKEN_EQ) {
            typ = parse_type();
        }

        parse_expect(TOKEN_EQ, "expected '=' in let expression");
        var init *u8 = parse_expression();

        parse_expect(TOKEN_IN, "expected 'in' after let initializer");
        var body *u8 = parse_expression();

        var node *u8 = let_expr_alloc();
        let_expr_set_name(node, tok_lexeme(name_tok));
        let_expr_set_name_len(node, tok_lexeme_len(name_tok));
        let_expr_set_type(node, typ);
        let_expr_set_init(node, init);
        let_expr_set_body(node, body);
        return node;
    }

    // Lambda expression: fn(param1 type1, param2 type2) ret_type { body }
    // Uses TOKEN_FN which is already used for fn(T) R type syntax
    // In primary position, this is a lambda value, not a type
    if parse_match(TOKEN_FN) {
        parse_expect(TOKEN_LPAREN, "expected '(' after 'fn' in lambda");

        // Parse parameters (similar to func params)
        var params *u8 = alloc(LIMIT_FUNC_PARAMS * 24);
        var param_count i64 = 0;

        if !parse_check(TOKEN_RPAREN) {
            var done i64 = 0;
            while done == 0 {
                var pname_tok *u8 = parse_expect(TOKEN_IDENT, "expected parameter name");
                var ptype *u8 = parse_type();

                var p *u8 = params + (param_count * 24);
                param_set_name(p, tok_lexeme(pname_tok));
                param_set_name_len(p, tok_lexeme_len(pname_tok));
                param_set_type(p, ptype);
                param_count = param_count + 1;

                if !parse_match(TOKEN_COMMA) {
                    done = 1;
                }
            }
        }
        parse_expect(TOKEN_RPAREN, "expected ')' after lambda parameters");

        // Parse optional return type (if not immediately a brace)
        var ret_type *u8 = nil;
        if !parse_check(TOKEN_LBRACE) {
            ret_type = parse_type();
        }

        // Parse body (block only for now)
        var body *u8 = parse_block();

        var node *u8 = lambda_expr_alloc();
        lambda_expr_set_params(node, params);
        lambda_expr_set_param_count(node, param_count);
        lambda_expr_set_ret_type(node, ret_type);
        lambda_expr_set_body(node, body);
        return node;
    }

    // Match expression: match expr { Pattern => body, ... }
    if parse_match(TOKEN_MATCH) {
        var scrutinee *u8 = parse_expression();
        parse_expect(TOKEN_LBRACE, "expected '{' after match expression");

        // Allocate arms array (max 32 arms)
        var arms *u8 = alloc(32 * 16);
        var arm_count i64 = 0;

        while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
            // Parse pattern
            var pattern *u8 = parse_pattern();

            parse_expect(TOKEN_ARROW, "expected '=>' after pattern");

            // Parse body: can be expression or block expression
            var body *u8 = nil;
            if parse_check(TOKEN_LBRACE) {
                body = parse_block_expr();
            } else {
                body = parse_expression();
            }

            // Store arm
            var arm *u8 = get_match_arm(arms, arm_count);
            match_arm_set_pattern(arm, pattern);
            match_arm_set_body(arm, body);
            arm_count = arm_count + 1;

            // Optional comma between arms
            parse_match(TOKEN_COMMA);
        }

        parse_expect(TOKEN_RBRACE, "expected '}' after match arms");

        var node *u8 = match_expr_alloc();
        match_expr_set_scrutinee(node, scrutinee);
        match_expr_set_arms(node, arms);
        match_expr_set_arm_count(node, arm_count);
        return node;
    }

    // Perform expression: perform Effect(args)
    if parse_match(TOKEN_PERFORM) {
        var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected effect name after 'perform'");
        parse_expect(TOKEN_LPAREN, "expected '(' after effect name");

        // Parse arguments
        var args *u8 = alloc(64 * 8);  // max 64 args
        var arg_count i64 = 0;

        if !parse_check(TOKEN_RPAREN) {
            var first_arg *u8 = parse_expression();
            var p **u8 = args + (arg_count * 8);
            *p = first_arg;
            arg_count = arg_count + 1;

            while parse_match(TOKEN_COMMA) {
                var arg *u8 = parse_expression();
                var pp **u8 = args + (arg_count * 8);
                *pp = arg;
                arg_count = arg_count + 1;
            }
        }

        parse_expect(TOKEN_RPAREN, "expected ')' after effect arguments");

        var node *u8 = perform_expr_alloc();
        perform_expr_set_name(node, tok_lexeme(name_tok));
        perform_expr_set_name_len(node, tok_lexeme_len(name_tok));
        perform_expr_set_args(node, args);
        perform_expr_set_arg_count(node, arg_count);
        return node;
    }

    // Resume expression: resume k(value)
    if parse_match(TOKEN_RESUME) {
        // Parse continuation as identifier
        var k_tok *u8 = parse_expect(TOKEN_IDENT, "expected continuation name after 'resume'");
        var k_expr *u8 = ident_expr_alloc();
        ident_expr_set_name(k_expr, tok_lexeme(k_tok));
        ident_expr_set_name_len(k_expr, tok_lexeme_len(k_tok));

        parse_expect(TOKEN_LPAREN, "expected '(' after continuation");
        var value *u8 = nil;
        if !parse_check(TOKEN_RPAREN) {
            value = parse_expression();
        }
        parse_expect(TOKEN_RPAREN, "expected ')' after resume value");

        var node *u8 = resume_expr_alloc();
        resume_expr_set_k(node, k_expr);
        resume_expr_set_value(node, value);
        return node;
    }

    // Handle expression: handle { body } with { return(v) => expr, Effect(e) => expr }
    if parse_match(TOKEN_HANDLE) {
        parse_expect(TOKEN_LBRACE, "expected '{' after 'handle'");

        // Parse body - always parse as block (statements until })
        // This allows: handle { var x = 1; x + 2; } with { ... }
        // and also: handle { func_call(); } with { ... }
        var stmts *u8 = alloc(LIMIT_STMTS_PER_BLOCK * 8);
        var stmt_count i64 = 0;
        while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
            var stmt *u8 = parse_statement();
            var p **u8 = stmts + (stmt_count * 8);
            *p = stmt;
            stmt_count = stmt_count + 1;
        }
        var body *u8 = block_stmt_alloc();
        block_stmt_set_stmts(body, stmts);
        block_stmt_set_count(body, stmt_count);

        parse_expect(TOKEN_RBRACE, "expected '}' after handle body");
        parse_expect(TOKEN_WITH, "expected 'with' after handle body");
        parse_expect(TOKEN_LBRACE, "expected '{' after 'with'");

        // Parse return case first: return(v) => expr
        var ret_bind *u8 = nil;
        var ret_bind_len i64 = 0;
        var ret_body *u8 = nil;

        // Allocate effect cases array (max 32 cases, 56 bytes each)
        var cases *u8 = alloc(32 * 56);
        var case_count i64 = 0;

        while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
            // Accept either IDENT or RETURN keyword for case name
            var case_name_tok *u8 = nil;
            if parse_match(TOKEN_RETURN) {
                case_name_tok = parse_previous();
            } else {
                case_name_tok = parse_expect(TOKEN_IDENT, "expected effect name or 'return'");
            }
            parse_expect(TOKEN_LPAREN, "expected '(' after handler case name");
            var binding_tok *u8 = parse_expect(TOKEN_IDENT, "expected binding name");

            // Optional continuation parameter: Effect(e, k)
            var k_tok *u8 = nil;
            if parse_match(TOKEN_COMMA) {
                k_tok = parse_expect(TOKEN_IDENT, "expected continuation name");
            }

            parse_expect(TOKEN_RPAREN, "expected ')' after binding");
            parse_expect(TOKEN_ARROW, "expected '=>' after pattern");

            // Handler body can be expression or block
            var case_body *u8 = nil;
            if parse_check(TOKEN_LBRACE) {
                case_body = parse_block();
            } else {
                case_body = parse_expression();
            }

            // Check if this is the return case
            if buf_eq_str(tok_lexeme(case_name_tok), tok_lexeme_len(case_name_tok), "return") {
                ret_bind = tok_lexeme(binding_tok);
                ret_bind_len = tok_lexeme_len(binding_tok);
                ret_body = case_body;
            } else {
                // Effect case: store in cases array
                var entry *u8 = cases + (case_count * 56);
                var p1 **u8 = entry;
                *p1 = tok_lexeme(case_name_tok);
                var p2 *i64 = entry + 8;
                *p2 = tok_lexeme_len(case_name_tok);
                var p3 **u8 = entry + 16;
                *p3 = tok_lexeme(binding_tok);
                var p4 *i64 = entry + 24;
                *p4 = tok_lexeme_len(binding_tok);
                // Continuation binding (k)
                var p5 **u8 = entry + 32;
                var p6 *i64 = entry + 40;
                if k_tok != nil {
                    *p5 = tok_lexeme(k_tok);
                    *p6 = tok_lexeme_len(k_tok);
                } else {
                    *p5 = nil;
                    *p6 = 0;
                }
                var p7 **u8 = entry + 48;
                *p7 = case_body;
                case_count = case_count + 1;
            }

            // Optional comma
            parse_match(TOKEN_COMMA);
        }

        parse_expect(TOKEN_RBRACE, "expected '}' after handler cases");

        var node *u8 = handle_expr_alloc();
        handle_expr_set_body(node, body);
        handle_expr_set_cases(node, cases);
        handle_expr_set_case_count(node, case_count);
        handle_expr_set_ret_bind(node, ret_bind);
        handle_expr_set_ret_bind_len(node, ret_bind_len);
        handle_expr_set_ret_body(node, ret_body);
        return node;
    }

    parse_error("expected expression");
    var node *u8 = number_expr_alloc();
    number_expr_set_value(node, "0");
    number_expr_set_value_len(node, 1);
    return node;
}

// ============================================================
// Statement parsing
// ============================================================

func parse_block() *u8 {
    parse_expect(TOKEN_LBRACE, "expected '{'");

    // Allocate array for statements
    var stmts *u8 = alloc(LIMIT_STMTS_PER_BLOCK * 8);
    var stmt_count i64 = 0;

    while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
        var stmt *u8 = parse_statement();
        var p **u8 = stmts + (stmt_count * 8);
        *p = stmt;
        stmt_count = stmt_count + 1;
    }
    parse_expect(TOKEN_RBRACE, "expected '}'");

    var node *u8 = block_stmt_alloc();
    block_stmt_set_stmts(node, stmts);
    block_stmt_set_count(node, stmt_count);
    return node;
}

// Parse block as expression: { stmts; tail_expr }
// The tail expression (without semicolon) becomes the block's value
func parse_block_expr() *u8 {
    parse_expect(TOKEN_LBRACE, "expected '{'");

    var stmts *u8 = alloc(LIMIT_STMTS_PER_BLOCK * 8);
    var stmt_count i64 = 0;
    var tail_expr *u8 = nil;

    while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
        // Try to parse a statement that has explicit statement syntax
        // (var, if, while, return, break, continue, block)
        if parse_check(TOKEN_VAR) || parse_check(TOKEN_IF) ||
           parse_check(TOKEN_WHILE) || parse_check(TOKEN_RETURN) ||
           parse_check(TOKEN_BREAK) || parse_check(TOKEN_CONTINUE) ||
           parse_check(TOKEN_LBRACE) {
            var stmt *u8 = parse_statement();
            var p **u8 = stmts + (stmt_count * 8);
            *p = stmt;
            stmt_count = stmt_count + 1;
        } else {
            // Parse as expression
            var expr *u8 = parse_expression();

            if parse_check(TOKEN_SEMICOLON) {
                // It's an expression statement
                parse_advance();  // consume ;
                var stmt *u8 = expr_stmt_alloc();
                expr_stmt_set_expr(stmt, expr);
                var p **u8 = stmts + (stmt_count * 8);
                *p = stmt;
                stmt_count = stmt_count + 1;
            } else if parse_check(TOKEN_RBRACE) {
                // It's the tail expression (no semicolon before })
                tail_expr = expr;
            } else {
                // Check for assignment
                if parse_check(TOKEN_EQ) {
                    parse_advance();
                    var val *u8 = parse_expression();
                    parse_expect(TOKEN_SEMICOLON, "expected ';' after assignment");
                    var stmt *u8 = assign_stmt_alloc();
                    assign_stmt_set_target(stmt, expr);
                    assign_stmt_set_value(stmt, val);
                    var p **u8 = stmts + (stmt_count * 8);
                    *p = stmt;
                    stmt_count = stmt_count + 1;
                } else {
                    parse_error("expected ';' or '}' after expression in block");
                }
            }
        }
    }

    parse_expect(TOKEN_RBRACE, "expected '}'");

    var node *u8 = block_expr_alloc();
    block_expr_set_stmts(node, stmts);
    block_expr_set_count(node, stmt_count);
    block_expr_set_tail(node, tail_expr);
    return node;
}

// Track pending label for next while statement
var parse_pending_label *u8 = nil;
var parse_pending_label_len i64 = 0;

func parse_statement() *u8 {
    // Check for label: IDENT followed by COLON
    if parse_check(TOKEN_IDENT) {
        var tok *u8 = parse_peek();
        var next *u8 = parse_peek_next();
        if next != nil && tok_type(next) == TOKEN_COLON {
            // This is a label
            parse_advance();  // consume IDENT
            parse_advance();  // consume COLON
            parse_pending_label = tok_lexeme(tok);
            parse_pending_label_len = tok_lexeme_len(tok);
            // The next statement (must be while) will pick up the label
            return parse_statement();
        }
    }

    if parse_match(TOKEN_VAR) {
        return parse_var_decl();
    }
    if parse_match(TOKEN_IF) {
        return parse_if_stmt();
    }
    if parse_match(TOKEN_WHILE) {
        return parse_while_stmt();
    }
    if parse_match(TOKEN_RETURN) {
        return parse_return_stmt();
    }
    if parse_match(TOKEN_BREAK) {
        var node *u8 = break_stmt_alloc();
        // Check for optional label
        if parse_check(TOKEN_IDENT) {
            var label_tok *u8 = parse_advance();
            break_stmt_set_label(node, tok_lexeme(label_tok));
            break_stmt_set_label_len(node, tok_lexeme_len(label_tok));
        } else {
            break_stmt_set_label(node, nil);
            break_stmt_set_label_len(node, 0);
        }
        parse_expect(TOKEN_SEMICOLON, "expected ';' after break");
        return node;
    }
    if parse_match(TOKEN_CONTINUE) {
        var node *u8 = continue_stmt_alloc();
        // Check for optional label
        if parse_check(TOKEN_IDENT) {
            var label_tok *u8 = parse_advance();
            continue_stmt_set_label(node, tok_lexeme(label_tok));
            continue_stmt_set_label_len(node, tok_lexeme_len(label_tok));
        } else {
            continue_stmt_set_label(node, nil);
            continue_stmt_set_label_len(node, 0);
        }
        parse_expect(TOKEN_SEMICOLON, "expected ';' after continue");
        return node;
    }
    if parse_check(TOKEN_LBRACE) {
        return parse_block();
    }
    return parse_expr_stmt();
}

func parse_var_decl() *u8 {
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected variable name");
    var typ *u8 = parse_type();

    var init *u8 = nil;
    if parse_match(TOKEN_EQ) {
        init = parse_expression();
    }
    parse_expect(TOKEN_SEMICOLON, "expected ';' after variable declaration");

    var node *u8 = var_decl_alloc();
    var_decl_set_name(node, tok_lexeme(name_tok));
    var_decl_set_name_len(node, tok_lexeme_len(name_tok));
    var_decl_set_type(node, typ);
    var_decl_set_init(node, init);
    var_decl_set_is_extern(node, 0);
    return node;
}

func parse_extern_var_decl() *u8 {
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected variable name");
    var typ *u8 = parse_type();
    parse_expect(TOKEN_SEMICOLON, "expected ';' after extern variable declaration");

    var node *u8 = var_decl_alloc();
    var_decl_set_name(node, tok_lexeme(name_tok));
    var_decl_set_name_len(node, tok_lexeme_len(name_tok));
    var_decl_set_type(node, typ);
    var_decl_set_init(node, nil);
    var_decl_set_is_extern(node, 1);
    return node;
}

func parse_if_stmt() *u8 {
    var cond *u8 = parse_expression();
    var then *u8 = parse_block();

    var els *u8 = nil;
    if parse_match(TOKEN_ELSE) {
        if parse_check(TOKEN_IF) {
            parse_advance();
            els = parse_if_stmt();
        } else {
            els = parse_block();
        }
    }

    var node *u8 = if_stmt_alloc();
    if_stmt_set_cond(node, cond);
    if_stmt_set_then(node, then);
    if_stmt_set_else(node, els);
    return node;
}

func parse_while_stmt() *u8 {
    // Capture pending label BEFORE parsing body (nested loops would steal it)
    var label *u8 = parse_pending_label;
    var label_len i64 = parse_pending_label_len;
    parse_pending_label = nil;
    parse_pending_label_len = 0;

    var cond *u8 = parse_expression();
    var body *u8 = parse_block();

    var node *u8 = while_stmt_alloc();
    while_stmt_set_cond(node, cond);
    while_stmt_set_body(node, body);
    while_stmt_set_label(node, label);
    while_stmt_set_label_len(node, label_len);

    return node;
}

func parse_return_stmt() *u8 {
    var value *u8 = nil;
    if !parse_check(TOKEN_SEMICOLON) {
        value = parse_expression();
    }
    parse_expect(TOKEN_SEMICOLON, "expected ';' after return");

    var node *u8 = return_stmt_alloc();
    return_stmt_set_value(node, value);
    return node;
}

func parse_expr_stmt() *u8 {
    var expr *u8 = parse_expression();
    parse_expect(TOKEN_SEMICOLON, "expected ';' after expression");

    // Convert assignment binary expressions to explicit assign statements
    // This separates assignment-as-statement from assignment-as-expression
    if node_kind(expr) == NODE_BINARY_EXPR {
        if binary_expr_op(expr) == TOKEN_EQ {
            var node *u8 = assign_stmt_alloc();
            assign_stmt_set_target(node, binary_expr_left(expr));
            assign_stmt_set_value(node, binary_expr_right(expr));
            return node;
        }
    }

    var node *u8 = expr_stmt_alloc();
    expr_stmt_set_expr(node, expr);
    return node;
}

// ============================================================
// Declaration parsing
// ============================================================

func parse_func_decl_impl(is_extern i64) *u8 {
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected function name");
    parse_expect(TOKEN_LPAREN, "expected '(' after function name");

    // Allocate params array (max 16 params, 24 bytes each)
    var params *u8 = alloc(LIMIT_FUNC_PARAMS * 24);
    var param_count i64 = 0;

    if !parse_check(TOKEN_RPAREN) {
        var done i64 = 0;
        while done == 0 {
            var pname_tok *u8 = parse_expect(TOKEN_IDENT, "expected parameter name");
            var ptype *u8 = parse_type();

            var p *u8 = params + (param_count * 24);
            param_set_name(p, tok_lexeme(pname_tok));
            param_set_name_len(p, tok_lexeme_len(pname_tok));
            param_set_type(p, ptype);
            param_count = param_count + 1;

            if !parse_match(TOKEN_COMMA) {
                done = 1;
            }
        }
    }
    parse_expect(TOKEN_RPAREN, "expected ')' after parameters");

    var ret_type *u8 = nil;
    var body *u8 = nil;

    if is_extern {
        // Extern functions: expect return type then semicolon, no body
        if !parse_check(TOKEN_SEMICOLON) {
            ret_type = parse_type();
        }
        parse_expect(TOKEN_SEMICOLON, "expected ';' after extern function declaration");
    } else {
        // Regular functions: optional return type, then body
        if !parse_check(TOKEN_LBRACE) {
            ret_type = parse_type();
        }
        body = parse_block();
    }

    var node *u8 = func_decl_alloc();
    func_decl_set_name(node, tok_lexeme(name_tok));
    func_decl_set_name_len(node, tok_lexeme_len(name_tok));
    func_decl_set_params(node, params);
    func_decl_set_param_count(node, param_count);
    func_decl_set_ret_type(node, ret_type);
    func_decl_set_body(node, body);
    func_decl_set_is_extern(node, is_extern);
    return node;
}

func parse_func_decl() *u8 {
    return parse_func_decl_impl(0);
}

func parse_extern_func_decl() *u8 {
    return parse_func_decl_impl(1);
}

func parse_struct_decl() *u8 {
    // struct IDENT "{" { IDENT type ";" } "}"
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected struct name");
    parse_expect(TOKEN_LBRACE, "expected '{' after struct name");

    // Allocate fields array (max 64 fields)
    var fields *u8 = alloc(64 * 24);
    var field_count i64 = 0;

    while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
        var field_name *u8 = parse_expect(TOKEN_IDENT, "expected field name");
        var field_type *u8 = parse_type();
        parse_expect(TOKEN_SEMICOLON, "expected ';' after field");

        // Store field
        var f *u8 = get_struct_field(fields, field_count);
        struct_field_set_name(f, tok_lexeme(field_name));
        struct_field_set_name_len(f, tok_lexeme_len(field_name));
        struct_field_set_type(f, field_type);
        field_count = field_count + 1;
    }

    parse_expect(TOKEN_RBRACE, "expected '}' after struct fields");

    var node *u8 = struct_decl_alloc();
    struct_decl_set_name(node, tok_lexeme(name_tok));
    struct_decl_set_name_len(node, tok_lexeme_len(name_tok));
    struct_decl_set_fields(node, fields);
    struct_decl_set_field_count(node, field_count);
    return node;
}

func parse_enum_decl() *u8 {
    // enum IDENT "{" { IDENT [ "(" type ")" ] "," } "}"
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected enum name");
    parse_expect(TOKEN_LBRACE, "expected '{' after enum name");

    // Allocate variants array (max 64 variants, 32 bytes each)
    var variants *u8 = alloc(64 * 32);
    var variant_count i64 = 0;

    while !parse_check(TOKEN_RBRACE) && !parse_is_at_end() {
        var vname_tok *u8 = parse_expect(TOKEN_IDENT, "expected variant name");

        var v *u8 = get_enum_variant(variants, variant_count);
        enum_variant_set_name(v, tok_lexeme(vname_tok));
        enum_variant_set_name_len(v, tok_lexeme_len(vname_tok));
        enum_variant_set_tag(v, variant_count);

        // Optional payload type: Variant(Type)
        if parse_match(TOKEN_LPAREN) {
            var vtype *u8 = parse_type();
            enum_variant_set_type(v, vtype);
            parse_expect(TOKEN_RPAREN, "expected ')' after variant type");
        } else {
            enum_variant_set_type(v, nil);
        }

        variant_count = variant_count + 1;

        // Optional comma (allow trailing comma)
        parse_match(TOKEN_COMMA);
    }

    parse_expect(TOKEN_RBRACE, "expected '}' after enum variants");

    var node *u8 = enum_decl_alloc();
    enum_decl_set_name(node, tok_lexeme(name_tok));
    enum_decl_set_name_len(node, tok_lexeme_len(name_tok));
    enum_decl_set_variants(node, variants);
    enum_decl_set_variant_count(node, variant_count);
    return node;
}

func parse_effect_decl() *u8 {
    // effect NAME "(" [type-list] ")" return-type
    // Example: effect Fail(i64) void
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected effect name");
    parse_expect(TOKEN_LPAREN, "expected '(' after effect name");

    // Parse parameter types (just types, no names - effects don't bind param names in decl)
    var param_types *u8 = alloc(64 * 8);  // max 64 param types
    var param_type_count i64 = 0;

    if !parse_check(TOKEN_RPAREN) {
        var first_type *u8 = parse_type();
        var p **u8 = param_types + (param_type_count * 8);
        *p = first_type;
        param_type_count = param_type_count + 1;

        while parse_match(TOKEN_COMMA) {
            var ptype *u8 = parse_type();
            var pp **u8 = param_types + (param_type_count * 8);
            *pp = ptype;
            param_type_count = param_type_count + 1;
        }
    }

    parse_expect(TOKEN_RPAREN, "expected ')' after effect parameters");

    // Parse return type
    var ret_type *u8 = parse_type();

    var node *u8 = effect_decl_alloc();
    effect_decl_set_name(node, tok_lexeme(name_tok));
    effect_decl_set_name_len(node, tok_lexeme_len(name_tok));
    effect_decl_set_param_types(node, param_types);
    effect_decl_set_param_type_count(node, param_type_count);
    effect_decl_set_return_type(node, ret_type);
    return node;
}

func parse_macro_decl() *u8 {
    // macro IDENT "(" [param-list] ")" block
    // params are just names (no types, they're all *Ast)
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected macro name");
    parse_expect(TOKEN_LPAREN, "expected '(' after macro name");

    // Allocate params array (max 16 params, 24 bytes each - reuse same layout as func)
    var params *u8 = alloc(LIMIT_FUNC_PARAMS * 24);
    var param_count i64 = 0;

    if !parse_check(TOKEN_RPAREN) {
        var done i64 = 0;
        while done == 0 {
            var pname_tok *u8 = parse_expect(TOKEN_IDENT, "expected parameter name");

            // Store param (no type for macros, set type to nil)
            var p *u8 = params + (param_count * 24);
            param_set_name(p, tok_lexeme(pname_tok));
            param_set_name_len(p, tok_lexeme_len(pname_tok));
            param_set_type(p, nil);
            param_count = param_count + 1;

            if !parse_match(TOKEN_COMMA) {
                done = 1;
            }
        }
    }
    parse_expect(TOKEN_RPAREN, "expected ')' after macro parameters");

    var body *u8 = parse_block();

    var node *u8 = macro_decl_alloc();
    macro_decl_set_name(node, tok_lexeme(name_tok));
    macro_decl_set_name_len(node, tok_lexeme_len(name_tok));
    macro_decl_set_params(node, params);
    macro_decl_set_param_count(node, param_count);
    macro_decl_set_body(node, body);
    return node;
}

func parse_import() *u8 {
    // import "path"
    var path_tok *u8 = parse_expect(TOKEN_STRING, "expected string after 'import'");
    parse_expect(TOKEN_SEMICOLON, "expected ';' after import path");

    var node *u8 = import_decl_alloc();
    // Strip quotes from string - path points to opening quote
    import_decl_set_path(node, tok_lexeme(path_tok) + 1);
    import_decl_set_path_len(node, tok_lexeme_len(path_tok) - 2);
    return node;
}

func parse_reader_decl() *u8 {
    // reader name(param *u8) *u8 { body }
    var name_tok *u8 = parse_expect(TOKEN_IDENT, "expected reader name");
    parse_expect(TOKEN_LPAREN, "expected '(' after reader name");
    var param_tok *u8 = parse_expect(TOKEN_IDENT, "expected parameter name");
    // Parse parameter type (readers always take *u8)
    parse_type();
    parse_expect(TOKEN_RPAREN, "expected ')' after reader parameter");
    // Parse return type (readers always return *u8)
    parse_type();

    var body *u8 = parse_block();

    var node *u8 = reader_decl_alloc();
    reader_decl_set_name(node, tok_lexeme(name_tok));
    reader_decl_set_name_len(node, tok_lexeme_len(name_tok));
    reader_decl_set_param_name(node, tok_lexeme(param_tok));
    reader_decl_set_param_len(node, tok_lexeme_len(param_tok));
    reader_decl_set_body(node, body);
    return node;
}

// Parse: include "path"
func parse_include() *u8 {
    if !parse_match(TOKEN_STRING) {
        parse_error("expected string path after include");
        return nil;
    }
    var path_tok *u8 = parse_previous();

    // Extract path (string value includes quotes, we want just the path)
    var path *u8 = tok_lexeme(path_tok);
    var path_len i64 = tok_lexeme_len(path_tok);

    // Strip quotes from path
    path = path + 1;
    path_len = path_len - 2;

    var node *u8 = include_decl_alloc();
    include_decl_set_path(node, path);
    include_decl_set_path_len(node, path_len);
    return node;
}

func parse_declaration() *u8 {
    if parse_match(TOKEN_EXTERN) {
        // extern func name(...) type; OR extern var name type;
        if parse_match(TOKEN_FUNC) {
            return parse_extern_func_decl();
        }
        if parse_match(TOKEN_VAR) {
            return parse_extern_var_decl();
        }
        parse_error("expected 'func' or 'var' after 'extern'");
        return nil;
    }
    if parse_match(TOKEN_FUNC) {
        return parse_func_decl();
    }
    if parse_match(TOKEN_VAR) {
        return parse_var_decl();
    }
    if parse_match(TOKEN_STRUCT) {
        return parse_struct_decl();
    }
    if parse_match(TOKEN_ENUM) {
        return parse_enum_decl();
    }
    if parse_match(TOKEN_EFFECT) {
        return parse_effect_decl();
    }
    if parse_match(TOKEN_MACRO) {
        return parse_macro_decl();
    }
    if parse_match(TOKEN_IMPORT) {
        return parse_import();
    }
    if parse_match(TOKEN_READER) {
        return parse_reader_decl();
    }
    if parse_match(TOKEN_INCLUDE) {
        return parse_include();
    }
    // Reader macro at declaration level: #name{content}
    if parse_match(TOKEN_READER_MACRO) {
        var tok *u8 = parse_previous();
        var node *u8 = reader_expr_alloc();
        reader_expr_set_name(node, tok_lexeme(tok));
        reader_expr_set_name_len(node, tok_lexeme_len(tok));
        reader_expr_set_content(node, tok_content(tok));
        reader_expr_set_content_len(node, tok_content_len(tok));
        return node;
    }

    // Better error for stray semicolons (common C habit)
    if parse_check(TOKEN_SEMICOLON) {
        parse_error("unexpected ';' - lang doesn't use semicolons after include/import");
        parse_advance();
        return nil;
    }

    parse_error("expected declaration");
    parse_advance();
    return nil;
}

// ============================================================
// Program parsing
// ============================================================

// Program: [decls:8][decl_count:8] = 16 bytes

func parse_program() *u8 {
    // Allocate decls array (max 1000)
    var decls *u8 = alloc(LIMIT_TOP_DECLS * 8);
    var decl_count i64 = 0;

    while !parse_is_at_end() {
        var decl *u8 = parse_declaration();
        if decl != nil {
            var p **u8 = decls + (decl_count * 8);
            *p = decl;
            decl_count = decl_count + 1;
        }
    }

    var prog *u8 = alloc(16);
    var pd **u8 = prog;
    *pd = decls;
    var pc *i64 = prog + 8;
    *pc = decl_count;

    return prog;
}

// Program accessors
func program_decls(prog *u8) *u8 {
    var p **u8 = prog;
    return *p;
}

func program_decl_count(prog *u8) i64 {
    var p *i64 = prog + 8;
    return *p;
}

func get_decl(decls *u8, index i64) *u8 {
    var p **u8 = decls + (index * 8);
    return *p;
}

// ============================================================
// Parse expression from string (for V2 reader macros)
// ============================================================

func parse_expression_from_string(source *u8) *u8 {
    // Save current parser state
    var saved_tokens *u8 = parse_tokens;
    var saved_current i64 = parse_current;
    var saved_errors i64 = parse_error_count;

    // Initialize fresh state
    parse_tokens = vec_new(8);
    parse_current = 0;
    parse_error_count = 0;

    // Tokenize the source
    parser_tokenize(source);

    // Parse as expression
    var expr *u8 = nil;
    if parser_token_count() > 0 {
        expr = parse_expression();
    }

    // Free the temporary token vec
    vec_free(parse_tokens);

    // Restore parser state
    parse_tokens = saved_tokens;
    parse_current = saved_current;
    parse_error_count = saved_errors;

    return expr;
}

// Parse a program from a source string (for include processing)
func parse_program_from_string(source *u8) *u8 {
    // Save current parser state
    var saved_tokens *u8 = parse_tokens;
    var saved_current i64 = parse_current;
    var saved_errors i64 = parse_error_count;

    // Initialize fresh state
    parse_tokens = vec_new(8);
    parse_current = 0;
    parse_error_count = 0;

    // Tokenize the source
    parser_tokenize(source);

    // Parse as program
    var prog *u8 = nil;
    if parser_token_count() > 0 {
        prog = parse_program();
    }

    // Free the temporary token vec
    vec_free(parse_tokens);

    // Restore parser state
    parse_tokens = saved_tokens;
    parse_current = saved_current;
    parse_error_count = saved_errors;

    return prog;
}
